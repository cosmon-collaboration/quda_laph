GCR inverter with Multigrid preconditioning

QudaGaugeParam gauge_param;
QudaInvertParam inv_param;
QudaMultigridParam mg_param;
QudaInvertParam mg_inv_param;
QudaEigParam mg_eig_param[QUDA_MAX_MG_LEVEL];
QudaEigParam eig_param;
bool use_split_grid = false;



  setQudaDefaultMgTestParams();


void setQudaDefaultMgTestParams()
{
  // We give here some default values
  for (int i = 0; i < QUDA_MAX_MG_LEVEL; i++) {
    mg_verbosity[i] = QUDA_SUMMARIZE;
#ifdef QUDA_MMA_AVAILABLE
    mg_setup_use_mma[i] = true;
#else
    mg_setup_use_mma[i] = false;
#endif
    mg_dslash_use_mma[i] = false;
    setup_inv[i] = QUDA_BICGSTAB_INVERTER;
    num_setup_iter[i] = 1;
    setup_tol[i] = 5e-6;
    setup_maxiter[i] = 500;
    setup_maxiter_refresh[i] = 20;
    mu_factor[i] = 1.;
    coarse_solve_type[i] = QUDA_INVALID_SOLVE;
    smoother_solve_type[i] = QUDA_INVALID_SOLVE;
    mg_schwarz_type[i] = QUDA_INVALID_SCHWARZ;
    mg_schwarz_cycle[i] = 1;
    smoother_type[i] = QUDA_MR_INVERTER;
    smoother_tol[i] = 0.25;
    coarse_solver[i] = QUDA_GCR_INVERTER;
    coarse_solver_tol[i] = 0.25;
    coarse_solver_maxiter[i] = 100;
    solver_location[i] = QUDA_CUDA_FIELD_LOCATION;
    setup_location[i] = QUDA_CUDA_FIELD_LOCATION;
    nu_pre[i] = 2;
    nu_post[i] = 2;
    n_block_ortho[i] = 1;
    block_ortho_two_pass[i] = true;

    // Default eigensolver params
    mg_eig[i] = false;
    mg_eig_tol[i] = 1e-3;
    mg_eig_n_ev[i] = nvec[i];
    mg_eig_n_kr[i] = 3 * nvec[i];
    mg_eig_require_convergence[i] = QUDA_BOOLEAN_TRUE;
    mg_eig_type[i] = QUDA_EIG_TR_LANCZOS;
    mg_eig_spectrum[i] = QUDA_SPECTRUM_SR_EIG;
    mg_eig_check_interval[i] = 5;
    mg_eig_max_restarts[i] = 100;
    mg_eig_max_ortho_attempts[i] = 10;
    mg_eig_use_normop[i] = QUDA_BOOLEAN_FALSE;
    mg_eig_use_dagger[i] = QUDA_BOOLEAN_FALSE;
    mg_eig_use_poly_acc[i] = QUDA_BOOLEAN_TRUE;
    mg_eig_poly_deg[i] = 100;
    mg_eig_amin[i] = 1.0;
    mg_eig_amax[i] = -1.0; // use power iterations
    mg_eig_save_prec[i] = QUDA_DOUBLE_PRECISION;

    setup_ca_basis[i] = QUDA_POWER_BASIS;
    setup_ca_basis_size[i] = 4;
    setup_ca_lambda_min[i] = 0.0;
    setup_ca_lambda_max[i] = -1.0; // use power iterations

    coarse_solver_ca_basis[i] = QUDA_POWER_BASIS;
    coarse_solver_ca_basis_size[i] = 4;
    coarse_solver_ca_lambda_min[i] = 0.0;
    coarse_solver_ca_lambda_max[i] = -1.0;

    smoother_solver_ca_basis[i] = QUDA_POWER_BASIS;
    smoother_solver_ca_lambda_min[i] = 0.0;
    smoother_solver_ca_lambda_max[i] = -1.0; // use power iterations
  }
}



  // Parse command line options
  auto app = make_app();
  add_eigen_option_group(app);
  add_deflation_option_group(app);
  add_eofa_option_group(app);
  add_madwf_option_group(app);




  add_multigrid_option_group(app);




void add_multigrid_option_group(std::shared_ptr<QUDAApp> quda_app)
{
  auto opgroup = quda_app->add_option_group("MultiGrid", "Options controlling multigrid");

  // MWTODO: clean this up - code duplication

  auto solve_type_transform = CLI::QUDACheckedTransformer(solve_type_map);

  CLI::QUDACheckedTransformer prec_transform(precision_map);

  opgroup->add_option("--mg-allow-truncation", mg_allow_truncation,
                      "Let multigrid coarsening trucate improvement terms in operators, e.g. dropping asqtad long "
                      "links in a dimension with an aggreation length smaller than 3 (default false)");

  quda_app->add_mgoption(
    opgroup, "--mg-block-size", geo_block_size, CLI::Validator(),
    "Set the geometric block size for the each multigrid levels transfer operator (default 4 4 4 4)");
  quda_app->add_mgoption(opgroup, "--mg-coarse-solve-type", coarse_solve_type, solve_type_transform,
                         "The type of solve to do on each level (direct, direct-pc) (default = solve_type)");

  auto solver_trans = CLI::QUDACheckedTransformer(inverter_type_map);
  quda_app->add_mgoption(opgroup, "--mg-coarse-solver", coarse_solver, solver_trans,
                         "The solver to wrap the V cycle on each level (default gcr, only for levels 1+)");

  quda_app->add_mgoption(opgroup, "--mg-coarse-solver-ca-basis-size", coarse_solver_ca_basis_size, CLI::PositiveNumber,
                         "The basis size to use for CA solver setup of multigrid (default 4)");

  quda_app->add_mgoption(opgroup, "--mg-coarse-solver-ca-basis-type", coarse_solver_ca_basis,
                         CLI::QUDACheckedTransformer(ca_basis_map),
                         "The basis to use for CA solver setup of multigrid(default power)");
  quda_app->add_mgoption(
    opgroup, "--mg-coarse-solver-cheby-basis-eig-max", coarse_solver_ca_lambda_max, CLI::PositiveNumber,
    "Conservative estimate of largest eigenvalue for Chebyshev basis CA solvers in setup of multigrid "
    "(default is to guess with power iterations)");
  quda_app->add_mgoption(
    opgroup, "--mg-coarse-solver-cheby-basis-eig-min", coarse_solver_ca_lambda_min, CLI::PositiveNumber,
    "Conservative estimate of smallest eigenvalue for Chebyshev basis CA solvers in setup of multigrid (default 0)");
  quda_app->add_mgoption(opgroup, "--mg-coarse-solver-maxiter", coarse_solver_maxiter, CLI::PositiveNumber,
                         "The coarse solver maxiter for each level (default 100)");
  quda_app->add_mgoption(opgroup, "--mg-coarse-solver-tol", coarse_solver_tol, CLI::PositiveNumber,
                         "The coarse solver tolerance for each level (default 0.25, only for levels 1+)");
  quda_app->add_mgoption(opgroup, "--mg-eig", mg_eig, CLI::Validator(),
                         "Use the eigensolver on this level (default false)");
  quda_app->add_mgoption(opgroup, "--mg-eig-amax", mg_eig_amax, CLI::PositiveNumber,
                         "The maximum in the polynomial acceleration (default 4.0)");
  quda_app->add_mgoption(opgroup, "--mg-eig-amin", mg_eig_amin, CLI::PositiveNumber,
                         "The minimum in the polynomial acceleration (default 0.1)");
  quda_app->add_mgoption(
    opgroup, "--mg-eig-check-interval", mg_eig_check_interval, CLI::Validator(),
    "Perform a convergence check every nth restart/iteration (only used in Implicit Restart types)");
  quda_app->add_option("--mg-eig-coarse-guess", mg_eig_coarse_guess,
                       "If deflating on the coarse grid, optionally use an initial guess (default = false)");
  quda_app->add_option("--mg-eig-preserve-deflation", mg_eig_preserve_deflation,
                       "If the multigrid operator is updated, preserve generated deflation space (default = false)");
  quda_app->add_mgoption(opgroup, "--mg-eig-max-restarts", mg_eig_max_restarts, CLI::PositiveNumber,
                         "Perform a maximun of n restarts in eigensolver (default 100)");

  quda_app->add_mgoption(
    opgroup, "--mg-eig-max-ortho-attempts", mg_eig_max_ortho_attempts, CLI::PositiveNumber,
    "Perform n iterations of Gram-Schmidt orthonormalisation in the Block TRLM eigensolver (default 10)");
  quda_app->add_mgoption(
    opgroup, "--mg-eig-use-eigen-qr", mg_eig_use_eigen_qr, CLI::Validator(),
    "Use Eigen to eigensolve the upper Hessenberg in IRAM, else use QUDA's QR code. (default true)");
  quda_app->add_mgoption(opgroup, "--mg-eig-ortho-block-size", mg_eig_ortho_block_size, CLI::Validator(),
                         "The block size to use when orthonormalising vectors in hybrid modified Gram-Schmidt");
  quda_app->add_mgoption(opgroup, "--mg-eig-block-size", mg_eig_block_size, CLI::Validator(),
                         "The block size to use in the block variant eigensolver");
  quda_app->add_mgoption(opgroup, "--mg-eig-n-ev", mg_eig_n_ev, CLI::Validator(),
                         "The size of eigenvector search space in the eigensolver");
  quda_app->add_mgoption(opgroup, "--mg-eig-n-kr", mg_eig_n_kr, CLI::Validator(),
                         "The size of the Krylov subspace to use in the eigensolver");
  quda_app->add_mgoption(opgroup, "--mg-eig-n-ev-deflate", mg_eig_n_ev_deflate, CLI::Validator(),
                         "The number of converged eigenpairs that will be used in the deflation routines");
  quda_app->add_mgoption(
    opgroup, "--mg-eig-batched-rotate", mg_eig_batched_rotate, CLI::Validator(),
    "The maximum number of extra eigenvectors the solver may allocate to perform a Ritz rotation.");
  quda_app->add_mgoption(opgroup, "--mg-eig-poly-deg", mg_eig_poly_deg, CLI::PositiveNumber,
                         "Set the degree of the Chebyshev polynomial (default 100)");
  quda_app->add_mgoption(
    opgroup, "--mg-eig-require-convergence", mg_eig_require_convergence,
    CLI::Validator(), "If true, the solver will error out if convergence is not attained. If false, a warning will be given (default true)");

  quda_app->add_mgoption(
    opgroup, "--mg-eig-spectrum", mg_eig_spectrum, CLI::QUDACheckedTransformer(eig_spectrum_map),
    "The spectrum part to be calulated. S=smallest L=largest R=real M=modulus I=imaginary (default SR)");
  quda_app->add_mgoption(opgroup, "--mg-eig-tol", mg_eig_tol, CLI::PositiveNumber,
                         "The tolerance to use in the eigensolver (default 1e-6)");
  quda_app->add_mgoption(opgroup, "--mg-eig-qr-tol", mg_eig_qr_tol, CLI::PositiveNumber,
                         "The tolerance to use in the QR (default 1e-11)");

  quda_app->add_mgoption(opgroup, "--mg-eig-type", mg_eig_type, CLI::QUDACheckedTransformer(eig_type_map),
                         "The type of eigensolver to use (default trlm)");
  quda_app->add_mgoption(opgroup, "--mg-eig-use-dagger", mg_eig_use_dagger, CLI::Validator(),
                         "Solve the MMdag problem instead of M (MMdag if eig-use-normop == true) (default false)");
  quda_app->add_mgoption(opgroup, "--mg-eig-use-normop", mg_eig_use_normop, CLI::Validator(),
                         "Solve the MdagM problem instead of M (MMdag if eig-use-dagger == true) (default false)");
  quda_app->add_mgoption(opgroup, "--mg-eig-use-pc", mg_eig_use_pc, CLI::Validator(),
                         "Solve the Even-Odd preconditioned problem (default false)");
  quda_app->add_mgoption(opgroup, "--mg-eig-use-poly-acc", mg_eig_use_poly_acc, CLI::Validator(),
                         "Use Chebyshev polynomial acceleration in the eigensolver (default true)");
  opgroup->add_option(
    "--mg-generate-all-levels",
    generate_all_levels, "true=generate null-space on all levels, false=generate on level 0 and create other levels from that (default true)");
  opgroup->add_option("--mg-evolve-thin-updates", mg_evolve_thin_updates,
                      "Utilize thin updates for multigrid evolution tests (default false)");
  opgroup->add_option("--mg-generate-nullspace", generate_nullspace,
                      "Generate the null-space vector dynamically (default true, if set false and mg-load-vec isn't "
                      "set, creates free-field null vectors)");
  opgroup->add_option("--mg-levels", mg_levels, "The number of multigrid levels to do (default 2)");

  // TODO
  quda_app->add_mgoption(opgroup, "--mg-load-vec", mg_vec_infile, CLI::Validator(),
                         "Load the vectors <file> for the multigrid_test (requires QIO)");
  quda_app->add_mgoption(opgroup, "--mg-save-vec", mg_vec_outfile, CLI::Validator(),
                         "Save the generated null-space vectors <file> from the multigrid_test (requires QIO)");
  quda_app->add_mgoption(
    opgroup, "--mg-save-partfile", mg_vec_partfile, CLI::Validator(),
    "Whether to save near-null vectors as partfile instead of singlefile (default false; singlefile)");

  quda_app
    ->add_mgoption("--mg-eig-save-prec", mg_eig_save_prec, CLI::Validator(),
                   "If saving eigenvectors, use this precision to save. No-op if mg-eig-save-prec is greater than or "
                   "equal to precision of eigensolver (default = double)")
    ->transform(prec_transform);

  opgroup->add_option(
    "--mg-low-mode-check", low_mode_check,
    "Measure how well the null vector subspace overlaps with the low eigenmode subspace (default false)");
  quda_app->add_mgoption(opgroup, "--mg-mu-factor", mu_factor, CLI::Validator(),
                         "Set the multiplicative factor for the twisted mass mu parameter on each level (default 1)");
  quda_app->add_mgoption(opgroup, "--mg-n-block-ortho", n_block_ortho, CLI::PositiveNumber,
                         "The number of times to run Gram-Schmidt during block orthonormalization (default 1)");
  quda_app->add_mgoption(
    opgroup, "--mg-block-ortho-two-pass", block_ortho_two_pass, CLI::Validator(),
    "Whether to use a two block-orthogonalization when using fixed-point null space vectors (default true)");
  quda_app->add_mgoption(opgroup, "--mg-nu-post", nu_post, CLI::PositiveNumber,
                         "The number of post-smoother applications to do at a given multigrid level (default 2)");
  quda_app->add_mgoption(opgroup, "--mg-nu-pre", nu_pre, CLI::PositiveNumber,
                         "The number of pre-smoother applications to do at a given multigrid level (default 2)");
  quda_app->add_mgoption(opgroup, "--mg-nvec", nvec, CLI::PositiveNumber,
                         "Number of null-space vectors to define the multigrid transfer operator on a given level");
  opgroup->add_option("--mg-oblique-proj-check", oblique_proj_check,
                      "Measure how well the null vector subspace adjusts the low eigenmode subspace (default false)");
  opgroup->add_option("--mg-omega", omega,
                      "The over/under relaxation factor for the smoother of multigrid (default 0.85)");
  opgroup->add_option("--mg-post-orth", post_orthonormalize,
                      "If orthonormalize the vector after inverting in the setup of multigrid (default true)");
  opgroup->add_option("--mg-pre-orth", pre_orthonormalize,
                      "If orthonormalize the vector before inverting in the setup of multigrid (default false)");

  quda_app
    ->add_mgoption(opgroup, "--mg-schwarz-type", mg_schwarz_type, CLI::Validator(),
                   "The type of preconditioning to use (requires MR smoother and GCR setup solver) (default=invalid)")
    ->transform(CLI::QUDACheckedTransformer(schwarz_type_map));
  quda_app->add_mgoption(opgroup, "--mg-schwarz-cycle", mg_schwarz_cycle, CLI::PositiveNumber,
                         "The number of Schwarz cycles to apply per smoother application (default=1)");
  quda_app->add_mgoption(opgroup, "--mg-setup-ca-basis-size", setup_ca_basis_size, CLI::PositiveNumber,
                         "The basis size to use for CA solver setup of multigrid (default 4)");
  quda_app->add_mgoption(opgroup, "--mg-setup-ca-basis-type", setup_ca_basis, CLI::QUDACheckedTransformer(ca_basis_map),
                         "The basis to use for CA solver setup of multigrid(default power)");
  quda_app->add_mgoption(
    opgroup, "--mg-setup-cheby-basis-eig-max", setup_ca_lambda_max, CLI::PositiveNumber,
    "Conservative estimate of largest eigenvalue for Chebyshev basis CA solvers in setup of multigrid "
    "(default is to guess with power iterations)");
  quda_app->add_mgoption(
    opgroup, "--mg-setup-cheby-basis-eig-min", setup_ca_lambda_min, CLI::PositiveNumber,
    "Conservative estimate of smallest eigenvalue for Chebyshev basis CA solvers in setup of multigrid (default 0)");
  quda_app->add_mgoption(opgroup, "--mg-setup-inv", setup_inv, solver_trans,
                         "The inverter to use for the setup of multigrid (default bicgstab)");
  quda_app->add_mgoption(opgroup, "--mg-setup-iters", num_setup_iter, CLI::PositiveNumber,
                         "The number of setup iterations to use for the multigrid (default 1)");

  quda_app->add_mgoption(opgroup, "--mg-setup-location", setup_location, CLI::QUDACheckedTransformer(field_location_map),
                         "The location where the multigrid setup will be computed (default cuda)");
  quda_app->add_mgoption(
    opgroup, "--mg-setup-maxiter", setup_maxiter, CLI::Validator(),
    "The maximum number of solver iterations to use when relaxing on a null space vector (default 500)");
  quda_app->add_mgoption(
    opgroup, "--mg-setup-maxiter-refresh", setup_maxiter_refresh, CLI::Validator(),
    "The maximum number of solver iterations to use when refreshing the pre-existing null space vectors (default 100)");
  quda_app->add_mgoption(opgroup, "--mg-setup-tol", setup_tol, CLI::Validator(),
                         "The tolerance to use for the setup of multigrid (default 5e-6)");

  opgroup->add_option("--mg-setup-type", setup_type, "The type of setup to use for the multigrid (default null)")
    ->transform(CLI::QUDACheckedTransformer(setup_type_map));

  opgroup
    ->add_option(
      "--mg-staggered-coarsen-type",
      staggered_transfer_type, "The type of coarsening to use for the top level staggered operator (aggregate, kd-coarse, kd-optimized (default))")
    ->transform(CLI::QUDACheckedTransformer(transfer_type_map));

  opgroup->add_option("--mg-staggered-kd-dagger-approximation", mg_staggered_kd_dagger_approximation,
                      "Use the dagger approximation to Xinv, which is X^dagger (default = false)");

  quda_app->add_mgoption(opgroup, "--mg-smoother", smoother_type, solver_trans,
                         "The smoother to use for multigrid (default mr)");
  quda_app->add_mgoption(opgroup, "--mg-smoother-ca-basis-type", smoother_solver_ca_basis,
                         CLI::QUDACheckedTransformer(ca_basis_map),
                         "The basis to use for CA solver smoothers in multigrid (default power)");
  quda_app->add_mgoption(opgroup, "--mg-smoother-cheby-basis-eig-max", smoother_solver_ca_lambda_max, CLI::PositiveNumber,
                         "Conservative estimate of largest eigenvalue for CA solvers used as a multigrid smoother "
                         "(default is to guess with power iterations)");
  quda_app->add_mgoption(
    opgroup, "--mg-smoother-cheby-basis-eig-min", smoother_solver_ca_lambda_min, CLI::PositiveNumber,
    "Conservative estimate of smallest eigenvalue for CA solvers used as a multigrid smoother (default 0)");
  opgroup
    ->add_option("--mg-smoother-halo-prec", smoother_halo_prec,
                 "The smoother halo precision (applies to all levels - defaults to null_precision)")
    ->transform(prec_transform);

  quda_app->add_mgoption(opgroup, "--mg-smoother-solve-type", smoother_solve_type, solve_type_transform,
                         "The type of solve to do in smoother (direct, direct-pc (default) )");
  quda_app->add_mgoption(opgroup, "--mg-smoother-tol", smoother_tol, CLI::Validator(),
                         "The smoother tolerance to use for each multigrid (default 0.25)");
  quda_app->add_mgoption(opgroup, "--mg-solve-location", solver_location, CLI::QUDACheckedTransformer(field_location_map),
                         "The location where the multigrid solver will run (default cuda)");
  quda_app->add_mgoption(opgroup, "--mg-setup-use-mma", mg_setup_use_mma, CLI::Validator(),
                         "Whether multigrid setup should use mma (default to true when supported)");
  quda_app->add_mgoption(opgroup, "--mg-dslash-use-mma", mg_dslash_use_mma, CLI::Validator(),
                         "Whether multigrid dslash should use mma (default to false)");
  quda_app->add_mgoption(opgroup, "--mg-verbosity", mg_verbosity, CLI::QUDACheckedTransformer(verbosity_map),
                         "The verbosity to use on each level of the multigrid (default summarize)");

}









  inv_param = newQudaInvertParam();
  mg_param = newQudaMultigridParam();
  mg_inv_param = newQudaInvertParam();
  eig_param = newQudaEigParam();

  if (inv_multigrid) {



    setQudaMgSolveTypes();


void setQudaMgSolveTypes()
{
  for (int i = 0; i < QUDA_MAX_MG_LEVEL; i++) {
    if (coarse_solve_type[i] == QUDA_INVALID_SOLVE) coarse_solve_type[i] = solve_type;
    if (smoother_solve_type[i] == QUDA_INVALID_SOLVE) smoother_solve_type[i] = QUDA_DIRECT_PC_SOLVE;
  }
}





    setMultigridInvertParam(inv_param);

void setMultigridInvertParam(QudaInvertParam &inv_param)
{
  inv_param.Ls = 1;

  inv_param.cpu_prec = cpu_prec;
  inv_param.cuda_prec = cuda_prec;
  inv_param.cuda_prec_sloppy = cuda_prec_sloppy;

  inv_param.cuda_prec_precondition = cuda_prec_precondition;
  inv_param.cuda_prec_eigensolver = cuda_prec_eigensolver;
  inv_param.gamma_basis = QUDA_DEGRAND_ROSSI_GAMMA_BASIS;
  inv_param.dirac_order = QUDA_DIRAC_ORDER;

  if (kappa == -1.0) {
    inv_param.mass = mass;
    inv_param.kappa = 1.0 / (2.0 * (1 + 3 / anisotropy + mass));
  } else {
    inv_param.kappa = kappa;
    inv_param.mass = 0.5 / kappa - (1 + 3 / anisotropy);
  }

  if (dslash_type == QUDA_CLOVER_WILSON_DSLASH || dslash_type == QUDA_TWISTED_CLOVER_DSLASH
      || dslash_type == QUDA_CLOVER_HASENBUSCH_TWIST_DSLASH) {
    inv_param.clover_cpu_prec = cpu_prec;
    inv_param.clover_cuda_prec = cuda_prec;
    inv_param.clover_cuda_prec_sloppy = cuda_prec_sloppy;
    inv_param.clover_cuda_prec_precondition = cuda_prec_precondition;
    inv_param.clover_cuda_prec_eigensolver = cuda_prec_eigensolver;
    inv_param.clover_cuda_prec_refinement_sloppy = cuda_prec_refinement_sloppy;
    inv_param.clover_order = QUDA_PACKED_CLOVER_ORDER;
    // Use kappa * csw or supplied clover_coeff
    inv_param.clover_csw = clover_csw;
    if (clover_coeff == 0.0) {
      inv_param.clover_coeff = clover_csw * inv_param.kappa;
    } else {
      inv_param.clover_coeff = clover_coeff;
    }
    inv_param.compute_clover_trlog = compute_clover_trlog ? 1 : 0;
  }

  inv_param.input_location = QUDA_CPU_FIELD_LOCATION;
  inv_param.output_location = QUDA_CPU_FIELD_LOCATION;

  inv_param.dslash_type = dslash_type;

  if (dslash_type == QUDA_TWISTED_MASS_DSLASH || dslash_type == QUDA_TWISTED_CLOVER_DSLASH) {
    inv_param.mu = mu;
    inv_param.epsilon = epsilon;
    inv_param.twist_flavor = twist_flavor;
    inv_param.Ls = (inv_param.twist_flavor == QUDA_TWIST_NONDEG_DOUBLET) ? 2 : 1;

    if (twist_flavor == QUDA_TWIST_NONDEG_DOUBLET) {
      printfQuda("Twisted-mass doublet non supported (yet)\n");
      exit(0);
    }
  }

  inv_param.dagger = QUDA_DAG_NO;
  inv_param.mass_normalization = QUDA_KAPPA_NORMALIZATION;

  // do we want full solution or single-parity solution
  inv_param.solution_type = QUDA_MAT_SOLUTION;

  // do we want to use an even-odd preconditioned solve or not
  inv_param.solve_type = solve_type;
  inv_param.matpc_type = matpc_type;

  inv_param.inv_type = QUDA_GCR_INVERTER;

  inv_param.verbosity = verbosity;
  inv_param.verbosity_precondition = mg_verbosity[0];

  inv_param.inv_type_precondition = QUDA_MG_INVERTER;
  inv_param.pipeline = pipeline;
  inv_param.gcrNkrylov = gcrNkrylov;
  inv_param.tol = tol;

  // require both L2 relative and heavy quark residual to determine convergence
  inv_param.residual_type = static_cast<QudaResidualType>(QUDA_L2_RELATIVE_RESIDUAL);
  inv_param.tol_hq = tol_hq; // specify a tolerance for the residual for heavy quark residual

  // Offsets used only by multi-shift solver
  // should be set in application
  inv_param.num_offset = multishift;
  for (int i = 0; i < inv_param.num_offset; i++) inv_param.offset[i] = 0.06 + i * i * 0.1;
  // these can be set individually
  for (int i = 0; i < inv_param.num_offset; i++) {
    inv_param.tol_offset[i] = inv_param.tol;
    inv_param.tol_hq_offset[i] = inv_param.tol_hq;
  }
  inv_param.maxiter = niter;
  inv_param.reliable_delta = reliable_delta;

  // domain decomposition preconditioner is disabled when using MG
  inv_param.schwarz_type = QUDA_INVALID_SCHWARZ;
  inv_param.accelerator_type_precondition = precon_accelerator_type;
  inv_param.precondition_cycle = precon_schwarz_cycle;
  inv_param.tol_precondition = 1e-1;
  inv_param.maxiter_precondition = 1;
  inv_param.ca_basis_precondition = ca_basis_precondition;
  inv_param.ca_lambda_min_precondition = ca_lambda_min_precondition;
  inv_param.ca_lambda_max_precondition = ca_lambda_max_precondition;
  inv_param.omega = 1.0;

  // Whether or not to use native BLAS LAPACK
  inv_param.native_blas_lapack = (native_blas_lapack ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE);

  inv_param.struct_size = sizeof(inv_param);
}









    // Set sub structures
    mg_param.invert_param = &mg_inv_param;
    for (int i = 0; i < mg_levels; i++) {
      if (mg_eig[i]) {
        mg_eig_param[i] = newQudaEigParam();


        setMultigridEigParam(mg_eig_param[i], i);



// Parameters defining the eigensolver
void setMultigridEigParam(QudaEigParam &mg_eig_param, int level)
{
  mg_eig_param.eig_type = mg_eig_type[level];
  mg_eig_param.spectrum = mg_eig_spectrum[level];
  if ((mg_eig_type[level] == QUDA_EIG_TR_LANCZOS || mg_eig_type[level] == QUDA_EIG_BLK_TR_LANCZOS)
      && !(mg_eig_spectrum[level] == QUDA_SPECTRUM_LR_EIG || mg_eig_spectrum[level] == QUDA_SPECTRUM_SR_EIG)) {
    errorQuda("Only real spectrum type (LR or SR) can be passed to the a Lanczos type solver");
  }

  mg_eig_param.ortho_block_size = mg_eig_ortho_block_size[level];
  mg_eig_param.block_size
    = (mg_eig_param.eig_type == QUDA_EIG_TR_LANCZOS || mg_eig_param.eig_type == QUDA_EIG_IR_ARNOLDI) ?
    1 :
    mg_eig_block_size[level];
  mg_eig_param.n_ev = mg_eig_n_ev[level];
  mg_eig_param.n_kr = mg_eig_n_kr[level];
  mg_eig_param.n_conv = nvec[level];

  // Inverters will deflate only this number of vectors.
  if (mg_eig_n_ev_deflate[level] > 0 && mg_eig_n_ev_deflate[level] < mg_eig_param.n_conv)
    mg_eig_param.n_ev_deflate = mg_eig_n_ev_deflate[level];
  else if (mg_eig_n_ev_deflate[level] > mg_eig_param.n_conv)
    errorQuda("Can not deflate more than nvec[%d] eigenvectors.", mg_eig_param.n_conv);
  else {
    mg_eig_param.n_ev_deflate = mg_eig_param.n_conv;
    mg_eig_n_ev_deflate[level] = mg_eig_param.n_conv;
  }

  mg_eig_param.batched_rotate = mg_eig_batched_rotate[level];
  mg_eig_param.require_convergence = mg_eig_require_convergence[level] ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

  mg_eig_param.tol = mg_eig_tol[level];
  mg_eig_param.qr_tol = mg_eig_qr_tol[level];
  mg_eig_param.check_interval = mg_eig_check_interval[level];
  mg_eig_param.max_restarts = mg_eig_max_restarts[level];
  mg_eig_param.max_ortho_attempts = mg_eig_max_ortho_attempts[level];

  mg_eig_param.compute_svd = QUDA_BOOLEAN_FALSE;
  mg_eig_param.compute_gamma5 = QUDA_BOOLEAN_FALSE;
  mg_eig_param.use_norm_op = mg_eig_use_normop[level] ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  mg_eig_param.use_dagger = mg_eig_use_dagger[level] ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

  mg_eig_param.use_eigen_qr = mg_eig_use_eigen_qr[level] ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  mg_eig_param.use_poly_acc = mg_eig_use_poly_acc[level] ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  mg_eig_param.poly_deg = mg_eig_poly_deg[level];
  mg_eig_param.a_min = mg_eig_amin[level];
  mg_eig_param.a_max = mg_eig_amax[level];

  // set file i/o parameters
  // Give empty strings, Multigrid will handle IO.
  strcpy(mg_eig_param.vec_infile, "");
  strcpy(mg_eig_param.vec_outfile, "");
  mg_eig_param.save_prec = mg_eig_save_prec[level];
  mg_eig_param.io_parity_inflate = QUDA_BOOLEAN_FALSE;
  mg_eig_param.partfile = QUDA_BOOLEAN_FALSE; // ignored

  mg_eig_param.struct_size = sizeof(mg_eig_param);
}





        mg_param.eig_param[i] = &mg_eig_param[i];
      } else {
        mg_param.eig_param[i] = nullptr;
      }
    }
    // Set MG
    setMultigridParam(mg_param);


void setMultigridParam(QudaMultigridParam &mg_param)
{
  QudaInvertParam &inv_param = *mg_param.invert_param; // this will be used to setup SolverParam parent in MGParam class

  // Whether or not to use native BLAS LAPACK
  inv_param.native_blas_lapack = (native_blas_lapack ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE);

  inv_param.Ls = 1;

  inv_param.cpu_prec = cpu_prec;
  inv_param.cuda_prec = cuda_prec;
  inv_param.cuda_prec_sloppy = cuda_prec_sloppy;
  inv_param.cuda_prec_precondition = cuda_prec_precondition;
  inv_param.cuda_prec_eigensolver = cuda_prec_eigensolver;
  inv_param.gamma_basis = QUDA_DEGRAND_ROSSI_GAMMA_BASIS;
  inv_param.dirac_order = QUDA_DIRAC_ORDER;

  if (kappa == -1.0) {
    inv_param.mass = mass;
    inv_param.kappa = 1.0 / (2.0 * (1 + 3 / anisotropy + mass));
  } else {
    inv_param.kappa = kappa;
    inv_param.mass = 0.5 / kappa - (1 + 3 / anisotropy);
  }

  if (dslash_type == QUDA_CLOVER_WILSON_DSLASH || dslash_type == QUDA_TWISTED_CLOVER_DSLASH
      || dslash_type == QUDA_CLOVER_HASENBUSCH_TWIST_DSLASH) {
    inv_param.clover_cpu_prec = cpu_prec;
    inv_param.clover_cuda_prec = cuda_prec;
    inv_param.clover_cuda_prec_sloppy = cuda_prec_sloppy;
    inv_param.clover_cuda_prec_precondition = cuda_prec_precondition;
    inv_param.clover_cuda_prec_eigensolver = cuda_prec_eigensolver;
    inv_param.clover_cuda_prec_refinement_sloppy = cuda_prec_refinement_sloppy;
    inv_param.clover_order = QUDA_PACKED_CLOVER_ORDER;
    // Use kappa * csw or supplied clover_coeff
    inv_param.clover_csw = clover_csw;
    if (clover_coeff == 0.0) {
      inv_param.clover_coeff = clover_csw * inv_param.kappa;
    } else {
      inv_param.clover_coeff = clover_coeff;
    }
    inv_param.compute_clover_trlog = compute_clover_trlog ? 1 : 0;
  }

  inv_param.input_location = QUDA_CPU_FIELD_LOCATION;
  inv_param.output_location = QUDA_CPU_FIELD_LOCATION;

  inv_param.dslash_type = dslash_type;

  if (dslash_type == QUDA_TWISTED_MASS_DSLASH || dslash_type == QUDA_TWISTED_CLOVER_DSLASH) {
    inv_param.mu = mu;
    inv_param.epsilon = epsilon;
    inv_param.twist_flavor = twist_flavor;
    inv_param.Ls = (inv_param.twist_flavor == QUDA_TWIST_NONDEG_DOUBLET) ? 2 : 1;

    if (twist_flavor == QUDA_TWIST_NONDEG_DOUBLET) {
      printfQuda("Twisted-mass doublet non supported (yet)\n");
      exit(0);
    }
  }

  inv_param.dagger = QUDA_DAG_NO;
  inv_param.mass_normalization = QUDA_KAPPA_NORMALIZATION;

  inv_param.matpc_type = matpc_type;
  inv_param.solution_type = QUDA_MAT_SOLUTION;

  inv_param.solve_type = QUDA_DIRECT_SOLVE;

  mg_param.invert_param = &inv_param;
  mg_param.n_level = mg_levels;
  for (int i = 0; i < mg_param.n_level; i++) {
    for (int j = 0; j < 4; j++) {
      // if not defined use 4
      mg_param.geo_block_size[i][j] = geo_block_size[i][j] ? geo_block_size[i][j] : 4;
    }
    for (int j = 4; j < QUDA_MAX_DIM; j++) mg_param.geo_block_size[i][j] = 1;
    mg_param.use_eig_solver[i] = mg_eig[i] ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
    mg_param.verbosity[i] = mg_verbosity[i];
    mg_param.setup_use_mma[i] = mg_setup_use_mma[i] ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
    mg_param.dslash_use_mma[i] = mg_dslash_use_mma[i] ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
    mg_param.setup_inv_type[i] = setup_inv[i];
    mg_param.num_setup_iter[i] = num_setup_iter[i];
    mg_param.setup_tol[i] = setup_tol[i];
    mg_param.setup_maxiter[i] = setup_maxiter[i];
    mg_param.setup_maxiter_refresh[i] = setup_maxiter_refresh[i];

    // Basis to use for CA solver setups
    mg_param.setup_ca_basis[i] = setup_ca_basis[i];

    // Basis size for CA solver setup
    mg_param.setup_ca_basis_size[i] = setup_ca_basis_size[i];

    // Minimum and maximum eigenvalue for Chebyshev CA basis setup
    mg_param.setup_ca_lambda_min[i] = setup_ca_lambda_min[i];
    mg_param.setup_ca_lambda_max[i] = setup_ca_lambda_max[i];

    mg_param.spin_block_size[i] = 1;
    mg_param.n_vec[i] = nvec[i] == 0 ? 24 : nvec[i]; // default to 24 vectors if not set
    mg_param.n_block_ortho[i] = n_block_ortho[i];    // number of times to Gram-Schmidt
    mg_param.block_ortho_two_pass[i]
      = block_ortho_two_pass[i] ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE; // whether to use a two-pass block ortho
    mg_param.precision_null[i] = prec_null;                               // precision to store the null-space basis
    mg_param.smoother_halo_precision[i] = smoother_halo_prec; // precision of the halo exchange in the smoother
    mg_param.nu_pre[i] = nu_pre[i];
    mg_param.nu_post[i] = nu_post[i];
    mg_param.mu_factor[i] = mu_factor[i];

    mg_param.cycle_type[i] = QUDA_MG_CYCLE_RECURSIVE;

    // Is not a staggered solve, always aggregate
    mg_param.transfer_type[i] = QUDA_TRANSFER_AGGREGATE;

    // set the coarse solver wrappers including bottom solver
    mg_param.coarse_solver[i] = coarse_solver[i];
    mg_param.coarse_solver_tol[i] = coarse_solver_tol[i];
    mg_param.coarse_solver_maxiter[i] = coarse_solver_maxiter[i];

    // Basis to use for CA coarse solvers
    mg_param.coarse_solver_ca_basis[i] = coarse_solver_ca_basis[i];

    // Basis size for CA coarse solvers
    mg_param.coarse_solver_ca_basis_size[i] = coarse_solver_ca_basis_size[i];

    // Minimum and maximum eigenvalue for Chebyshev CA basis
    mg_param.coarse_solver_ca_lambda_min[i] = coarse_solver_ca_lambda_min[i];
    mg_param.coarse_solver_ca_lambda_max[i] = coarse_solver_ca_lambda_max[i];

    mg_param.smoother[i] = smoother_type[i];

    // set the smoother / bottom solver tolerance (for MR smoothing this will be ignored)
    mg_param.smoother_tol[i] = smoother_tol[i];

    // set to QUDA_DIRECT_SOLVE for no even/odd preconditioning on the smoother
    // set to QUDA_DIRECT_PC_SOLVE for to enable even/odd preconditioning on the smoother
    mg_param.smoother_solve_type[i] = smoother_solve_type[i];

    // set to QUDA_ADDITIVE_SCHWARZ for Additive Schwarz precondioned smoother (presently only impelemented for MR)
    mg_param.smoother_schwarz_type[i] = mg_schwarz_type[i];

    // if using Schwarz preconditioning then use local reductions only
    mg_param.global_reduction[i] = (mg_schwarz_type[i] == QUDA_INVALID_SCHWARZ) ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

    // set number of Schwarz cycles to apply
    mg_param.smoother_schwarz_cycle[i] = mg_schwarz_cycle[i];

    // Basis to use for CA smoothers
    mg_param.smoother_solver_ca_basis[i] = smoother_solver_ca_basis[i];

    // Minimum and maximum eigenvalue for Chebyshev CA basis smoothers
    mg_param.smoother_solver_ca_lambda_min[i] = smoother_solver_ca_lambda_min[i];
    mg_param.smoother_solver_ca_lambda_max[i] = smoother_solver_ca_lambda_max[i];

    // Set set coarse_grid_solution_type: this defines which linear
    // system we are solving on a given level
    // * QUDA_MAT_SOLUTION - we are solving the full system and inject
    //   a full field into coarse grid
    // * QUDA_MATPC_SOLUTION - we are solving the e/o-preconditioned
    //   system, and only inject single parity field into coarse grid
    //
    // Multiple possible scenarios here
    //
    // 1. **Direct outer solver and direct smoother**: here we use
    // full-field residual coarsening, and everything involves the
    // full system so coarse_grid_solution_type = QUDA_MAT_SOLUTION
    //
    // 2. **Direct outer solver and preconditioned smoother**: here,
    // only the smoothing uses e/o preconditioning, so
    // coarse_grid_solution_type = QUDA_MAT_SOLUTION_TYPE.
    // We reconstruct the full residual prior to coarsening after the
    // pre-smoother, and then need to project the solution for post
    // smoothing.
    //
    // 3. **Preconditioned outer solver and preconditioned smoother**:
    // here we use single-parity residual coarsening throughout, so
    // coarse_grid_solution_type = QUDA_MATPC_SOLUTION.  This is a bit
    // questionable from a theoretical point of view, since we don't
    // coarsen the preconditioned operator directly, rather we coarsen
    // the full operator and preconditioned that, but it just works.
    // This is the optimal combination in general for Wilson-type
    // operators: although there is an occasional increase in
    // iteration or two), by working completely in the preconditioned
    // space, we save the cost of reconstructing the full residual
    // from the preconditioned smoother, and re-projecting for the
    // subsequent smoother, as well as reducing the cost of the
    // ancillary blas operations in the coarse-grid solve.
    //
    // Note, we cannot use preconditioned outer solve with direct
    // smoother
    //
    // Finally, we have to treat the top level carefully: for all
    // other levels the entry into and out of the grid will be a
    // full-field, which we can then work in Schur complement space or
    // not (e.g., freedom to choose coarse_grid_solution_type).  For
    // the top level, if the outer solver is for the preconditioned
    // system, then we must use preconditoning, e.g., option 3.) above.

    if (i == 0) { // top-level treatment
      if (coarse_solve_type[0] != solve_type)
        errorQuda("Mismatch between top-level MG solve type %d and outer solve type %d", coarse_solve_type[0],
                  solve_type);

      if (solve_type == QUDA_DIRECT_SOLVE) {
        mg_param.coarse_grid_solution_type[i] = QUDA_MAT_SOLUTION;
      } else if (solve_type == QUDA_DIRECT_PC_SOLVE) {
        mg_param.coarse_grid_solution_type[i] = QUDA_MATPC_SOLUTION;
      } else {
        errorQuda("Unexpected solve_type = %d\n", solve_type);
      }

    } else {

      if (coarse_solve_type[i] == QUDA_DIRECT_SOLVE) {
        mg_param.coarse_grid_solution_type[i] = QUDA_MAT_SOLUTION;
      } else if (coarse_solve_type[i] == QUDA_DIRECT_PC_SOLVE) {
        mg_param.coarse_grid_solution_type[i] = QUDA_MATPC_SOLUTION;
      } else {
        errorQuda("Unexpected solve_type = %d\n", coarse_solve_type[i]);
      }
    }

    mg_param.omega[i] = omega; // over/under relaxation factor

    mg_param.location[i] = solver_location[i];
    mg_param.setup_location[i] = setup_location[i];
  }

  // whether to run GPU setup but putting temporaries into mapped (slow CPU) memory
  mg_param.setup_minimize_memory = QUDA_BOOLEAN_FALSE;

  // only coarsen the spin on the first restriction
  mg_param.spin_block_size[0] = 2;

  mg_param.setup_type = setup_type;
  mg_param.pre_orthonormalize = pre_orthonormalize ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  mg_param.post_orthonormalize = post_orthonormalize ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

  mg_param.compute_null_vector = generate_nullspace ? QUDA_COMPUTE_NULL_VECTOR_YES : QUDA_COMPUTE_NULL_VECTOR_NO;

  mg_param.generate_all_levels = generate_all_levels ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

  mg_param.run_verify = verify_results ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  mg_param.run_low_mode_check = low_mode_check ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  mg_param.run_oblique_proj_check = oblique_proj_check ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

  // Whether or not to use thin restarts in the evolve tests
  mg_param.thin_update_only = mg_evolve_thin_updates ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

  // whether or not to let MG coarsening drop improvements
  // ex: for asqtad, dropping the long links for aggregation dimensions smaller than 3
  mg_param.allow_truncation = mg_allow_truncation ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

  // whether or not to use the dagger approximation to Xinv, which is X^dagger
  mg_param.staggered_kd_dagger_approximation
    = mg_staggered_kd_dagger_approximation ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

  // set file i/o parameters
  for (int i = 0; i < mg_param.n_level; i++) {
    safe_strcpy(mg_param.vec_infile[i], mg_vec_infile[i], 256, "mg_vec_infile[" + std::to_string(i) + "]");
    safe_strcpy(mg_param.vec_outfile[i], mg_vec_outfile[i], 256, "mg_vec_outfile[" + std::to_string(i) + "]");
    if (mg_vec_infile[i].size() > 0) mg_param.vec_load[i] = QUDA_BOOLEAN_TRUE;
    if (mg_vec_outfile[i].size() > 0) mg_param.vec_store[i] = QUDA_BOOLEAN_TRUE;
    mg_param.mg_vec_partfile[i] = mg_vec_partfile[i] ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  }

  mg_param.coarse_guess = mg_eig_coarse_guess ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

  mg_param.struct_size = sizeof(mg_param);

  // these need to tbe set for now but are actually ignored by the MG setup
  // needed to make it pass the initialization test
  inv_param.inv_type = QUDA_GCR_INVERTER;
  inv_param.tol = 1e-10;
  inv_param.maxiter = 1000;
  inv_param.reliable_delta = reliable_delta;
  inv_param.gcrNkrylov = 10;

  inv_param.verbosity = verbosity;
  inv_param.verbosity_precondition = verbosity;

  // Use kappa * csw or supplied clover_coeff
  inv_param.clover_csw = clover_csw;
  if (clover_coeff == 0.0) {
    inv_param.clover_coeff = clover_csw * inv_param.kappa;
  } else {
    inv_param.clover_coeff = clover_coeff;
  }
}






  } else {
    setInvertParam(inv_param);


void setInvertParam(QudaInvertParam &inv_param)
{
  // Set dslash type
  inv_param.dslash_type = dslash_type;

  // Use kappa or mass normalisation
  if (kappa == -1.0) {
    inv_param.mass = mass;
    inv_param.kappa = 1.0 / (2.0 * (1 + 3 / anisotropy + mass));
    if (dslash_type == QUDA_LAPLACE_DSLASH) inv_param.kappa = 1.0 / (8 + mass);
  } else {
    inv_param.kappa = kappa;
    inv_param.mass = 0.5 / kappa - (1.0 + 3.0 / anisotropy);
    if (dslash_type == QUDA_LAPLACE_DSLASH) inv_param.mass = 1.0 / kappa - 8.0;
  }
  if (getVerbosity() >= QUDA_DEBUG_VERBOSE)
    printfQuda("Kappa = %.8f Mass = %.8f\n", inv_param.kappa, inv_param.mass);

  // Use 3D or 4D laplace
  inv_param.laplace3D = laplace3D;

  // Some fermion specific parameters
  if (dslash_type == QUDA_TWISTED_MASS_DSLASH || dslash_type == QUDA_TWISTED_CLOVER_DSLASH) {
    inv_param.mu = mu;
    inv_param.epsilon = epsilon;
    inv_param.twist_flavor = twist_flavor;
    inv_param.Ls = (inv_param.twist_flavor == QUDA_TWIST_NONDEG_DOUBLET) ? 2 : 1;
  } else if (dslash_type == QUDA_DOMAIN_WALL_DSLASH || dslash_type == QUDA_DOMAIN_WALL_4D_DSLASH
             || dslash_type == QUDA_MOBIUS_DWF_DSLASH || dslash_type == QUDA_MOBIUS_DWF_EOFA_DSLASH) {
    inv_param.m5 = m5;
    kappa5 = 0.5 / (5 + inv_param.m5);
    inv_param.Ls = Lsdim;
    for (int k = 0; k < Lsdim; k++) { // for mobius only
      // b5[k], c[k] values are chosen for arbitrary values,
      // but the difference of them are same as 1.0
      inv_param.b_5[k] = b5;
      inv_param.c_5[k] = c5;
    }
    inv_param.eofa_pm = eofa_pm;
    inv_param.eofa_shift = eofa_shift;
    inv_param.mq1 = eofa_mq1;
    inv_param.mq2 = eofa_mq2;
    inv_param.mq3 = eofa_mq3;
  } else {
    inv_param.Ls = 1;
  }

  // Set clover specific parameters
  if (dslash_type == QUDA_CLOVER_WILSON_DSLASH || dslash_type == QUDA_TWISTED_CLOVER_DSLASH
      || dslash_type == QUDA_CLOVER_HASENBUSCH_TWIST_DSLASH) {
    inv_param.clover_cpu_prec = cpu_prec;
    inv_param.clover_cuda_prec = cuda_prec;
    inv_param.clover_cuda_prec_sloppy = cuda_prec_sloppy;
    inv_param.clover_cuda_prec_precondition = cuda_prec_precondition;
    inv_param.clover_cuda_prec_eigensolver = cuda_prec_eigensolver;
    inv_param.clover_cuda_prec_refinement_sloppy = cuda_prec_refinement_sloppy;
    inv_param.clover_order = QUDA_PACKED_CLOVER_ORDER;
    // Use kappa * csw or supplied clover_coeff
    inv_param.clover_csw = clover_csw;
    if (clover_coeff == 0.0) {
      inv_param.clover_coeff = clover_csw * inv_param.kappa;
    } else {
      inv_param.clover_coeff = clover_coeff;
    }
    inv_param.compute_clover_trlog = compute_clover_trlog ? 1 : 0;
  }

  // General parameter setup
  inv_param.inv_type = inv_type;
  inv_param.solution_type = solution_type;
  inv_param.solve_type = solve_type;
  inv_param.matpc_type = matpc_type;
  inv_param.dagger = QUDA_DAG_NO;
  inv_param.mass_normalization = normalization;
  inv_param.solver_normalization = QUDA_DEFAULT_NORMALIZATION;
  inv_param.pipeline = pipeline;
  inv_param.Nsteps = 10;
  inv_param.gcrNkrylov = gcrNkrylov;
  inv_param.ca_basis = ca_basis;
  inv_param.ca_lambda_min = ca_lambda_min;
  inv_param.ca_lambda_max = ca_lambda_max;
  inv_param.tol = tol;
  inv_param.tol_restart = tol_restart;
  if (tol_hq == 0 && tol == 0) errorQuda("qudaInvert: requesting zero residual");

  // require both L2 relative and heavy quark residual to determine convergence
  inv_param.residual_type = static_cast<QudaResidualType_s>(0);
  inv_param.residual_type = (tol != 0) ?
    static_cast<QudaResidualType_s>(inv_param.residual_type | QUDA_L2_RELATIVE_RESIDUAL) :
    inv_param.residual_type;
  inv_param.residual_type = (tol_hq != 0) ?
    static_cast<QudaResidualType_s>(inv_param.residual_type | QUDA_HEAVY_QUARK_RESIDUAL) :
    inv_param.residual_type;

  inv_param.tol_hq = tol_hq; // specify a tolerance for the residual for heavy quark residual

  // Offsets used only by multi-shift solver
  // These should be set in the application code. We set the them here by way of
  // example
  inv_param.num_offset = multishift;
  for (int i = 0; i < inv_param.num_offset; i++) inv_param.offset[i] = 0.06 + i * i * 0.1;
  // these can be set individually
  for (int i = 0; i < inv_param.num_offset; i++) {
    inv_param.tol_offset[i] = inv_param.tol;
    inv_param.tol_hq_offset[i] = inv_param.tol_hq;
  }
  inv_param.maxiter = niter;
  inv_param.reliable_delta = reliable_delta;
  inv_param.use_alternative_reliable = alternative_reliable;
  inv_param.use_sloppy_partial_accumulator = 0;
  inv_param.solution_accumulator_pipeline = solution_accumulator_pipeline;
  inv_param.max_res_increase = max_res_increase;
  inv_param.max_res_increase_total = max_res_increase_total;

  // domain decomposition preconditioner parameters
  inv_param.inv_type_precondition = precon_type;

  inv_param.schwarz_type = precon_schwarz_type;
  inv_param.accelerator_type_precondition = precon_accelerator_type;

  inv_param.madwf_diagonal_suppressor = madwf_diagonal_suppressor;
  inv_param.madwf_ls = madwf_ls;

  inv_param.madwf_null_miniter = madwf_null_miniter;
  inv_param.madwf_null_tol = madwf_null_tol;
  inv_param.madwf_train_maxiter = madwf_train_maxiter;

  inv_param.madwf_param_load = madwf_param_load ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  inv_param.madwf_param_save = madwf_param_save ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

  safe_strcpy(inv_param.madwf_param_infile, madwf_param_infile, 256, "madwf_param_infile");
  safe_strcpy(inv_param.madwf_param_outfile, madwf_param_outfile, 256, "madwf_param_outfile");

  inv_param.precondition_cycle = precon_schwarz_cycle;
  inv_param.tol_precondition = tol_precondition;
  inv_param.maxiter_precondition = maxiter_precondition;
  inv_param.ca_basis_precondition = ca_basis_precondition;
  inv_param.ca_lambda_min_precondition = ca_lambda_min_precondition;
  inv_param.ca_lambda_max_precondition = ca_lambda_max_precondition;
  inv_param.verbosity_precondition = verbosity_precondition;
  inv_param.cuda_prec_precondition = cuda_prec_precondition;
  inv_param.cuda_prec_eigensolver = cuda_prec_eigensolver;
  inv_param.omega = 1.0;

  inv_param.cpu_prec = cpu_prec;
  inv_param.cuda_prec = cuda_prec;
  inv_param.cuda_prec_sloppy = cuda_prec_sloppy;
  inv_param.cuda_prec_refinement_sloppy = cuda_prec_refinement_sloppy;
  inv_param.gamma_basis = QUDA_DEGRAND_ROSSI_GAMMA_BASIS;
  inv_param.dirac_order = QUDA_DIRAC_ORDER;

  inv_param.input_location = QUDA_CPU_FIELD_LOCATION;
  inv_param.output_location = QUDA_CPU_FIELD_LOCATION;

  inv_param.verbosity = verbosity;

  inv_param.extlib_type = solver_ext_lib;

  // Whether or not to use native BLAS LAPACK
  inv_param.native_blas_lapack = (native_blas_lapack ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE);

  // Whether or not use fused kernels for Mobius
  inv_param.use_mobius_fused_kernel = use_mobius_fused_kernel ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

  inv_param.struct_size = sizeof(inv_param);
}








  }




  if (inv_deflate) {
    setEigParam(eig_param);



void setEigParam(QudaEigParam &eig_param)
{
  eig_param.eig_type = eig_type;
  eig_param.spectrum = eig_spectrum;
  if ((eig_type == QUDA_EIG_TR_LANCZOS || eig_type == QUDA_EIG_BLK_TR_LANCZOS)
      && !(eig_spectrum == QUDA_SPECTRUM_LR_EIG || eig_spectrum == QUDA_SPECTRUM_SR_EIG)) {
    errorQuda("Only real spectrum type (LR or SR) can be passed to Lanczos type solver.");
  }

  // The solver will exit when n_conv extremal eigenpairs have converged
  if (eig_n_conv < 0) {
    eig_param.n_conv = eig_n_ev;
    eig_n_conv = eig_n_ev;
  } else {
    eig_param.n_conv = eig_n_conv;
  }

  // Inverters will deflate only this number of vectors.
  if (eig_n_ev_deflate < 0) {
    eig_param.n_ev_deflate = eig_n_conv;
    eig_n_ev_deflate = eig_n_conv;
  } else {
    if (eig_n_ev_deflate > eig_n_conv) errorQuda("Can not deflate more that eig_n_conv eigenvectors.");
    eig_param.n_ev_deflate = eig_n_ev_deflate;
  }

  eig_param.ortho_block_size = eig_ortho_block_size;
  eig_param.block_size
    = (eig_param.eig_type == QUDA_EIG_TR_LANCZOS || eig_param.eig_type == QUDA_EIG_IR_ARNOLDI) ? 1 : eig_block_size;
  eig_param.n_ev = eig_n_ev;
  eig_param.n_kr = eig_n_kr;
  eig_param.tol = eig_tol;
  eig_param.qr_tol = eig_qr_tol;
  eig_param.batched_rotate = eig_batched_rotate;
  eig_param.require_convergence = eig_require_convergence ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  eig_param.check_interval = eig_check_interval;
  eig_param.max_restarts = eig_max_restarts;
  eig_param.max_ortho_attempts = eig_max_ortho_attempts;

  eig_param.use_norm_op = eig_use_normop ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  eig_param.use_dagger = eig_use_dagger ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  eig_param.use_pc = eig_use_pc ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  eig_param.compute_gamma5 = eig_compute_gamma5 ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  eig_param.compute_svd = eig_compute_svd ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  if (eig_compute_svd) {
    eig_param.use_dagger = QUDA_BOOLEAN_FALSE;
    eig_param.use_norm_op = QUDA_BOOLEAN_TRUE;
  }

  eig_param.use_eigen_qr = eig_use_eigen_qr ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  eig_param.use_poly_acc = eig_use_poly_acc ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  eig_param.poly_deg = eig_poly_deg;
  eig_param.a_min = eig_amin;
  eig_param.a_max = eig_amax;

  eig_param.arpack_check = eig_arpack_check ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  safe_strcpy(eig_param.arpack_logfile, eig_arpack_logfile, 512, "eig_arpack_logfile");

  safe_strcpy(eig_param.vec_infile, eig_vec_infile, 256, "eig_vec_infile");
  safe_strcpy(eig_param.vec_outfile, eig_vec_outfile, 256, "eig_vec_outfile");
  eig_param.save_prec = eig_save_prec;
  eig_param.io_parity_inflate = eig_io_parity_inflate ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  eig_param.partfile = eig_partfile ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

  eig_param.struct_size = sizeof(eig_param);
}







    inv_param.eig_param = &eig_param;
  } else {
    inv_param.eig_param = nullptr;
  }

  // set parameters for the reference Dslash, and prepare fields to be loaded
  if (dslash_type == QUDA_DOMAIN_WALL_DSLASH || dslash_type == QUDA_DOMAIN_WALL_4D_DSLASH
      || dslash_type == QUDA_MOBIUS_DWF_DSLASH || dslash_type == QUDA_MOBIUS_DWF_EOFA_DSLASH) {
    dw_setDims(gauge_param.X, inv_param.Ls);

  setQudaPrecisions();

void setQudaPrecisions()
{
  if (prec_sloppy == QUDA_INVALID_PRECISION) prec_sloppy = prec;
  if (prec_eigensolver == QUDA_INVALID_PRECISION) prec_eigensolver = prec_sloppy;
  if (prec_precondition == QUDA_INVALID_PRECISION) prec_precondition = prec_sloppy;
  if (prec_null == QUDA_INVALID_PRECISION) prec_null = prec_precondition;
  if (smoother_halo_prec == QUDA_INVALID_PRECISION) smoother_halo_prec = prec_null;
  if (link_recon_sloppy == QUDA_RECONSTRUCT_INVALID) link_recon_sloppy = link_recon;
  if (link_recon_precondition == QUDA_RECONSTRUCT_INVALID) link_recon_precondition = link_recon_sloppy;
  if (link_recon_eigensolver == QUDA_RECONSTRUCT_INVALID) link_recon_eigensolver = link_recon_sloppy;
}









  if (inv_deflate && inv_multigrid) {
    errorQuda("Error: Cannot use both deflation and multigrid preconditioners on top level solve");
  }
  if (inv_multigrid) {
    // Only these fermions are supported with MG
    if (dslash_type != QUDA_WILSON_DSLASH && dslash_type != QUDA_CLOVER_WILSON_DSLASH
        && dslash_type != QUDA_TWISTED_MASS_DSLASH && dslash_type != QUDA_TWISTED_CLOVER_DSLASH) {
      errorQuda("dslash_type %d not supported for MG\n", dslash_type);
    }

    // Only these solve types are supported with MG
    if (solve_type != QUDA_DIRECT_SOLVE && solve_type != QUDA_DIRECT_PC_SOLVE) {
      errorQuda("Solve_type %d not supported with MG. Please use QUDA_DIRECT_SOLVE or QUDA_DIRECT_PC_SOLVE", solve_type);
    }
  }

