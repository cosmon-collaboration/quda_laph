#ifndef FIELD_CONTAINER_H
#define FIELD_CONTAINER_H

#include <complex>
#include "layout_info.h"
#include "util_quda.h"

namespace LaphEnv {

// **************************************************************************
// *                                                                        *
// *  Class "LattField<T>" with T=float or double is a simple container     *
// *  for a lattice field on the hosts (CPUs).  The type of lattice field   *
// *  is specified by the possible values in the FieldSiteType enum.        *
// *  Each type differs by how many complex<T> values the field has at      *
// *  each site of the lattice.  The possibilities are                      *
// *      Complex, ColorMatrix, ColorVector, ColorSpinVector, Unknown.      *
// *  The global constants "FieldNspin" and "FieldNcolor" are also          *
// *  defined and initialized here.                                         *
// *                                                                        *
// *  The field itself is stored in a vector of complex<T>.  The            *
// *  constructor sizes this array based on the FieldSiteType given.        *
// *  The "reset" member resizes the vector if necessary.  This class is    *
// *  mainly useful for file I/O of lattice fields and simple storage on    *
// *  the hosts.                                                            *
// *                                                                        *
// *  QDPXX format is assumed: lattice sites are assumed to be even-odd     *
// *  checkerboard (even/odd sites have x+y+z+t even/odd), with ordering    *
// *  (x,y,z,t) with t varying most slowly for each parity; SU3 color       *
// *  matrix is all 9 complex components row major; ColorSpinVector has     *
// *  the color index varying fastest.                                      *
// *                                                                        *
// **************************************************************************


typedef enum FieldSiteType_s {
   Complex, 
   ColorMatrix, 
   ColorVector, 
   ColorSpinVector, 
   Unknown }  FieldSiteType;

  // global variables for field

const int FieldNspin=4;
const int FieldNcolor=3;


// ***********************************************************************

   //  T should be double or float

template <typename T>
class LattField
{
   
   std::vector<std::complex<T>> m_data;
   
   FieldSiteType m_sitetype;
   
   size_t m_site_elems;


 public:

   LattField(FieldSiteType sitetype=Unknown);

         // caution with copy: memory usage
   LattField(const LattField& in) : m_data(in.m_data), m_sitetype(in.m_sitetype), 
                                    m_site_elems(in.m_site_elems) {}
   
   LattField& operator=(const LattField& in)
    {m_data=in.m_data; m_sitetype=in.m_sitetype; 
     m_site_elems=in.m_site_elems; return *this;}           
   
   size_t bytesPerSite() const
    {return sizeof(std::complex<T>)*m_site_elems;}
   
   size_t bytesPerWord() const
    {return sizeof(std::complex<T>);}

   size_t elemsPerSite() const
    {return m_site_elems;}
    
   FieldSiteType getFieldSiteType() const
    {return m_sitetype;}

   std::vector<std::complex<T>>& getDataRef() {return m_data;}

   const std::vector<std::complex<T>>& getDataConstRef() const {return m_data;}
   
   const T* getDataConstPtr() const {return reinterpret_cast<const T*>(m_data.data());}
   
   T* getDataPtr() {return reinterpret_cast<T*>(m_data.data());}
   
   LattField& reset(FieldSiteType sitetype);

     // Next two routines are useful for testing/checks (slow though); gets
     // and puts data into the right location according to the lattice site "coord";
     // even/odd checkboard with x,y,z,t column major

   std::vector<std::complex<T>> getSiteData(const std::vector<int>& latt_coord) const;
   
   void putSiteData(const std::vector<int>& latt_coord, const std::vector<std::complex<T>>& siteData);

 private:
  
   void do_resize();

   LattField& reset_from_bytes_per_site(size_t bytes_per_site);

   friend class IOHandlerFM;

};

// *************************************************************


template <typename T>
LattField<T>::LattField(FieldSiteType sitetype) : m_sitetype(sitetype)
{
 do_resize();
}

template <typename T>
LattField<T>& LattField<T>::reset(FieldSiteType sitetype)
{
 m_sitetype=sitetype;
 do_resize();
 return *this;
}


template <typename T>
void LattField<T>::do_resize()
{
 if (m_sitetype==Complex) m_site_elems=1;
 else if (m_sitetype==ColorMatrix) m_site_elems=FieldNcolor*FieldNcolor;
 else if (m_sitetype==ColorVector) m_site_elems=FieldNcolor;
 else if (m_sitetype==ColorSpinVector) m_site_elems=FieldNspin*FieldNcolor;
 else m_site_elems=0;
 if (m_site_elems>0)
    m_data.resize(LayoutInfo::getRankLatticeNumSites()*m_site_elems);
 else 
    m_data.clear();
}
   
   
template <typename T>
LattField<T>& LattField<T>::reset_from_bytes_per_site(size_t bytes_per_site)
{
 size_t elem_per_site=bytes_per_site/sizeof(std::complex<T>);
 if (elem_per_site!=m_site_elems){
    m_site_elems=elem_per_site;
    if (m_site_elems==1) m_sitetype=Complex;
    else if (m_site_elems==FieldNcolor*FieldNcolor) m_sitetype=ColorMatrix;
    else if (m_site_elems==FieldNcolor) m_sitetype=ColorVector;
    else if (m_site_elems==FieldNspin*FieldNcolor) m_sitetype=ColorSpinVector;
    else{
       throw(std::runtime_error("Invalid LattField read"));}
    if (m_site_elems>0){
       m_data.resize(LayoutInfo::getRankLatticeNumSites()*m_site_elems);}
    else{
       m_data.clear();}}
 return *this;
}


template <typename T>
std::vector<std::complex<T>> LattField<T>::getSiteData(const std::vector<int>& latt_coords) const
{
 std::vector<std::complex<T>> buffer(m_site_elems);
 int send_rank, rank_site_linear_index;
 LayoutInfo::getCommInfoFromLatticeCoords(latt_coords,send_rank,rank_site_linear_index);
 if (send_rank==LayoutInfo::getMyRank()){
    int offset=m_site_elems*rank_site_linear_index;
    std::memcpy((char*)(buffer.data()),(const char*)(&m_data[offset]),bytesPerSite());}
//    for (int k=0;k<m_site_elems;++k) buffer[k]=m_data[offset];}
#if ARCH_PARALLEL
 quda::comm_broadcast((char*)(buffer.data()),bytesPerSite(),send_rank);
#endif
 return buffer;
}


template <typename T>
void LattField<T>::putSiteData(const std::vector<int>& latt_coords, const std::vector<std::complex<T>>& siteData)
{
 if (siteData.size()!=m_site_elems){
    throw(std::runtime_error("Invalid site data to put into LattField"));}
 int recv_rank, rank_site_linear_index;
 LayoutInfo::getCommInfoFromLatticeCoords(latt_coords,recv_rank,rank_site_linear_index);
 if (recv_rank==LayoutInfo::getMyRank()){
    int offset=m_site_elems*rank_site_linear_index;
    std::memcpy((char*)(&m_data[offset]),(const char*)(siteData.data()),bytesPerSite());}
//    for (int k=0;k<m_site_elems;++k) m_data[offset+k]=siteData[k];}
}


typedef LattField<double> LattFieldDP;
typedef LattField<float>  LattFieldSP;


// *************************************************************
}
#endif
