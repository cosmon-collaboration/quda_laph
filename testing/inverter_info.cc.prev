#include "inverter_info.h"
#include "quda_info.h"
#include "util_quda.h"
#include "utils.h"
#include "laph_stdio.h"
#include "layout_info.h"
#include <map>

using namespace std;


namespace LaphEnv {



InverterInfo::InverterInfo(const XMLHandler& xml_in)
{ 
 XMLHandler xmlr(xml_in, "InverterInfo");
 string name;
 xmlread(xmlr,"Name",name,"InverterInfo");
 if (name=="CG"){
    set_info_cg(xmlr);}
 else if (name=="BICGSTAB"){
    set_info_bicgstab(xmlr);}
 else if (name=="GCR"){
    set_info_gcr(xmlr);}
 else if (name=="MULTIGRID"){
    set_info_multigrid(xmlr);}
 else{
    xmlreadfail(xmlr,"InverterInfo","Unsupported name in InverterInfo");}
}


     // copy constructor

InverterInfo::InverterInfo(const InverterInfo& rhs)
                : svalues(rhs.svalues), ivalues(rhs.ivalues), 
                  rvalues(rhs.rvalues) {}

	
InverterInfo& InverterInfo::operator=(const InverterInfo& rhs)
{
 svalues = rhs.svalues;
 ivalues = rhs.ivalues;
 rvalues = rhs.rvalues;
 return *this;
}


void InverterInfo::checkEqual(const InverterInfo& rhs) const
{
 if (!((*this)==rhs)){
    throw(std::invalid_argument("InverterInfo contents do not match"));}
}


bool InverterInfo::operator==(const InverterInfo& rhs) const
{
 for (int k=0;k<int(svalues.size());++k){
    if (svalues[k]!=rhs.svalues[k]){
       return false;}}
 for (int k=0;k<int(ivalues.size());++k){
    if (ivalues[k]!=rhs.ivalues[k]){
       return false;}}
 for (int k=0;k<int(rvalues.size());++k){
    if (std::abs(rvalues[k]-rhs.rvalues[k])>1e-12){
       return false;}}
 return true;
}


string InverterInfo::output(int indent) const
{
 XMLHandler xmlh;
 output(xmlh);
 return xmlh.output(indent);
}


void InverterInfo::output(XMLHandler& xmlout) const
{
 if (svalues[0]=="CG"){
    output_cg(xmlout);}
 else if (svalues[0]=="BICGSTAB"){
    output_bicgstab(xmlout);}
 else if (svalues[0]=="GCR"){
    output_gcr(xmlout);}
 else if (svalues[0]=="MULTIGRID"){
    output_multigrid(xmlout);}
}


void InverterInfo::setQudaInvertParam(QudaInvertParam& invParam) const
{
 if (svalues[0]=="CG"){
    setQudaInvertParam_cg(invParam);}
 else if (svalues[0]=="BICGSTAB"){
    setQudaInvertParam_bicgstab(invParam);}
 else if (svalues[0]=="GCR"){
    setQudaInvertParam_gcr(invParam);}
 else if (svalues[0]=="MULTIGRID"){
    setQudaInvertParam_multigrid(invParam);}
}


void InverterInfo::setQudaMultigridParam(QudaMultigridParam& mg_param) const
{
 if (svalues[0]=="MULTIGRID"){
    setQudaMGParam_multigrid(mg_param);}
 else{
    errorLaph("Cannot set Multigrid parameters if inverter is not multigrid");}
}


// **********************************************************************
// *                                                                    *
// *    Conjugate-Gradient:                                             *
// *                                                                    *
// *   <InvertInfo>                                                     *
// *     <Name>CG</Name>                                                *
// *     <Tolerance>1.0e-5</Tolerance>                                  *
// *     <MaxIterations>10000</MaxIterations>                           *
// *   </InvertInfo>                                                    *
// *                                                                    *
// *         rvalues[0]=tolerance in residual                           *
// *         ivalues[0]=maximum iterations                              *
// *                                                                    *
// **********************************************************************

void InverterInfo::set_info_cg(XMLHandler& xmlr)
{
 svalues.resize(1);
 rvalues.resize(1);
 ivalues.resize(1);
 svalues[0]="CG";
 xmlread(xmlr,"Tolerance",rvalues[0],"InverterInfo");
 xmlread(xmlr,"MaxIterations",ivalues[0],"InverterInfo");
}


void InverterInfo::output_cg(XMLHandler& xmlout) const
{
 xmlout.set_root("InverterInfo");
 xmlout.put_child("Name","CG");
 xmlout.put_child("Tolerance",make_string(rvalues[0]));
 xmlout.put_child("MaxIterations",make_string(ivalues[0]));
}
 

void InverterInfo::setQudaInvertParam_cg(QudaInvertParam& invParam) const
{
 invParam=newQudaInvertParam();
 invParam.cpu_prec = QudaInfo::get_cpu_prec();
 invParam.cuda_prec = QudaInfo::get_cuda_prec();

// invParam.solution_type = QUDA_MATPC_SOLUTION;
 invParam.solution_type = QUDA_MAT_SOLUTION;

 invParam.solve_type = QUDA_NORMOP_PC_SOLVE;

// invParam.matpc_type = QUDA_MATPC_ODD_ODD_ASYMMETRIC;
 invParam.matpc_type = QUDA_MATPC_EVEN_EVEN;

 invParam.tune = QUDA_TUNE_YES;
 invParam.inv_type = QUDA_CG_INVERTER;
 //invParam.gcrNkrylov = 10;
 invParam.tol = rvalues[0];
 invParam.reliable_delta = 0.1;    //  mixed precision parameter (how often
 invParam.maxiter = ivalues[0];             // compute high precision residual
 invParam.pipeline = 0;
 invParam.dagger = QUDA_DAG_NO;
 invParam.verbosity = getVerbosity();
 invParam.compute_true_res=true;
 invParam.preserve_source = QUDA_PRESERVE_SOURCE_NO;
 invParam.cuda_prec_sloppy = QudaInfo::get_cuda_prec_sloppy();
 invParam.cuda_prec_refinement_sloppy = QudaInfo::get_cuda_prec_sloppy();
 invParam.cuda_prec_precondition = QudaInfo::get_cuda_prec_sloppy();
 invParam.cuda_prec_eigensolver = QudaInfo::get_cuda_prec();
 invParam.struct_size = sizeof(invParam);
}

/*
void setInvertParam(QudaInvertParam &inv_param)
{
  // Set dslash type
  inv_param.dslash_type = dslash_type;

  // Use kappa or mass normalisation
  if (kappa == -1.0) {
    inv_param.mass = mass;
    inv_param.kappa = 1.0 / (2.0 * (1 + 3 / anisotropy + mass));
    if (dslash_type == QUDA_LAPLACE_DSLASH) inv_param.kappa = 1.0 / (8 + mass);
  } else {
    inv_param.kappa = kappa;
    inv_param.mass = 0.5 / kappa - (1.0 + 3.0 / anisotropy);
    if (dslash_type == QUDA_LAPLACE_DSLASH) inv_param.mass = 1.0 / kappa - 8.0;
  }
  if (getVerbosity() >= QUDA_DEBUG_VERBOSE)
    printLaph("Kappa = %.8f Mass = %.8f\n", inv_param.kappa, inv_param.mass);

  // Use 3D or 4D laplace
  inv_param.laplace3D = laplace3D;

  // Some fermion specific parameters
  if (dslash_type == QUDA_TWISTED_MASS_DSLASH || dslash_type == QUDA_TWISTED_CLOVER_DSLASH) {
    inv_param.mu = mu;
    inv_param.epsilon = epsilon;
    inv_param.twist_flavor = twist_flavor;
    inv_param.Ls = (inv_param.twist_flavor == QUDA_TWIST_NONDEG_DOUBLET) ? 2 : 1;
  } else if (dslash_type == QUDA_DOMAIN_WALL_DSLASH || dslash_type == QUDA_DOMAIN_WALL_4D_DSLASH
             || dslash_type == QUDA_MOBIUS_DWF_DSLASH || dslash_type == QUDA_MOBIUS_DWF_EOFA_DSLASH) {
    inv_param.m5 = m5;
    kappa5 = 0.5 / (5 + inv_param.m5);
    inv_param.Ls = Lsdim;
    for (int k = 0; k < Lsdim; k++) { // for mobius only
      // b5[k], c[k] values are chosen for arbitrary values,
      // but the difference of them are same as 1.0
      inv_param.b_5[k] = b5;
      inv_param.c_5[k] = c5;
    }
    inv_param.eofa_pm = eofa_pm;
    inv_param.eofa_shift = eofa_shift;
    inv_param.mq1 = eofa_mq1;
    inv_param.mq2 = eofa_mq2;
    inv_param.mq3 = eofa_mq3;
  } else {
    inv_param.Ls = 1;
  }

  // Set clover specific parameters
  if (dslash_type == QUDA_CLOVER_WILSON_DSLASH || dslash_type == QUDA_TWISTED_CLOVER_DSLASH
      || dslash_type == QUDA_CLOVER_HASENBUSCH_TWIST_DSLASH) {
    inv_param.clover_cpu_prec = cpu_prec;
    inv_param.clover_cuda_prec = cuda_prec;
    inv_param.clover_cuda_prec_sloppy = cuda_prec_sloppy;
    inv_param.clover_cuda_prec_precondition = cuda_prec_precondition;
    inv_param.clover_cuda_prec_eigensolver = cuda_prec_eigensolver;
    inv_param.clover_cuda_prec_refinement_sloppy = cuda_prec_refinement_sloppy;
    inv_param.clover_order = QUDA_PACKED_CLOVER_ORDER;
    // Use kappa * csw or supplied clover_coeff
    inv_param.clover_csw = clover_csw;
    if (clover_coeff == 0.0) {
      inv_param.clover_coeff = clover_csw * inv_param.kappa;
    } else {
      inv_param.clover_coeff = clover_coeff;
    }
    inv_param.compute_clover_trlog = compute_clover_trlog ? 1 : 0;
  }

  // General parameter setup
  inv_param.inv_type = inv_type;
  inv_param.solution_type = solution_type;
  inv_param.solve_type = solve_type;
  inv_param.matpc_type = matpc_type;
  inv_param.dagger = QUDA_DAG_NO;
  inv_param.mass_normalization = normalization;
  inv_param.solver_normalization = QUDA_DEFAULT_NORMALIZATION;
  inv_param.pipeline = pipeline;
  inv_param.Nsteps = 10;
  inv_param.gcrNkrylov = gcrNkrylov;
  inv_param.ca_basis = ca_basis;
  inv_param.ca_lambda_min = ca_lambda_min;
  inv_param.ca_lambda_max = ca_lambda_max;
  inv_param.tol = tol;
  inv_param.tol_restart = tol_restart;
  if (tol_hq == 0 && tol == 0) errorLaph("qudaInvert: requesting zero residual");

  // require both L2 relative and heavy quark residual to determine convergence
  inv_param.residual_type = static_cast<QudaResidualType_s>(0);
  inv_param.residual_type = (tol != 0) ?
    static_cast<QudaResidualType_s>(inv_param.residual_type | QUDA_L2_RELATIVE_RESIDUAL) :
    inv_param.residual_type;
  inv_param.residual_type = (tol_hq != 0) ?
    static_cast<QudaResidualType_s>(inv_param.residual_type | QUDA_HEAVY_QUARK_RESIDUAL) :
    inv_param.residual_type;

  inv_param.tol_hq = tol_hq; // specify a tolerance for the residual for heavy quark residual

  // Offsets used only by multi-shift solver
  // These should be set in the application code. We set the them here by way of
  // example
  inv_param.num_offset = multishift;
  for (int i = 0; i < inv_param.num_offset; i++) inv_param.offset[i] = 0.06 + i * i * 0.1;
  // these can be set individually
  for (int i = 0; i < inv_param.num_offset; i++) {
    inv_param.tol_offset[i] = inv_param.tol;
    inv_param.tol_hq_offset[i] = inv_param.tol_hq;
  }
  inv_param.maxiter = niter;
  inv_param.reliable_delta = reliable_delta;
  inv_param.use_alternative_reliable = alternative_reliable;
  inv_param.use_sloppy_partial_accumulator = 0;
  inv_param.solution_accumulator_pipeline = solution_accumulator_pipeline;
  inv_param.max_res_increase = max_res_increase;
  inv_param.max_res_increase_total = max_res_increase_total;

  // domain decomposition preconditioner parameters
  inv_param.inv_type_precondition = precon_type;

  inv_param.schwarz_type = precon_schwarz_type;
  inv_param.accelerator_type_precondition = precon_accelerator_type;

  inv_param.madwf_diagonal_suppressor = madwf_diagonal_suppressor;
  inv_param.madwf_ls = madwf_ls;

  inv_param.madwf_null_miniter = madwf_null_miniter;
  inv_param.madwf_null_tol = madwf_null_tol;
  inv_param.madwf_train_maxiter = madwf_train_maxiter;

  inv_param.madwf_param_load = madwf_param_load ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
  inv_param.madwf_param_save = madwf_param_save ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

  safe_strcpy(inv_param.madwf_param_infile, madwf_param_infile, 256, "madwf_param_infile");
  safe_strcpy(inv_param.madwf_param_outfile, madwf_param_outfile, 256, "madwf_param_outfile");

  inv_param.precondition_cycle = precon_schwarz_cycle;
  inv_param.tol_precondition = tol_precondition;
  inv_param.maxiter_precondition = maxiter_precondition;
  inv_param.ca_basis_precondition = ca_basis_precondition;
  inv_param.ca_lambda_min_precondition = ca_lambda_min_precondition;
  inv_param.ca_lambda_max_precondition = ca_lambda_max_precondition;
  inv_param.verbosity_precondition = verbosity_precondition;
  inv_param.cuda_prec_precondition = cuda_prec_precondition;
  inv_param.cuda_prec_eigensolver = cuda_prec_eigensolver;
  inv_param.omega = 1.0;

  inv_param.cpu_prec = cpu_prec;
  inv_param.cuda_prec = cuda_prec;
  inv_param.cuda_prec_sloppy = cuda_prec_sloppy;
  inv_param.cuda_prec_refinement_sloppy = cuda_prec_refinement_sloppy;
  inv_param.gamma_basis = QUDA_DEGRAND_ROSSI_GAMMA_BASIS;
  inv_param.dirac_order = QUDA_DIRAC_ORDER;

  inv_param.input_location = QUDA_CPU_FIELD_LOCATION;
  inv_param.output_location = QUDA_CPU_FIELD_LOCATION;

  inv_param.verbosity = verbosity;

  inv_param.extlib_type = solver_ext_lib;

  // Whether or not to use native BLAS LAPACK
  inv_param.native_blas_lapack = (native_blas_lapack ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE);

  // Whether or not use fused kernels for Mobius
  inv_param.use_mobius_fused_kernel = use_mobius_fused_kernel ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;

  inv_param.struct_size = sizeof(inv_param);
}

*/



/*
   // Parameters relating to the solver and the choice of Dirac operator.

  typedef struct QudaInvertParam_s {

    / ** Size of this struct in bytes.  Used to ensure that the host application and QUDA see the same struct size * /
    size_t struct_size;

    QudaFieldLocation input_location; / **< The location of the input field * /
    QudaFieldLocation output_location; / **< The location of the output field * /

    QudaDslashType dslash_type; / **< The Dirac Dslash type that is being used * /
    QudaInverterType inv_type; / **< Which linear solver to use * /

    double mass;  / **< Used for staggered only * /
    double kappa; / **< Used for Wilson and Wilson-clover * /

    double m5;    / **< Domain wall height * /
    int Ls;       / **< Extent of the 5th dimension (for domain wall) * /

    double_complex b_5[QUDA_MAX_DWF_LS]; / **< Mobius coefficients - only real part used if regular Mobius * /
    double_complex c_5[QUDA_MAX_DWF_LS]; / **< Mobius coefficients - only real part used if regular Mobius * /

    / **<
     * The following specifies the EOFA parameters. Notation follows arXiv:1706.05843
     * eofa_shift: the "\beta" in the paper
     * eofa_pm: plus or minus for the EOFA operator
     * mq1, mq2, mq3 are the three masses corresponds to Hasenbusch mass spliting.
     * As far as I know mq1 is always the same as "mass" but it's here just for consistence.
     * * /
    double eofa_shift;
    int eofa_pm;
    double mq1;
    double mq2;
    double mq3;

    double mu;    / **< Twisted mass parameter * /
    double tm_rho;  / **< Hasenbusch mass shift applied like twisted mass to diagonal (but not inverse) * /
    double epsilon; / **< Twisted mass parameter * /

    QudaTwistFlavorType twist_flavor;  / **< Twisted mass flavor * /

    int laplace3D; / **< omit this direction from laplace operator: x,y,z,t -> 0,1,2,3 (-1 is full 4D) * /

    double tol;    / **< Solver tolerance in the L2 residual norm * /
    double tol_restart;   / **< Solver tolerance in the L2 residual norm (used to restart InitCG) * /
    double tol_hq; / **< Solver tolerance in the heavy quark residual norm * /

    int compute_true_res; / ** Whether to compute the true residual post solve * /
    double true_res; / **< Actual L2 residual norm achieved in solver * /
    double true_res_hq; / **< Actual heavy quark residual norm achieved in solver * /
    int maxiter; / **< Maximum number of iterations in the linear solver * /
    double reliable_delta; / **< Reliable update tolerance * /
    double reliable_delta_refinement; / **< Reliable update tolerance used in post multi-shift solver refinement * /
    int use_alternative_reliable; / **< Whether to use alternative reliable updates * /
    int use_sloppy_partial_accumulator; / **< Whether to keep the partial solution accumuator in sloppy precision * /

    / **< This parameter determines how often we accumulate into the
       solution vector from the direction vectors in the solver.
       E.g., running with solution_accumulator_pipeline = 4, means we
       will update the solution vector every four iterations using the
       direction vectors from the prior four iterations.  This
       increases performance of mixed-precision solvers since it means
       less high-precision vector round-trip memory travel, but
       requires more low-precision memory allocation. * /
    int solution_accumulator_pipeline;

    / **< This parameter determines how many consecutive reliable update
    residual increases we tolerate before terminating the solver,
    i.e., how long do we want to keep trying to converge * /
    int max_res_increase;

    / **< This parameter determines how many total reliable update
    residual increases we tolerate before terminating the solver,
    i.e., how long do we want to keep trying to converge * /
    int max_res_increase_total;

    / **< This parameter determines how many consecutive heavy-quark
    residual increases we tolerate before terminating the solver,
    i.e., how long do we want to keep trying to converge * /
    int max_hq_res_increase;

    / **< This parameter determines how many total heavy-quark residual
    restarts we tolerate before terminating the solver, i.e., how long
    do we want to keep trying to converge * /
    int max_hq_res_restart_total;

    / **< After how many iterations shall the heavy quark residual be updated * /
    int heavy_quark_check;

    int pipeline; / **< Whether to use a pipelined solver with less global sums * /

    int num_offset; / **< Number of offsets in the multi-shift solver * /

    int num_src; / **< Number of sources in the multiple source solver * /

    int num_src_per_sub_partition; / **< Number of sources in the multiple source solver, but per sub-partition * /

    / **< The grid of sub-partition according to which the processor grid will be partitioned.
    Should have:
      split_grid[0] * split_grid[1] * split_grid[2] * split_grid[3] * num_src_per_sub_partition == num_src. ** /
    int split_grid[QUDA_MAX_DIM];

    int overlap; / **< Width of domain overlaps * /

    / ** Offsets for multi-shift solver * /
    double offset[QUDA_MAX_MULTI_SHIFT];

    / ** Solver tolerance for each offset * /
    double tol_offset[QUDA_MAX_MULTI_SHIFT];

    / ** Solver tolerance for each shift when refinement is applied using the heavy-quark residual * /
    double tol_hq_offset[QUDA_MAX_MULTI_SHIFT];

    / ** Actual L2 residual norm achieved in solver for each offset * /
    double true_res_offset[QUDA_MAX_MULTI_SHIFT];

    / ** Iterated L2 residual norm achieved in multi shift solver for each offset * /
    double iter_res_offset[QUDA_MAX_MULTI_SHIFT];

    / ** Actual heavy quark residual norm achieved in solver for each offset * /
    double true_res_hq_offset[QUDA_MAX_MULTI_SHIFT];

    / ** Residuals in the partial faction expansion * /
    double residue[QUDA_MAX_MULTI_SHIFT];

    / ** Whether we should evaluate the action after the linear solver* /
    int compute_action;

    / ** Computed value of the bilinear action (complex-valued)
	invert: \phi^\dagger A^{-1} \phi
	multishift: \phi^\dagger r(x) \phi = \phi^\dagger (sum_k residue[k] * (A + offset[k])^{-1} ) \phi * /
    double action[2];

    QudaSolutionType solution_type;  / **< Type of system to solve * /
    QudaSolveType solve_type;        / **< How to solve it * /
    QudaMatPCType matpc_type;        / **< The preconditioned matrix type * /
    QudaDagType dagger;              / **< Whether we are using the Hermitian conjugate system or not * /
    QudaMassNormalization mass_normalization; / **< The mass normalization is being used by the caller * /
    QudaSolverNormalization solver_normalization; / **< The normalization desired in the solver * /

    QudaPreserveSource preserve_source;       / **< Preserve the source or not in the linear solver (deprecated) * /

    QudaPrecision cpu_prec;                / **< The precision used by the input fermion fields * /
    QudaPrecision cuda_prec;               / **< The precision used by the QUDA solver * /
    QudaPrecision cuda_prec_sloppy;        / **< The precision used by the QUDA sloppy operator * /
    QudaPrecision cuda_prec_refinement_sloppy; / **< The precision of the sloppy gauge field for the refinement step in multishift * /
    QudaPrecision cuda_prec_precondition;  / **< The precision used by the QUDA preconditioner * /
    QudaPrecision cuda_prec_eigensolver;   / **< The precision used by the QUDA eigensolver * /

    QudaDiracFieldOrder dirac_order;       / **< The order of the input and output fermion fields * /

    QudaGammaBasis gamma_basis;            / **< Gamma basis of the input and output host fields * /

    QudaFieldLocation clover_location;     / **< The location of the clover field * /
    QudaPrecision clover_cpu_prec;         / **< The precision used for the input clover field * /
    QudaPrecision clover_cuda_prec;        / **< The precision used for the clover field in the QUDA solver * /
    QudaPrecision clover_cuda_prec_sloppy; / **< The precision used for the clover field in the QUDA sloppy operator * /
    QudaPrecision clover_cuda_prec_refinement_sloppy; / **< The precision of the sloppy clover field for the refinement step in multishift * /
    QudaPrecision clover_cuda_prec_precondition; / **< The precision used for the clover field in the QUDA preconditioner * /
    QudaPrecision clover_cuda_prec_eigensolver;  / **< The precision used for the clover field in the QUDA eigensolver * /

    QudaCloverFieldOrder clover_order;     / **< The order of the input clover field * /
    QudaUseInitGuess use_init_guess;       / **< Whether to use an initial guess in the solver or not * /

    double clover_csw;                     / **< Csw coefficient of the clover term * /
    double clover_coeff;                   / **< Coefficient of the clover term * /
    double clover_rho;                     / **< Real number added to the clover diagonal (not to inverse) * /

    int compute_clover_trlog;              / **< Whether to compute the trace log of the clover term * /
    double trlogA[2];                      / **< The trace log of the clover term (even/odd computed separately) * /

    int compute_clover;                    / **< Whether to compute the clover field * /
    int compute_clover_inverse;            / **< Whether to compute the clover inverse field * /
    int return_clover;                     / **< Whether to copy back the clover matrix field * /
    int return_clover_inverse;             / **< Whether to copy back the inverted clover matrix field * /

    QudaVerbosity verbosity;               / **< The verbosity setting to use in the solver * /

    int iter;                              / **< The number of iterations performed by the solver * /
    double gflops;                         / **< The Gflops rate of the solver * /
    double secs;                           / **< The time taken by the solver * /

    QudaTune tune; / **< Enable auto-tuning? (default = QUDA_TUNE_YES) * /

    / ** Number of steps in s-step algorithms * /
    int Nsteps;

    / ** Maximum size of Krylov space used by solver * /
    int gcrNkrylov;

    / *
     * The following parameters are related to the solver
     * preconditioner, if enabled.
     * /

    / **
     * The inner Krylov solver used in the preconditioner.  Set to
     * QUDA_INVALID_INVERTER to disable the preconditioner entirely.
     * /
    QudaInverterType inv_type_precondition;

    / ** Preconditioner instance, e.g., multigrid * /
    void *preconditioner;

    / ** Deflation instance * /
    void *deflation_op;

    / ** defines deflation * /
    void *eig_param;

    / ** If true, deflate the initial guess * /
    QudaBoolean deflate;

    / ** Dirac Dslash used in preconditioner * /
    QudaDslashType dslash_type_precondition;
    / ** Verbosity of the inner Krylov solver * /
    QudaVerbosity verbosity_precondition;

    / ** Tolerance in the inner solver * /
    double tol_precondition;

    / ** Maximum number of iterations allowed in the inner solver * /
    int maxiter_precondition;

    / ** Relaxation parameter used in GCR-DD (default = 1.0) * /
    double omega;

    / ** Basis for CA algorithms * /
    QudaCABasis ca_basis;

    / ** Minimum eigenvalue for Chebyshev CA basis * /
    double ca_lambda_min;

    / ** Maximum eigenvalue for Chebyshev CA basis * /
    double ca_lambda_max;

    / ** Basis for CA algorithms in a preconditioned solver * /
    QudaCABasis ca_basis_precondition;

    / ** Minimum eigenvalue for Chebyshev CA basis in a preconditioner solver * /
    double ca_lambda_min_precondition;

    / ** Maximum eigenvalue for Chebyshev CA basis in a preconditioner solver * /
    double ca_lambda_max_precondition;

    / ** Number of preconditioner cycles to perform per iteration * /
    int precondition_cycle;

    / ** Whether to use additive or multiplicative Schwarz preconditioning * /
    QudaSchwarzType schwarz_type;

    / ** The type of accelerator type to use for preconditioner * /
    QudaAcceleratorType accelerator_type_precondition;

    / **
     * The following parameters are the ones used to perform the adaptive MADWF in MSPCG
     * See section 3.3 of [arXiv:2104.05615]
     * /

    / ** The diagonal constant to suppress the low modes when performing 5D transfer * /
    double madwf_diagonal_suppressor;

    / ** The target MADWF Ls to be used in the accelerator * /
    int madwf_ls;

    / ** The minimum number of iterations after which to generate the null vectors for MADWF * /
    int madwf_null_miniter;

    / ** The maximum tolerance after which to generate the null vectors for MADWF * /
    double madwf_null_tol;

    / ** The maximum number of iterations for the training iterations * /
    int madwf_train_maxiter;

    / ** Whether to load the MADWF parameters from the file system * /
    QudaBoolean madwf_param_load;

    / ** Whether to save the MADWF parameters to the file system * /
    QudaBoolean madwf_param_save;

    / ** Path to load from the file system * /
    char madwf_param_infile[256];

    / ** Path to save to the file system * /
    char madwf_param_outfile[256];

    / **
     * Whether to use the L2 relative residual, Fermilab heavy-quark
     * residual, or both to determine convergence.  To require that both
     * stopping conditions are satisfied, use a bitwise OR as follows:
     *
     * p.residual_type = (QudaResidualType) (QUDA_L2_RELATIVE_RESIDUAL
     *                                     | QUDA_HEAVY_QUARK_RESIDUAL);
     * /
    QudaResidualType residual_type;

    / **Parameters for deflated solvers* /
    / ** The precision of the Ritz vectors * /
    QudaPrecision cuda_prec_ritz;
    / ** How many vectors to compute after one solve
     *  for eigCG recommended values 8 or 16
    * /
    int n_ev;
    / ** EeigCG  : Search space dimension
     *  gmresdr : Krylov subspace dimension
     * /
    int max_search_dim;
    / ** For systems with many RHS: current RHS index * /
    int rhs_idx;
    / ** Specifies deflation space volume: total number of eigenvectors is n_ev*deflation_grid * /
    int deflation_grid;
    / ** eigCG: selection criterion for the reduced eigenvector set * /
    double eigenval_tol;
    / ** mixed precision eigCG tuning parameter:  minimum search vector space restarts * /
    int eigcg_max_restarts;
    / ** initCG tuning parameter:  maximum restarts * /
    int max_restart_num;
    / ** initCG tuning parameter:  tolerance for cg refinement corrections in the deflation stage * /
    double inc_tol;

    / ** Whether to make the solution vector(s) after the solve * /
    int make_resident_solution;

    / ** Whether to use the resident solution vector(s) * /
    int use_resident_solution;

    / ** Whether to use the solution vector to augment the chronological basis * /
    int chrono_make_resident;

    / ** Whether the solution should replace the last entry in the chronology * /
    int chrono_replace_last;

    / ** Whether to use the resident chronological basis * /
    int chrono_use_resident;

    / ** The maximum length of the chronological history to store * /
    int chrono_max_dim;

    / ** The index to indicate which chrono history we are augmenting * /
    int chrono_index;

    / ** Precision to store the chronological basis in * /
    QudaPrecision chrono_precision;

    / ** Which external library to use in the linear solvers (Eigen) * /
    QudaExtLibType extlib_type;

    / ** Whether to use the platform native or generic BLAS / LAPACK * /
    QudaBoolean native_blas_lapack;

    / ** Whether to use fused kernels for mobius * /
    QudaBoolean use_mobius_fused_kernel;

  } QudaInvertParam;
*/

/*

#include "chromabase.h"
#include <string>
#include "actions/ferm/invert/quda_solvers/quda_multigrid_params.h"

using namespace QDP;

namespace Chroma {

	template<typename T>
	void readArray(XMLReader& paramtop, const std::string& path, multi1d<T>& array, const T& defValue)
	{

		multi1d<T> tmp;
		// If path is not found use default
		if ( paramtop.count(path) == 0 ) {

			QDPIO::cout << "Parameter with " << path << " not found. Setting default value "
					<< defValue <<  " for " << array.size() << " array members" << std::endl;

			for(int l=0; l < array.size() ; ++l) array[l] = defValue;
		}
		else {

			// If it is found read it to tmp
			read(paramtop, path, tmp);
			if ( tmp.size() == 1 ) {
                QDPIO::cout << "Broadcasting " << path << " = " << tmp[0] << "  to "  << array.size() <<  " array members" << std::endl;
				// if tmp is a single element array, broadcast it
				for(int l=0; l < array.size(); ++l) array[l] = tmp[0];
			}
			else {

				// If tmp is the same size as array copy it
				QDPIO::cout << "Copying " << path << " values to " << array.size() << " members " << std::endl;
				if ( tmp.size() == array.size() ) {
					for(int l=0; l < array.size(); ++l) array[l] = tmp[l];
				}
				else {
					QDPIO::cout << "Error: Array with path " << path << "has size "
							<< tmp.size() << " but " << array.size() << " are expected. " << std::endl;
					QDP_abort(1);
				}
			}
		}
	}

  MULTIGRIDSolverParams::MULTIGRIDSolverParams(XMLReader& xml, 
					     const std::string& path)
  {
    XMLReader paramtop(xml, path);


    read(paramtop, "Verbosity", verbosity);
    read(paramtop, "Precision", prec);
    read(paramtop, "Reconstruct", reconstruct);
    
    read(paramtop, "Blocking", blocking);
    mg_levels = blocking.size()+1;





    nvec.resize(mg_levels-1);
    nu_pre.resize(mg_levels-1);
    nu_post.resize(mg_levels-1);
    maxIterSubspaceCreate.resize(mg_levels-1);
    maxIterSubspaceRefresh.resize(mg_levels-1);
    rsdTargetSubspaceCreate.resize(mg_levels-1);

    coarseSolverType.resize(mg_levels-1);
    readArray<QudaSolverType>(paramtop, "CoarseSolverType", coarseSolverType, GCR);


    tol.resize(mg_levels);
    readArray<Real>(paramtop, "CoarseResidual", tol, Real(0.0001));

    maxIterations.resize(mg_levels);
    readArray<int>(paramtop, "MaxCoarseIterations", maxIterations, 12 );

    smootherType.resize(mg_levels);
    readArray<QudaSolverType>(paramtop, "SmootherType", smootherType, MR);


    smootherTol.resize(mg_levels);
    readArray<Real>(paramtop, "SmootherTol", smootherTol, Real(0.25));

    smootherHaloPrecision.resize(mg_levels);
    readArray<QudaPrecisionType>(paramtop, "SmootherHaloPrecision", smootherHaloPrecision, DEFAULT);

    smootherSchwarzType.resize(mg_levels);
    readArray(paramtop, "SmootherSchwarzType", smootherSchwarzType, INVALID_SCHWARZ);


    smootherSchwarzCycle.resize(mg_levels);
    readArray(paramtop, "SmootherSchwarzCycle", smootherSchwarzCycle, 1);

    read(paramtop, "NullVectors", nvec);
    read(paramtop, "Pre-SmootherApplications", nu_pre);
    read(paramtop, "Post-SmootherApplications", nu_post);
    if (nvec.size() != mg_levels-1 ) {
 
      QDPIO::cout<<"Warning. There are "<< blocking.size() 
		 << " blockings but only " << nvec.size() << " sets of NullVectors" << std::endl;
      QDP_abort(1);
    }

    if (nu_pre.size() != mg_levels-1 ) {
 
      QDPIO::cout<<"Error. There are "<< (mg_levels-1)  
		 << " blockings but only " << nu_pre.size() << " sets pre-smoothing iterations" << std::endl;
      QDP_abort(1);
    }

    subspaceSolver.resize(mg_levels-1);
    readArray(paramtop, "SubspaceSolver", subspaceSolver, CG);

    if( paramtop.count("./RsdTargetSubspaceCreate") == 1 ) { 
      read(paramtop, "RsdTargetSubspaceCreate", rsdTargetSubspaceCreate);
    }
    else {
      // Default values.
      for(int l=0; l < mg_levels-1; ++l) { 
	rsdTargetSubspaceCreate[l] = 5.0e-6;
      }
    }

    if( paramtop.count("./MaxIterSubspaceCreate") == 1) {
      read(paramtop, "./MaxIterSubspaceCreate", maxIterSubspaceCreate);
    }
    else {
      for(int l=0; l < mg_levels-1; ++l) {
	maxIterSubspaceCreate[l] = 500;
      }
    }

    if( paramtop.count("./MaxIterSubspaceRefresh") == 1) { 
      read(paramtop, "./MaxIterSubspaceRefresh", maxIterSubspaceRefresh);
    }
    else {
      for(int l=0; l < mg_levels-1; ++l) { 
	maxIterSubspaceRefresh[l] = maxIterSubspaceCreate[l];
      }
    }


    if( paramtop.count("./OuterGCRNKrylov") == 1 ) {
	read(paramtop, "OuterGCRNKrylov", outer_gcr_nkrylov);
    }
    else { 
	outer_gcr_nkrylov = 12;
    }

    if( paramtop.count("./PrecondGCRNKrylov") == 1 ) { 
	read(paramtop, "PrecondGCRNKrylov", precond_gcr_nkrylov);
    }
    else {
        precond_gcr_nkrylov = 12;
    }

    if (nu_post.size() != mg_levels-1 ) {
 
      QDPIO::cout<<"Warning. There are "<< blocking.size() 
		 << " blockings but only " << nu_post.size() << " sets post-smoothing iterations " << std::endl;
      QDP_abort(1);
    }

    read(paramtop, "GenerateNullspace", generate_nullspace);

    if( paramtop.count("./CheckMultigridSetup") == 1 ) {
      read(paramtop, "CheckMultigridSetup", check_multigrid_setup);
    }
    else {
      check_multigrid_setup = true; // Default: Checks for suspace and coarss op ar one!
    }

    read(paramtop, "GenerateAllLevels", generate_all_levels);

    //FIXME: Should be an enum
    read(paramtop, "CycleType", cycle_type);
  

    // Read optional params otherwise use defaults
    if( paramtop.count("SchwarzType") > 0 ) { 
      read(paramtop, "SchwarzType", schwarzType);
    }

    relaxationOmegaMG.resize(mg_levels);
    readArray(paramtop, "RelaxationOmegaMG", relaxationOmegaMG, Real(1.0));

   // Read optional relaxation param
    if( paramtop.count("RelaxationOmegaOuter") > 0 ) {
      read(paramtop, "RelaxationOmegaOuter", relaxationOmegaOuter);
    }
    else {
        relaxationOmegaOuter = Real(1.0);
    }

    if(paramtop.count("SetupOnGPU") == 1) {
      read(paramtop, "SetupOnGPU", setup_on_gpu);
      if ( setup_on_gpu.size() != mg_levels - 1 ) { 

        // if size != n_levels - 1 then it is an error 
        // unless size is 1 in which case we broadcast it.
        //
	if ( setup_on_gpu.size() == 1 ) { 

          // Only one value was entered broadcast it
          bool value = setup_on_gpu[0];
          setup_on_gpu.resize(mg_levels-1);
          for(int l=0; l < mg_levels-1; ++l) { 
            setup_on_gpu[l] = value;
          } 
        }
        else { 
	   // Size mismatch and size is not 1 error. 
	   QDPIO::cerr << "setup_on_gpu has size = " << setup_on_gpu.size() << 
              " but it should be either 1 (broadcast to all levels) or " << mg_levels -1 
	      << " (mg_levels -1) \n";
           QDP_abort(1);
        } // setup_on_gpu_size == 1
      } // setup_on_gpu_size != mg_levels - 1
    } // paramtop.count("SetupOnGPU") == 1
    else {

      // No specification in XML. Default
      // behaviour is that all levels set up on GPU
      setup_on_gpu.resize(mg_levels-1);
      for(int l=0; l < mg_levels-1; ++l) {
        setup_on_gpu[l] = true;
      }
    }
    
  }

  void read(XMLReader& xml, const std::string& path, 
	    MULTIGRIDSolverParams& p)
  {
    MULTIGRIDSolverParams tmp(xml, path);
    p = tmp;
  }

  
  
  void write(XMLWriter& xml, const std::string& path, 
	     const MULTIGRIDSolverParams& p) {
    push(xml, path);
    write(xml, "Residual", p.tol);
    write(xml, "MaxIterations", p.maxIterations);
    write(xml, "SmootherType", p.smootherType);
    if ( p.smootherHaloPrecision[0] != DEFAULT ) {
      write(xml, "SmootherHaloPrecision", p.smootherHaloPrecision);
    }
    write(xml, "RelaxationOmegaMG", p.relaxationOmegaMG);
    write(xml, "RelaxationOmegaOuter", p.relaxationOmegaOuter);
    write(xml, "Verbosity", p.verbosity);
    write(xml, "Precision", p.prec);
    write(xml, "Reconstruct", p.reconstruct);
    write(xml, "SchwarzType", p.schwarzType);
    write(xml, "NullVectors", p.nvec);
    write(xml, "MultiGridLevels", p.mg_levels);
    write(xml, "GenerateNullSpace", p.generate_nullspace);
    write(xml, "GenerateAllLevels", p.generate_all_levels);
    write(xml, "CheckMultigridSetup", p.check_multigrid_setup);
    write(xml, "CycleType", p.cycle_type);
    write(xml, "Pre-SmootherApplications", p.nu_pre);
    write(xml, "Post-SmootherApplications", p.nu_post);
    // FIXME: This should go in the general solver interface, and work for all GCR solvers, not just GCR inner params
    write(xml, "OuterGCRNKrylov", p.outer_gcr_nkrylov);
    write(xml, "PrecondGCRNKrylov", p.precond_gcr_nkrylov);
    write(xml, "Blocking", p.blocking);
    write(xml, "MaxIterSubspaceCreate", p.maxIterSubspaceCreate);
    write(xml, "MaxIterSubspaceRefresh", p.maxIterSubspaceRefresh);
    write(xml, "RsdTargetSubspaceCreate", p.rsdTargetSubspaceCreate);
    write(xml, "SetupOnGPU", p.setup_on_gpu);
    pop(xml);

  }
}
*/

// **********************************************************************
// *                                                                    *
// *    Biconjugate Gradient Stabilized:                                *
// *                                                                    *
// *   <InvertInfo>                                                     *
// *     <Name>BICGSTAB</Name>                                          *
// *     <Tolerance>1.0e-5</Tolerance>                                  *
// *     <MaxIterations>10000</MaxIterations>                           *
// *   </InvertInfo>                                                    *
// *                                                                    *
// *         rvalues[0]=tolerance in residual                           *
// *         ivalues[0]=maximum iterations                              *
// *                                                                    *
// **********************************************************************

void InverterInfo::set_info_bicgstab(XMLHandler& xmlr)
{
 svalues.resize(1);
 rvalues.resize(1);
 ivalues.resize(1);
 svalues[0]="BICGSTAB";
 xmlread(xmlr,"Tolerance",rvalues[0],"InverterInfo");
 xmlread(xmlr,"MaxIterations",ivalues[0],"InverterInfo");
}


void InverterInfo::output_bicgstab(XMLHandler& xmlout) const
{
 xmlout.set_root("InverterInfo");
 xmlout.put_child("Name","BICGSTAB");
 xmlout.put_child("Tolerance",make_string(rvalues[0]));
 xmlout.put_child("MaxIterations",make_string(ivalues[0]));
}
 

void InverterInfo::setQudaInvertParam_bicgstab(QudaInvertParam& invParam) const
{
 invParam=newQudaInvertParam();
 invParam.cpu_prec = QudaInfo::get_cpu_prec();
 invParam.cuda_prec = QudaInfo::get_cuda_prec();

// invParam.solution_type = QUDA_MATPC_SOLUTION;
 invParam.solution_type = QUDA_MAT_SOLUTION;

 invParam.solve_type = QUDA_DIRECT_PC_SOLVE;

// invParam.matpc_type = QUDA_MATPC_ODD_ODD_ASYMMETRIC;
 invParam.matpc_type = QUDA_MATPC_EVEN_EVEN;

 invParam.tune = QUDA_TUNE_YES;
 invParam.inv_type = QUDA_BICGSTAB_INVERTER;
 //invParam.gcrNkrylov = 10;
 invParam.tol = rvalues[0];
 invParam.reliable_delta = 0.1;    //  mixed precision parameter (how often
 invParam.maxiter = ivalues[0];             // compute high precision residual
 invParam.pipeline = 0;
 invParam.dagger = QUDA_DAG_NO;
 invParam.verbosity = getVerbosity();
 invParam.compute_true_res=true;
 invParam.preserve_source = QUDA_PRESERVE_SOURCE_NO;
 invParam.cuda_prec_sloppy = QudaInfo::get_cuda_prec_sloppy();
 invParam.cuda_prec_refinement_sloppy = QudaInfo::get_cuda_prec_sloppy();
 invParam.cuda_prec_precondition = QudaInfo::get_cuda_prec_sloppy();
 invParam.cuda_prec_eigensolver = QudaInfo::get_cuda_prec();
 invParam.struct_size = sizeof(invParam);
}


// **********************************************************************
// *                                                                    *
// *    Generalized Conjugate Residual:                                 *
// *                                                                    *
// *   <InvertInfo>                                                     *
// *     <Name>GCR</Name>                                               *
// *     <Tolerance>1.0e-5</Tolerance>                                  *
// *     <MaxIterations>10000</MaxIterations>                           *
// *     <NKrylov>24</NKrylov>
// *   </InvertInfo>                                                    *
// *                                                                    *
// *         rvalues[0]=tolerance in residual                           *
// *         ivalues[0]=maximum iterations                              *
// *         ivalues[1]=NKrylov
// *                                                                    *
// **********************************************************************

void InverterInfo::set_info_gcr(XMLHandler& xmlr)
{
 svalues.resize(1);
 rvalues.resize(1);
 ivalues.resize(2);
 svalues[0]="GCR";
 xmlread(xmlr,"Tolerance",rvalues[0],"InverterInfo");
 xmlread(xmlr,"MaxIterations",ivalues[0],"InverterInfo");
 xmlread(xmlr,"NKrylov",ivalues[1],"InverterInfo");
}


void InverterInfo::output_gcr(XMLHandler& xmlout) const
{
 xmlout.set_root("InverterInfo");
 xmlout.put_child("Name","GCR");
 xmlout.put_child("Tolerance",make_string(rvalues[0]));
 xmlout.put_child("MaxIterations",make_string(ivalues[0]));
 xmlout.put_child("NKrylov",make_string(ivalues[1]));
}
 

void InverterInfo::setQudaInvertParam_gcr(QudaInvertParam& invParam) const
{
 invParam=newQudaInvertParam();
 invParam.cpu_prec = QudaInfo::get_cpu_prec();
 invParam.cuda_prec = QudaInfo::get_cuda_prec();

// invParam.solution_type = QUDA_MATPC_SOLUTION;
 invParam.solution_type = QUDA_MAT_SOLUTION;

 invParam.solve_type = QUDA_DIRECT_PC_SOLVE;

// invParam.matpc_type = QUDA_MATPC_ODD_ODD_ASYMMETRIC;
 invParam.matpc_type = QUDA_MATPC_EVEN_EVEN;

 invParam.tune = QUDA_TUNE_YES;
 invParam.inv_type = QUDA_GCR_INVERTER;
 invParam.gcrNkrylov = ivalues[1];
 invParam.tol = rvalues[0];
 invParam.reliable_delta = 0.1;    //  mixed precision parameter (how often
 invParam.maxiter = ivalues[0];             // compute high precision residual
 invParam.pipeline = 0;
 invParam.dagger = QUDA_DAG_NO;
 invParam.verbosity = getVerbosity();
 invParam.compute_true_res=true;
 invParam.preserve_source = QUDA_PRESERVE_SOURCE_NO;
 invParam.cuda_prec_sloppy = QudaInfo::get_cuda_prec_sloppy();
 invParam.cuda_prec_refinement_sloppy = QudaInfo::get_cuda_prec_sloppy();
 invParam.cuda_prec_precondition = QudaInfo::get_cuda_prec_sloppy();
 invParam.cuda_prec_eigensolver = QudaInfo::get_cuda_prec();
 invParam.struct_size = sizeof(invParam);
}


// **********************************************************************
// *                                                                    *
// *    Multigrid:                                 *
// *                                                                    *
// *   <InvertInfo>                                                     *
// *     <Name>MULTIGRID</Name>                                               *
// *     <Tolerance>1.0e-11</Tolerance>                                  *
// *     <MaxIterations>10000</MaxIterations>                           *
// *     <NumLevels>3</NumLevels>             1,2,3,4 (3 usually best)
// *     <Level>
// *       <IdNum>0</IdNum>
// *          ....
// *     </Level>
// *     <Level>
// *       <IdNum>1</IdNum>
// *          ....
// *     </Level>
// *     <Level>
// *       <IdNum>2</IdNum>
// *          ....
// *     </Level>
// *     <ComputeNullVectors>true</ComputeNullVectors> (optional: true default)
// *     <GenerateAllLevels>true</GenerateAllLevels>   (optional: true default)
// *     <RunVerify>true</RunVerify>                   (optional: true default)


// *   </InvertInfo>                                                    *
// *                                                                    *
// *   For each level, input XML is
// *
// *     <Level>
// *       <IdNum>0</IdNum>
// *
/*
// *       <CoarseSolverType>   QudaInverterType coarse_solver[QUDA_MAX_MG_LEVEL] 	The solver that wraps around the coarse grid correction and smoother 	Set for all levels except 0. Suggest using QUDA_GCR_INVERTER on all intermediate grids and QUDA_CA_GCR_INVERTER on the bottom. 	--mg-coarse-solver <level gcr/etc.>
// *       <CoarseSolutionType>  QudaSolutionType coarse_grid_solution_type[QUDA_MAX_MG_LEVEL] 	The type of residual to send to the next coarse grid, and thus the type of solution to receive back from this coarse grid 	Use QUDA_MATPC_SOLUTION for all levels; if solving the full unpreconditioned system on level 0 then set coarse_grid_solution_type[0]=QUDA_MAT_SOLUTION 	Implicitly depending on --mg-solve-type and --solve-type
// *       <CoarseSolverTolerance>0.1</CoarseSolverTolerance>              Tolerance for the solver that wraps around the coarse grid correction and smoother 	Suggest setting each level to 0.25 	--mg-coarse-solver-tol <level gcr/etc.>
// *       <CoarseSolverMaxIterations>12</CoarseSolverMaxIterations>       Tolerance for the solver that wraps around the coarse grid correction and smoother 	Suggest setting in the range 8-100 	--mg-coarse-solver-maxiter <level n>
// *       <Blocking>[QUDA_MAX_MG_LEVEL][QUDA_MAX_DIM] 	Geometric block sizes to use on each level 	Generally favor more aggressive coarsening for first level, rule of thumb is 4^4 	--mg-block-size <level x y z t>
// *       <SpinBlockSize>    int spin_block_size[QUDA_MAX_MG_LEVEL] 	Spin block sizes to use on each level 	2 for level 0, and 1 thereafter 	N/A
// *       <NumNullVectors>24</NumNullVectors>   (24 or 32; 24 is default)
// *       <SmootherType>   QudaInverterType smoother[QUDA_MAX_MG_LEVEL] 	Smoother to use on each level 	Set to QUDA_CA_GCR_INVERTER for each level 	--mg-smoother <level mr/ca-gcr/etc.>
// *       <SmootherTolerance>   double smoother_tol[QUDA_MAX_MG_LEVEL] 	Tolerance to use for the smoother / solver on each level 	Suggest setting each level to 0.25 	--mg-smoother-tol <level resid_tol>
// *       <NumPreSmooth> int nu_pre[QUDA_MAX_MG_LEVEL] 	Number of pre-smoother applications on each level 	Suggest setting to 0 	--mg-nu-pre  <level 1-20>
// *       <NumPostSmooth> int nu_post[QUDA_MAX_MG_LEVEL] 	Number of post-smoother applications on each level 	Suggest setting to 8 	--mg-nu-post <level 1-20>
// *       <OverRelaxOmega> double omega[QUDA_MAX_MG_LEVEL] 	Over/under relaxation factor for the smoother at each level 	Set to 0.8-1.0 	--mg-omega
// *       <SmootherSolveType>    QudaSolveType smoother_solve_type[QUDA_MAX_MG_LEVEL] 	The type of smoother solve to do on each grid (e/o preconditioning or not) 	Suggest setting to QUDA_DIRECT_PC_SOLVE for all levels 	--mg-solve-type <level solve>
// *       <CycleType>   QudaMultigridCycleType cycle_type[QUDA_MAX_MG_LEVEL] 	The type of multigrid cycle to perform at each level 	Always set to QUDA_MG_CYCLE_RECURSIVE (this sets the MG cycles to be a K-cycle which is generally superior to a V-cycle for non-Hermitian systems) 	
// *       <SmootherSchwarzCycle>    int smoother_schwarz_cycle[QUDA_MAX_MG_LEVEL] 	Number of Schwarz cycles to apply 	Experimental, set to 1 for each level 	--mg-schwarz-cycle <level cycle>


QudaPrecision precision_null[QUDA_MAX_MG_LEVEL] 	Precision to store the null-space vectors and preconditioned coarse-link variables 	Use QUDA_HALF_PRECISION for optimal performance 	--prec-null <double/single/half>
QudaVerbosity verbosity[QUDA_MAX_MG_LEVEL] 	Verbosity on each level of the multigrid 		--mg-verbosity <level verb>
QudaBoolean global_reduction[QUDA_MAX_MG_LEVEL] 	Whether to use global reductions or not for the smoother / solver at each level 	Experimental, keep set to QUDA_BOOLEAN_YES for all levels unless using a Schwarz smoother 	
QudaSchwarzType smoother_schwarz_type[QUDA_MAX_MG_LEVEL] 	Whether to use additive or multiplicative Schwarz preconditioning in the smoother 	Experimental, set to QUDA_INVALID_SCHWARZ for each level unless you know what you're doing 	--mg-schwarz-type <level false/add/mul>
QudaFieldLocation location[QUDA_MAX_MG_LEVEL] 	Location where each level should be done 	Set to QUDA_CUDA_FIELD_LOCATION for all levels 	N/A
double mu_factor[QUDA_MAX_MG_LEVEL] 	Multiplicative factor for the mu parameter 	Only applicable for twisted-mass and twisted-clover fermions 	--mg-mu-factor <level factor>
*/




// *         rvalues[0]=tolerance in residual                           *
// *         ivalues[0]=maximum iterations                              *
// *         ivalues[1]=NKrylov
// *                                                                    *






















/*

          //       <invType>QUDA_MULTIGRID_CLOVER_INVERTER</invType>
          //       <CloverParams>
          //         <!--Mass>-0.356557937</Mass-->
          //         <Kappa>0.137232867</Kappa>
          //         <clovCoeff>1.8248654</clovCoeff>
          //         <AnisoParam>
          //           <anisoP>false</anisoP>
          //           <t_dir>3</t_dir>
          //           <xi_0>1</xi_0>
          //           <nu>1</nu>
          //         </AnisoParam>
          //       </CloverParams>
          //       <RsdTarget>1e-11</RsdTarget>
                 <Delta>1.0e-3</Delta>
                 <Pipeline>0</Pipeline>
          //       <MaxIter>1000</MaxIter>
                 <RsdToleranceFactor>100.0</RsdToleranceFactor>
                 <AntiPeriodicT>true</AntiPeriodicT>
                 <SolverType>GCR</SolverType>
                 <Verbose>false</Verbose>
                 <AsymmetricLinop>true</AsymmetricLinop>
                 <CudaReconstruct>RECONS_12</CudaReconstruct>
                 <CudaSloppyPrecision>SINGLE</CudaSloppyPrecision>
                 <CudaSloppyReconstruct>RECONS_12</CudaSloppyReconstruct>
                 <AxialGaugeFix>false</AxialGaugeFix>
                <AutotuneDslash>true</AutotuneDslash>
                 <MULTIGRIDParams>
                   <Verbosity>true</Verbosity>
                   <Precision>HALF</Precision>
                   <Reconstruct>RECONS_12</Reconstruct>
                   <Blocking>
                     <elem>3 3 3 2</elem>
                     <elem>2 2 2 2</elem>
                     <elem>2 2 2 2</elem>
                   </Blocking>
                   <CoarseSolverType>
                     <elem>GCR</elem>
                     <elem>GCR</elem>
                     <elem>CA_GCR</elem>
                   </CoarseSolverType>
                   <CoarseResidual>0.1 0.1 0.1 0.1</CoarseResidual>
                   <MaxCoarseIterations>12 12 12 8</MaxCoarseIterations>
                   <RelaxationOmegaMG>1.0 1.0 1.0 1.0</RelaxationOmegaMG>
                   <SmootherType>
                     <elem>CA_GCR</elem>
                     <elem>CA_GCR</elem>
                     <elem>CA_GCR</elem>
                     <elem>CA_GCR</elem>
                   </SmootherType>
                   <SmootherTol>0.25 0.25 0.25 0.25</SmootherTol>
                   <SmootherHaloPrecision>
                     <elem>DEFAULT</elem>
                     <elem>HALF</elem>
                     <elem>HALF</elem>
                     <elem>DEFAULT</elem>
                   </SmootherHaloPrecision>
                   <NullVectors>24 32 32</NullVectors>
                   <Pre-SmootherApplications>0 0 0</Pre-SmootherApplications>
                   <Post-SmootherApplications>8 8 8</Post-SmootherApplications>
                   <SubspaceSolver>
                     <elem>CG</elem>
                     <elem>CG</elem>
                     <elem>CG</elem>
                   </SubspaceSolver>
                   <RsdTargetSubspaceCreate>5e-06 5e-06 5e-06</RsdTargetSubspaceCreate>
                   <MaxIterSubspaceCreate>1000 1000 1000</MaxIterSubspaceCreate>
                   <MaxIterSubspaceRefresh>500 500 500</MaxIterSubspaceRefresh>
                   <OuterGCRNKrylov>30</OuterGCRNKrylov>
                   <PrecondGCRNKrylov>20</PrecondGCRNKrylov>
                   <GenerateNullspace>true</GenerateNullspace>
                   <CheckMultigridSetup>false</CheckMultigridSetup>
                   <GenerateAllLevels>true</GenerateAllLevels>
                   <CycleType>MG_RECURSIVE</CycleType>
                   <SchwarzType>ADDITIVE_SCHWARZ</SchwarzType>
                   <RelaxationOmegaOuter>1.0</RelaxationOmegaOuter>
                   <SetupOnGPU>1 1 1</SetupOnGPU>
                 </MULTIGRIDParams>
                 <SubspaceID>subspace_208</SubspaceID>
                 <ThresholdCount>500</ThresholdCount>
              </InvertParam>
 */






// **********************************************************************

void InverterInfo::set_info_multigrid(XMLHandler& xmlr)
{
 svalues.resize(1);
 rvalues.resize(10);
 ivalues.resize(50);
 svalues[0]="MULTIGRID";
 int rvalindex=0;
 int ivalindex=0;
 xmlsetQPReal(xmlr,"Tolerance",rvalues,rvalindex);
 xmlsetQPInt(xmlr,"MaxIterations",ivalues,ivalindex);
 const int mg_max_levels=4;
 xmlsetQPInt(xmlr,"NumLevels",ivalues,ivalindex);
 uint nlevels=ivalues[ivalindex-1];
 if ((ivalues[1]<1)||(ivalues[1]>mg_max_levels)){
    throw(std::invalid_argument("Unsupported number of levels in MultiGrid inverter"));}
 list<XMLHandler> xmllevels=xmlr.find("Level");
 if (xmllevels.size()!=nlevels){
    throw(std::invalid_argument("Number of <Level> tags does not match <NumLevels> in MultiGrid inverter"));}
 std::map<int,list<XMLHandler>::iterator> lmap;
 for (list<XMLHandler>::iterator it=xmllevels.begin();it!=xmllevels.end();++it){
    xmlsetQPInt(*it,"IdNum",ivalues,ivalindex);
    int idnum=ivalues[ivalindex-1];
    if ((idnum<0)||(idnum>=int(nlevels))){
       throw(std::invalid_argument("Invalid level <IdNum> in MultiGrid inverter"));}
    lmap.insert(make_pair(idnum,it));
    --ivalindex;}
 if (lmap.size()!=nlevels){
    throw(std::invalid_argument("<Level> tags do not all have appropriate <IdNum> values in MultiGrid inverter"));}
 ivalues.resize(2+16*nlevels);
 rvalues.resize(1+3*nlevels);
 for (uint k=0;k<nlevels;++k){
    list<XMLHandler>::iterator it=lmap[k];
    xmlsetQPInt(*it,"IdNum",ivalues,ivalindex);
    xmlsetQPEnum(*it,"CoarseSolverType",{"CG","BICGSTAB","GCR","CA_GCR","CA_CG"},
                 ivalues,ivalindex,true,(k<(nlevels-1))?2:3);
    xmlsetQPEnum(*it,"CoarseSolutionType",{"MAT","MAT_PC"},ivalues,ivalindex);
    xmlsetQPReal(*it,"CoarseSolverTolerance",rvalues,rvalindex,true,0.25);
    xmlsetQPInt(*it,"CoarseSolverMaxIterations",ivalues,ivalindex,true,40);
    xmlsetQPIntVector(*it,"Blocking",ivalues,ivalindex,LayoutInfo::Ndim);
    xmlsetQPInt(*it,"SpinBlockSize",ivalues,ivalindex,true,(k==0)?2:1);
    xmlsetQPInt(*it,"NumNullVectors",ivalues,ivalindex,true,24); // other choice 32
    xmlsetQPEnum(*it,"SmootherType",{"CA_GCR","CA_CG"},ivalues,ivalindex,true,0);
    xmlsetQPEnum(*it,"SmootherSolveType",{"DIRECT_PC","NORMOP_PC"},ivalues,ivalindex,true,0);
    xmlsetQPReal(*it,"SmootherTolerance",rvalues,rvalindex,true,0.25);
    xmlsetQPInt(*it,"NumPreSmooth",ivalues,ivalindex,true,0);
    xmlsetQPInt(*it,"NumPostSmooth",ivalues,ivalindex,true,8);
    xmlsetQPReal(*it,"OverRelaxOmega",rvalues,rvalindex,true,0.8);
    xmlsetQPEnum(*it,"CycleType",{"R","V","F","W"},ivalues,ivalindex,true,0);
    xmlsetQPInt(*it,"SmootherSchwarzCycle",ivalues,ivalindex,true,1);   
    }

// printLaph(make_str("rvalindex = ",rvalindex));
// printLaph(make_str("ivalindex = ",ivalindex));
}


void InverterInfo::output_multigrid(XMLHandler& xmlout) const
{
 int ivalindex=0;
 int rvalindex=0;
 xmlout.set_root("InverterInfo");
 xmlout.put_child("Name","MULTIGRID");
 xmlout.put_child(xmloutputQPReal("Tolerance",rvalues,rvalindex));
 xmlout.put_child(xmloutputQPInt("MaxIterations",ivalues,ivalindex));
 xmlout.put_child(xmloutputQPInt("NumLevels",ivalues,ivalindex));
 for (int idnum=0;idnum<ivalues[1];++idnum){
    XMLHandler xmllevel("Level");
    xmllevel.put_child(xmloutputQPInt("IdNum",ivalues,ivalindex));
    xmllevel.put_child(xmloutputQPEnum("CoarseSolverType",{"CG","BICGSTAB","GCR","CA_GCR","CA_CG"},ivalues,ivalindex));
    xmllevel.put_child(xmloutputQPEnum("CoarseSolutionType",{"MAT","MAT_PC"},ivalues,ivalindex));
    xmllevel.put_child(xmloutputQPReal("CoarseSolverTolerance",rvalues,rvalindex));
    xmllevel.put_child(xmloutputQPInt("CoarseSolverMaxIterations",ivalues,ivalindex));
    xmllevel.put_child(xmloutputQPIntVector("Blocking",ivalues,ivalindex,LayoutInfo::Ndim));
    xmllevel.put_child(xmloutputQPInt("SpinBlockSize",ivalues,ivalindex));
    xmllevel.put_child(xmloutputQPInt("NumNullVectors",ivalues,ivalindex));
    xmllevel.put_child(xmloutputQPEnum("SmootherType",{"CA_GCR","CA_CG"},ivalues,ivalindex));
    xmllevel.put_child(xmloutputQPEnum("SmootherSolveType",{"DIRECT_PC","NORMOP_PC"},ivalues,ivalindex));
    xmllevel.put_child(xmloutputQPReal("SmootherTolerance",rvalues,rvalindex));
    xmllevel.put_child(xmloutputQPInt("NumPreSmooth",ivalues,ivalindex));
    xmllevel.put_child(xmloutputQPInt("NumPostSmooth",ivalues,ivalindex));
    xmllevel.put_child(xmloutputQPReal("OverRelaxOmega",rvalues,rvalindex));
    xmllevel.put_child(xmloutputQPEnum("CycleType",{"R","V","F","W"},ivalues,ivalindex));
    xmllevel.put_child(xmloutputQPInt("SmootherSchwarzCycle",ivalues,ivalindex));   


    xmlout.put_child(xmllevel);
    }
}
 

void InverterInfo::setQudaInvertParam_multigrid(QudaInvertParam& invParam) const
{
 invParam=newQudaInvertParam();
 invParam.cpu_prec = QudaInfo::get_cpu_prec();
 invParam.cuda_prec = QudaInfo::get_cuda_prec();

// invParam.solution_type = QUDA_MATPC_SOLUTION;
 invParam.solution_type = QUDA_MAT_SOLUTION;

 invParam.solve_type = QUDA_DIRECT_PC_SOLVE;

// invParam.matpc_type = QUDA_MATPC_ODD_ODD_ASYMMETRIC;
 invParam.matpc_type = QUDA_MATPC_EVEN_EVEN;

 invParam.tune = QUDA_TUNE_YES;
 invParam.inv_type = QUDA_MG_INVERTER;
 int ivalindex=0;
 int rvalindex=0;
 invParam.tol = xmlputQPReal("Tolerance",rvalues,rvalindex);
 invParam.reliable_delta = 0.1;  
 invParam.maxiter = xmlputQPInt("MaxIterations",ivalues,ivalindex);
 invParam.pipeline = 0;
 invParam.dagger = QUDA_DAG_NO;
 invParam.verbosity = getVerbosity();
 invParam.compute_true_res=true;
 invParam.preserve_source = QUDA_PRESERVE_SOURCE_NO;
 invParam.cuda_prec_sloppy = QudaInfo::get_cuda_prec_sloppy();
 invParam.cuda_prec_refinement_sloppy = QudaInfo::get_cuda_prec_sloppy();
 invParam.cuda_prec_precondition = QUDA_HALF_PRECISION;
 invParam.cuda_prec_eigensolver = QudaInfo::get_cuda_prec();
 invParam.struct_size = sizeof(invParam);

}


void InverterInfo::setQudaMGParam_multigrid(QudaMultigridParam& mg_param) const
{
 int ivalindex=1;
 int rvalindex=1;
 mg_param = newQudaMultigridParam();
 mg_param.n_level=xmlputQPInt("NumLevels",ivalues,ivalindex);

 for (int idnum=0;idnum<ivalues[1];++idnum){
    if (xmlputQPInt("IdNum",ivalues,ivalindex)!=idnum){
       errorLaph("Problem occurred in set multigrid parameters");}
    mg_param.coarse_solver[idnum]=static_cast<QudaInverterType>(xmlputQPEnum("CoarseSolverType",
                 {QUDA_CG_INVERTER,QUDA_BICGSTAB_INVERTER,QUDA_GCR_INVERTER,
                  QUDA_CA_GCR_INVERTER,QUDA_CA_CG_INVERTER},ivalues,ivalindex));
    mg_param.coarse_grid_solution_type[idnum]=static_cast<QudaSolutionType>(xmlputQPEnum("CoarseSolutionType",
                 {QUDA_MAT_SOLUTION,QUDA_MATPC_SOLUTION},ivalues,ivalindex));
    mg_param.coarse_solver_tol[idnum]=xmlputQPReal("CoarseSolverTolerance",rvalues,rvalindex);
    mg_param.coarse_solver_maxiter[idnum]=xmlputQPInt("CoarseSolverMaxIterations",ivalues,ivalindex);
    vector<int> blocksizes=xmlputQPIntVector("Blocking",ivalues,ivalindex,LayoutInfo::Ndim);
    for (int dir=0;dir<LayoutInfo::Ndim;++dir){
       mg_param.geo_block_size[idnum][dir]=blocksizes[dir];}
    mg_param.spin_block_size[idnum]=xmlputQPInt("SpinBlockSize",ivalues,ivalindex);
    mg_param.n_vec[idnum]=xmlputQPInt("NumNullVectors",ivalues,ivalindex);
    mg_param.smoother[idnum]=static_cast<QudaInverterType>(xmlputQPEnum("SmootherType",
                 {QUDA_CA_GCR_INVERTER,QUDA_CA_CG_INVERTER},ivalues,ivalindex));
    mg_param.smoother_solve_type[idnum]=static_cast<QudaSolveType>(xmlputQPEnum("SmootherSolveType",
                 {QUDA_DIRECT_PC_SOLVE,QUDA_NORMOP_PC_SOLVE},ivalues,ivalindex));
    mg_param.smoother_tol[idnum]=xmlputQPReal("SmootherTolerance",rvalues,rvalindex);
    mg_param.nu_pre[idnum]=xmlputQPInt("NumPreSmooth",ivalues,ivalindex);
    mg_param.nu_post[idnum]=xmlputQPInt("NumPostSmooth",ivalues,ivalindex);
    mg_param.omega[idnum]=xmlputQPReal("OverRelaxOmega",rvalues,rvalindex);
    mg_param.cycle_type[idnum]=static_cast<QudaMultigridCycleType>(xmlputQPEnum("CycleType",
                 {QUDA_MG_CYCLE_RECURSIVE,QUDA_MG_CYCLE_VCYCLE,QUDA_MG_CYCLE_FCYCLE,
                  QUDA_MG_CYCLE_WCYCLE},ivalues,ivalindex));
    mg_param.smoother_schwarz_cycle[idnum]=xmlputQPInt("SmootherSchwarzCycle",ivalues,ivalindex);   

    mg_param.location[idnum]=QUDA_CUDA_FIELD_LOCATION;
    mg_param.smoother_schwarz_type[idnum]=QUDA_INVALID_SCHWARZ;

    mg_param.precision_null[idnum]=QUDA_HALF_PRECISION;
    mg_param.verbosity[idnum]=QUDA_SILENT;
    mg_param.global_reduction[idnum]=QUDA_BOOLEAN_YES;   // unless using schwarz smoother

    }

 mg_param.compute_null_vector = QUDA_COMPUTE_NULL_VECTOR_YES;
 mg_param.generate_all_levels = QUDA_BOOLEAN_TRUE;
 mg_param.run_verify = QUDA_BOOLEAN_TRUE;

// QudaInvertParam mg_inv_param = newQudaInvertParam();
// const int QUDA_MAX_MG_LEVEL=4;
// QudaEigParam mg_eig_param[QUDA_MAX_MG_LEVEL];
// QudaEigParam eig_param = newQudaEigParam();
// bool use_split_grid = false;




/*

    / ** Size of this struct in bytes.  Used to ensure that the host application and QUDA see the same struct size * /
    size_t struct_size;

    QudaInvertParam *invert_param;

    QudaEigParam *eig_param[QUDA_MAX_MG_LEVEL];

    / ** Number of multigrid levels * /
DONE    int n_level;  

    / ** Geometric block sizes to use on each level * /
    int geo_block_size[QUDA_MAX_MG_LEVEL][QUDA_MAX_DIM];                  <Blocking><elem>3 3 3 2</elem>

    / ** Spin block sizes to use on each level * /
    int spin_block_size[QUDA_MAX_MG_LEVEL];

    / ** Number of null-space vectors to use on each level * /
DONE    int n_vec[QUDA_MAX_MG_LEVEL];

    / ** Precision to store the null-space vectors in (post block orthogonalization) * /
    QudaPrecision precision_null[QUDA_MAX_MG_LEVEL];

    / ** Number of times to repeat Gram-Schmidt in block orthogonalization * /
    int n_block_ortho[QUDA_MAX_MG_LEVEL];

    / ** Whether to do passes at block orthogonalize in fixed point for improved accuracy * /
    QudaBoolean block_ortho_two_pass[QUDA_MAX_MG_LEVEL];

    / ** Verbosity on each level of the multigrid * /
    QudaVerbosity verbosity[QUDA_MAX_MG_LEVEL];            <Verbosity>

    / ** Setup MMA usage on each level of the multigrid * /
    QudaBoolean setup_use_mma[QUDA_MAX_MG_LEVEL];

    / ** Dslash MMA usage on each level of the multigrid * /
    QudaBoolean dslash_use_mma[QUDA_MAX_MG_LEVEL];

    / ** Inverter to use in the setup phase * /
    QudaInverterType setup_inv_type[QUDA_MAX_MG_LEVEL];

    / ** Number of setup iterations * /
    int num_setup_iter[QUDA_MAX_MG_LEVEL];

    / ** Tolerance to use in the setup phase * /
    double setup_tol[QUDA_MAX_MG_LEVEL];

    / ** Maximum number of iterations for each setup solver * /
    int setup_maxiter[QUDA_MAX_MG_LEVEL];

    / ** Maximum number of iterations for refreshing the null-space vectors * /
    int setup_maxiter_refresh[QUDA_MAX_MG_LEVEL];

    / ** Basis to use for CA solver setup * /
    QudaCABasis setup_ca_basis[QUDA_MAX_MG_LEVEL];

    / ** Basis size for CA solver setup * /
    int setup_ca_basis_size[QUDA_MAX_MG_LEVEL];

    / ** Minimum eigenvalue for Chebyshev CA basis * /
    double setup_ca_lambda_min[QUDA_MAX_MG_LEVEL];

    / ** Maximum eigenvalue for Chebyshev CA basis * /
    double setup_ca_lambda_max[QUDA_MAX_MG_LEVEL];

    / ** Null-space type to use in the setup phase * /
    QudaSetupType setup_type;

    / ** Pre orthonormalize vectors in the setup phase * /
    QudaBoolean pre_orthonormalize;

    / ** Post orthonormalize vectors in the setup phase * /
    QudaBoolean post_orthonormalize;

    / ** The solver that wraps around the coarse grid correction and smoother * /
DONE    QudaInverterType coarse_solver[QUDA_MAX_MG_LEVEL];                <CoarseSolverType>

    / ** Tolerance for the solver that wraps around the coarse grid correction and smoother * /
DONE    double coarse_solver_tol[QUDA_MAX_MG_LEVEL];              <CoarseResidual>

    / ** Maximum number of iterations for the solver that wraps around the coarse grid correction and smoother * /
DONE    int coarse_solver_maxiter[QUDA_MAX_MG_LEVEL];          <MaxCoarseIterations>

    / ** Basis to use for CA coarse solvers * /
    QudaCABasis coarse_solver_ca_basis[QUDA_MAX_MG_LEVEL];

    / ** Basis size for CA coarse solvers * /
    int coarse_solver_ca_basis_size[QUDA_MAX_MG_LEVEL];

    / ** Minimum eigenvalue for Chebyshev CA basis * /
    double coarse_solver_ca_lambda_min[QUDA_MAX_MG_LEVEL];

    / ** Maximum eigenvalue for Chebyshev CA basis * /
    double coarse_solver_ca_lambda_max[QUDA_MAX_MG_LEVEL];

    / ** Smoother to use on each level * /
    QudaInverterType smoother[QUDA_MAX_MG_LEVEL];      <SmootherType>

    / ** Tolerance to use for the smoother / solver on each level * /
    double smoother_tol[QUDA_MAX_MG_LEVEL];       <SmootherTol>

    / ** Number of pre-smoother applications on each level * /
    int nu_pre[QUDA_MAX_MG_LEVEL];

    / ** Number of post-smoother applications on each level * /
    int nu_post[QUDA_MAX_MG_LEVEL];

    / ** Basis to use for CA smoother solvers * /
    QudaCABasis smoother_solver_ca_basis[QUDA_MAX_MG_LEVEL];

    / ** Minimum eigenvalue for Chebyshev CA smoother basis * /
    double smoother_solver_ca_lambda_min[QUDA_MAX_MG_LEVEL];

    / ** Maximum eigenvalue for Chebyshev CA smoother basis * /
    double smoother_solver_ca_lambda_max[QUDA_MAX_MG_LEVEL];

    / ** Over/under relaxation factor for the smoother at each level * /
    double omega[QUDA_MAX_MG_LEVEL];        <RelaxationOmegaMG>

    / ** Precision to use for halo communication in the smoother * /
    QudaPrecision smoother_halo_precision[QUDA_MAX_MG_LEVEL];       <SmootherHaloPrecision>

    / ** Whether to use additive or multiplicative Schwarz preconditioning in the smoother * /
    QudaSchwarzType smoother_schwarz_type[QUDA_MAX_MG_LEVEL];

    / ** Number of Schwarz cycles to apply * /
    int smoother_schwarz_cycle[QUDA_MAX_MG_LEVEL];

    / ** The type of residual to send to the next coarse grid, and thus the
	type of solution to receive back from this coarse grid * /
    QudaSolutionType coarse_grid_solution_type[QUDA_MAX_MG_LEVEL];

    / ** The type of smoother solve to do on each grid (e/o preconditioning or not)* /
    QudaSolveType smoother_solve_type[QUDA_MAX_MG_LEVEL];

    / ** The type of multigrid cycle to perform at each level * /
    QudaMultigridCycleType cycle_type[QUDA_MAX_MG_LEVEL];

    / ** Whether to use global reductions or not for the smoother / solver at each level * /
    QudaBoolean global_reduction[QUDA_MAX_MG_LEVEL];

    / ** Location where each level should be done * /
    QudaFieldLocation location[QUDA_MAX_MG_LEVEL];

    / ** Location where the coarse-operator construction will be computedn * /
    QudaFieldLocation setup_location[QUDA_MAX_MG_LEVEL];

    / ** Whether to use eigenvectors for the nullspace or, if the coarsest instance deflate* /
    QudaBoolean use_eig_solver[QUDA_MAX_MG_LEVEL];

    / ** Minimize device memory allocations during the adaptive setup,
        placing temporary fields in mapped memory instad of device
        memory * /
    QudaBoolean setup_minimize_memory;

    / ** Whether to compute the null vectors or reload them * /
    QudaComputeNullVector compute_null_vector;

    / ** Whether to generate on all levels or just on level 0 * /
    QudaBoolean generate_all_levels;

    / ** Whether to run the verification checks once set up is complete * /
    QudaBoolean run_verify;

    / ** Whether to run null Vs eigen vector overlap checks once set up is complete * /
    QudaBoolean run_low_mode_check;

    / ** Whether to run null vector oblique checks once set up is complete * /
    QudaBoolean run_oblique_proj_check;

    / ** Whether to load the null-space vectors to disk (requires QIO) * /
    QudaBoolean vec_load[QUDA_MAX_MG_LEVEL];

    / ** Filename prefix where to load the null-space vectors * /
    char vec_infile[QUDA_MAX_MG_LEVEL][256];

    / ** Whether to store the null-space vectors to disk (requires QIO) * /
    QudaBoolean vec_store[QUDA_MAX_MG_LEVEL];

    / ** Filename prefix for where to save the null-space vectors * /
    char vec_outfile[QUDA_MAX_MG_LEVEL][256];

    / ** Whether to store the null-space vectors in singlefile or partfile format * /
    QudaBoolean mg_vec_partfile[QUDA_MAX_MG_LEVEL];

    / ** Whether to use and initial guess during coarse grid deflation * /
    QudaBoolean coarse_guess;

    / ** Whether to preserve the deflation space during MG update * /
    QudaBoolean preserve_deflation;

    / ** The Gflops rate of the multigrid solver setup * /
    double gflops;

    / **< The time taken by the multigrid solver setup * /
    double secs;

    / ** Multiplicative factor for the mu parameter * /
    double mu_factor[QUDA_MAX_MG_LEVEL];

    / ** Boolean for aggregation type, implies staggered or not * /
    QudaTransferType transfer_type[QUDA_MAX_MG_LEVEL];

    / ** Whether or not to let MG coarsening drop improvements, for ex dropping long links in small aggregation dimensions * /
    QudaBoolean allow_truncation;

    / ** Whether or not to use the dagger approximation for the KD preconditioned operator * /
    QudaBoolean staggered_kd_dagger_approximation;

    / ** Whether to do a full (false) or thin (true) update in the context of updateMultigridQuda * /
    QudaBoolean thin_update_only;
  } QudaMultigridParam;
*/

/*
  if (inv_multigrid) {
    setQudaMgSolveTypes();
    setMultigridInvertParam(inv_param);
    // Set sub structures
    mg_param.invert_param = &mg_inv_param;
    for (int i = 0; i < mg_levels; i++) {
      if (mg_eig[i]) {
        mg_eig_param[i] = newQudaEigParam();
        setMultigridEigParam(mg_eig_param[i], i);
        mg_param.eig_param[i] = &mg_eig_param[i];
      } else {
        mg_param.eig_param[i] = nullptr;
      }
    }
    // Set MG
    setMultigridParam(mg_param);
  } else {
    setInvertParam(inv_param);
  }

  if (inv_deflate) {
    setEigParam(eig_param);
    inv_param.eig_param = &eig_param;
  } else {
    inv_param.eig_param = nullptr;
  }
*/





























/*


void setQudaDefaultMgTestParams()
{
  // We give here some default values
  for (int i = 0; i < QUDA_MAX_MG_LEVEL; i++) {
    mg_verbosity[i] = QUDA_SUMMARIZE;
#ifdef QUDA_MMA_AVAILABLE
    mg_setup_use_mma[i] = true;
#else
    mg_setup_use_mma[i] = false;
#endif
    mg_dslash_use_mma[i] = false;
    setup_inv[i] = QUDA_BICGSTAB_INVERTER;
    num_setup_iter[i] = 1;
    setup_tol[i] = 5e-6;
    setup_maxiter[i] = 500;
    setup_maxiter_refresh[i] = 20;
    mu_factor[i] = 1.;
    coarse_solve_type[i] = QUDA_INVALID_SOLVE;
    smoother_solve_type[i] = QUDA_INVALID_SOLVE;
    mg_schwarz_type[i] = QUDA_INVALID_SCHWARZ;
    mg_schwarz_cycle[i] = 1;
    smoother_type[i] = QUDA_MR_INVERTER;
    smoother_tol[i] = 0.25;
    coarse_solver[i] = QUDA_GCR_INVERTER;
    coarse_solver_tol[i] = 0.25;
    coarse_solver_maxiter[i] = 100;
    solver_location[i] = QUDA_CUDA_FIELD_LOCATION;
    setup_location[i] = QUDA_CUDA_FIELD_LOCATION;
    nu_pre[i] = 2;
    nu_post[i] = 2;
    n_block_ortho[i] = 1;
    block_ortho_two_pass[i] = true;

    // Default eigensolver params
    mg_eig[i] = false;
    mg_eig_tol[i] = 1e-3;
    mg_eig_n_ev[i] = nvec[i];
    mg_eig_n_kr[i] = 3 * nvec[i];
    mg_eig_require_convergence[i] = QUDA_BOOLEAN_TRUE;
    mg_eig_type[i] = QUDA_EIG_TR_LANCZOS;
    mg_eig_spectrum[i] = QUDA_SPECTRUM_SR_EIG;
    mg_eig_check_interval[i] = 5;
    mg_eig_max_restarts[i] = 100;
    mg_eig_max_ortho_attempts[i] = 10;
    mg_eig_use_normop[i] = QUDA_BOOLEAN_FALSE;
    mg_eig_use_dagger[i] = QUDA_BOOLEAN_FALSE;
    mg_eig_use_poly_acc[i] = QUDA_BOOLEAN_TRUE;
    mg_eig_poly_deg[i] = 100;
    mg_eig_amin[i] = 1.0;
    mg_eig_amax[i] = -1.0; // use power iterations
    mg_eig_save_prec[i] = QUDA_DOUBLE_PRECISION;

    setup_ca_basis[i] = QUDA_POWER_BASIS;
    setup_ca_basis_size[i] = 4;
    setup_ca_lambda_min[i] = 0.0;
    setup_ca_lambda_max[i] = -1.0; // use power iterations

    coarse_solver_ca_basis[i] = QUDA_POWER_BASIS;
    coarse_solver_ca_basis_size[i] = 4;
    coarse_solver_ca_lambda_min[i] = 0.0;
    coarse_solver_ca_lambda_max[i] = -1.0;

    smoother_solver_ca_basis[i] = QUDA_POWER_BASIS;
    smoother_solver_ca_lambda_min[i] = 0.0;
    smoother_solver_ca_lambda_max[i] = -1.0; // use power iterations
  }
}

  // Set QUDA's internal parameters
  gauge_param = newQudaGaugeParam();
  setWilsonGaugeParam(gauge_param);

  inv_param = newQudaInvertParam();
  mg_param = newQudaMultigridParam();
  mg_inv_param = newQudaInvertParam();
  eig_param = newQudaEigParam();

  if (inv_multigrid) {
    setQudaMgSolveTypes();
    setMultigridInvertParam(inv_param);
    // Set sub structures
    mg_param.invert_param = &mg_inv_param;
    for (int i = 0; i < mg_levels; i++) {
      if (mg_eig[i]) {
        mg_eig_param[i] = newQudaEigParam();
        setMultigridEigParam(mg_eig_param[i], i);
        mg_param.eig_param[i] = &mg_eig_param[i];
      } else {
        mg_param.eig_param[i] = nullptr;
      }
    }
    // Set MG
    setMultigridParam(mg_param);
  } else {
    setInvertParam(inv_param);
  }

  if (inv_deflate) {
    setEigParam(eig_param);
    inv_param.eig_param = &eig_param;
  } else {
    inv_param.eig_param = nullptr;
  }

  // set parameters for the reference Dslash, and prepare fields to be loaded
  if (dslash_type == QUDA_DOMAIN_WALL_DSLASH || dslash_type == QUDA_DOMAIN_WALL_4D_DSLASH
      || dslash_type == QUDA_MOBIUS_DWF_DSLASH || dslash_type == QUDA_MOBIUS_DWF_EOFA_DSLASH) {
    dw_setDims(gauge_param.X, inv_param.Ls);
  } else {
    setDims(gauge_param.X);
  }

  // Allocate host side memory for the gauge field.
  //----------------------------------------------------------------------------
  gauge_.resize(4 * V * gauge_site_size * host_gauge_data_type_size);
  for (int i = 0; i < 4; i++) gauge[i] = gauge_.data() + i * V * gauge_site_size * host_gauge_data_type_size;
  constructHostGaugeField(gauge.data(), gauge_param, argc, argv);

  // Allocate host side memory for clover terms if needed.
  if (dslash_type == QUDA_CLOVER_WILSON_DSLASH || dslash_type == QUDA_TWISTED_CLOVER_DSLASH) {
    clover.resize(V * clover_site_size * host_clover_data_type_size);
    clover_inv.resize(V * clover_site_size * host_spinor_data_type_size);
    constructHostCloverField(clover.data(), clover_inv.data(), inv_param);
  }

  if (!enable_testing) {
    // Load the gauge field to the device
    loadGaugeQuda(gauge.data(), &gauge_param);

    if (dslash_type == QUDA_CLOVER_WILSON_DSLASH || dslash_type == QUDA_TWISTED_CLOVER_DSLASH) {
      // Load the clover terms to the device
      loadCloverQuda(clover.data(), clover_inv.data(), &inv_param);
    }

    // Compute plaquette as a sanity check
    double plaq[3];
    plaqQuda(plaq);
    printfQuda("Computed plaquette is %e (spatial = %e, temporal = %e)\n", plaq[0], plaq[1], plaq[2]);
  }
}

std::vector<std::array<double, 2>> solve(test_t param)
{
  inv_param.cuda_prec = ::testing::get<0>(param);
  inv_param.clover_cuda_prec = ::testing::get<0>(param);
  inv_param.cuda_prec_sloppy = ::testing::get<1>(param);
  inv_param.cuda_prec_refinement_sloppy = ::testing::get<1>(param);
  inv_param.cuda_prec_eigensolver = ::testing::get<1>(param);
  inv_param.clover_cuda_prec_sloppy = ::testing::get<1>(param);
  inv_param.clover_cuda_prec_refinement_sloppy = ::testing::get<1>(param);
  inv_param.clover_cuda_prec_eigensolver = ::testing::get<1>(param);
  inv_param.inv_type = ::testing::get<2>(param);
  inv_param.solution_type = ::testing::get<3>(param);
  inv_param.solve_type = ::testing::get<4>(param);
  multishift = ::testing::get<5>(param);
  inv_param.solution_accumulator_pipeline = ::testing::get<6>(param);

  // schwarz parameters
  auto schwarz_param = ::testing::get<7>(param);
  inv_param.schwarz_type           = ::testing::get<0>(schwarz_param);
  inv_param.inv_type_precondition  = ::testing::get<1>(schwarz_param);
  inv_param.cuda_prec_precondition = ::testing::get<2>(schwarz_param);
  inv_param.clover_cuda_prec_precondition = ::testing::get<2>(schwarz_param);

  inv_param.residual_type = ::testing::get<8>(param);

  // reset lambda_max if we're doing a testing loop to ensure correct lambma_max
  if (enable_testing) inv_param.ca_lambda_max = -1.0;

  logQuda(QUDA_SUMMARIZE, "Solution = %s, Solve = %s, Solver = %s, Precision = %s, Sloppy precision = %s\n",
          get_solution_str(inv_param.solution_type), get_solve_str(inv_param.solve_type),
          get_solver_str(inv_param.inv_type), get_prec_str(inv_param.cuda_prec),
          get_prec_str(inv_param.cuda_prec_sloppy));

  // params corresponds to split grid
  for (int i = 0; i < 4; i++) inv_param.split_grid[i] = grid_partition[i];
  int num_sub_partition = grid_partition[0] * grid_partition[1] * grid_partition[2] * grid_partition[3];
  use_split_grid = num_sub_partition > 1;

  // Now QUDA is initialised and the fields are loaded, we may setup the preconditioner
  void *mg_preconditioner = nullptr;
  if (inv_multigrid) {
    if (use_split_grid) { errorQuda("Split grid does not work with MG yet."); }
    mg_preconditioner = newMultigridQuda(&mg_param);
    inv_param.preconditioner = mg_preconditioner;

    printfQuda("MG Setup Done: %g secs, %g Gflops\n", mg_param.secs, mg_param.gflops / mg_param.secs);
  }

  // Vector construct START
  //-----------------------------------------------------------------------------------
  std::vector<quda::ColorSpinorField> in(Nsrc);
  std::vector<quda::ColorSpinorField> out(Nsrc);
  std::vector<quda::ColorSpinorField> out_multishift(multishift * Nsrc);
  quda::ColorSpinorField check;
  quda::ColorSpinorParam cs_param;
  constructWilsonTestSpinorParam(&cs_param, &inv_param, &gauge_param);
  check = quda::ColorSpinorField(cs_param);
  std::vector<std::vector<void *>> _hp_multi_x(Nsrc, std::vector<void *>(multishift));

  // QUDA host array for internal checks and malloc
  // Vector construct END
  //-----------------------------------------------------------------------------------

  // Shifts
  std::vector<double> shifts(multishift);

  // QUDA invert test BEGIN
  //----------------------------------------------------------------------------
  if (multishift > 1) {
    if (use_split_grid) { errorQuda("Split grid does not work with multishift yet."); }
    inv_param.num_offset = multishift;

    // Consistency check for shifts, tols, tols_hq size if we're setting custom values
    if (multishift_masses.size() != 0)
      errorQuda("Multishift masses are not supported for Wilson-type fermions");
    if (multishift_shifts.size() != 0 && multishift_shifts.size() != static_cast<unsigned long>(multishift))
      errorQuda("Multishift shift count %d does not agree with number of shifts passed in %lu\n", multishift, multishift_shifts.size());
    if (multishift_tols.size() != 0 && multishift_tols.size() != static_cast<unsigned long>(multishift))
      errorQuda("Multishift tolerance count %d does not agree with number of masses passed in %lu\n", multishift, multishift_tols.size());
    if (multishift_tols_hq.size() != 0 && multishift_tols_hq.size() != static_cast<unsigned long>(multishift))
      errorQuda("Multishift hq tolerance count %d does not agree with number of masses passed in %lu\n", multishift, multishift_tols_hq.size());

    // Copy offsets and tolerances into inv_param; copy data pointers
    for (int i = 0; i < multishift; i++) {
      shifts[i] = (multishift_shifts.size() == 0 ? (i * i * 0.01) : multishift_shifts[i]);
      inv_param.offset[i] = shifts[i];
      inv_param.tol_offset[i] = (multishift_tols.size() == 0 ? inv_param.tol : multishift_tols[i]);
      inv_param.tol_hq_offset[i] = (multishift_tols_hq.size() == 0 ? inv_param.tol_hq : multishift_tols_hq[i]);

      // Allocate memory and set pointers
      for (int n = 0; n < Nsrc; n++) {
        out_multishift[n * multishift + i] = quda::ColorSpinorField(cs_param);
        _hp_multi_x[n][i] = out_multishift[n * multishift + i].data();
      }
    }
  }

  std::vector<double> time(Nsrc);
  std::vector<double> gflops(Nsrc);
  std::vector<int> iter(Nsrc);

  quda::RNG rng(check, 1234);

  for (int i = 0; i < Nsrc; i++) {
    // Populate the host spinor with random numbers.
    in[i] = quda::ColorSpinorField(cs_param);
    spinorNoise(in[i], rng, QUDA_NOISE_GAUSS);
    out[i] = quda::ColorSpinorField(cs_param);
  }

  if (distance_pc_alpha0 != 0.0 && distance_pc_t0 >= 0) {
    inv_param.distance_pc_alpha0 = distance_pc_alpha0;
    inv_param.distance_pc_t0 = distance_pc_t0;
    verifySpinorDistanceReweight(in[0], distance_pc_alpha0, distance_pc_t0);
  }

  if (!use_split_grid) {

    for (int i = 0; i < Nsrc; i++) {
      // If deflating, preserve the deflation space between solves
      if (inv_deflate) eig_param.preserve_deflation = i < Nsrc - 1 ? QUDA_BOOLEAN_TRUE : QUDA_BOOLEAN_FALSE;
      // Perform QUDA inversions
      if (multishift > 1) {
        invertMultiShiftQuda(_hp_multi_x[i].data(), in[i].data(), &inv_param);
      } else {
        invertQuda(out[i].data(), in[i].data(), &inv_param);
      }

      time[i] = inv_param.secs;
      gflops[i] = inv_param.gflops / inv_param.secs;
      iter[i] = inv_param.iter;
      printfQuda("Done: %i iter / %g secs = %g Gflops\n", inv_param.iter, inv_param.secs,
                 inv_param.gflops / inv_param.secs);
    }
  } else {

    inv_param.num_src = Nsrc;
    inv_param.num_src_per_sub_partition = Nsrc / num_sub_partition;
    // Host arrays for solutions, sources, and check
    std::vector<void *> _hp_x(Nsrc);
    std::vector<void *> _hp_b(Nsrc);
    for (int i = 0; i < Nsrc; i++) {
      _hp_x[i] = out[i].data();
      _hp_b[i] = in[i].data();
    }
    
		// Run split grid
    invertMultiSrcQuda(_hp_x.data(), _hp_b.data(), &inv_param);

    quda::comm_allreduce_int(inv_param.iter);
    inv_param.iter /= quda::comm_size() / num_sub_partition;
    quda::comm_allreduce_sum(inv_param.gflops);
    inv_param.gflops /= quda::comm_size() / num_sub_partition;
    quda::comm_allreduce_max(inv_param.secs);
    printfQuda("Done: %d sub-partitions - %i iter / %g secs = %g Gflops\n", num_sub_partition, inv_param.iter,
               inv_param.secs, inv_param.gflops / inv_param.secs);
  }

  // QUDA invert test COMPLETE
  //----------------------------------------------------------------------------

  // free the multigrid solver
  if (inv_multigrid) destroyMultigridQuda(mg_preconditioner);

  // Compute performance statistics
  if (Nsrc > 1 && !use_split_grid) performanceStats(time, gflops, iter);

  std::vector<std::array<double, 2>> res(Nsrc);
  // Perform host side verification of inversion if requested
  if (verify_results) {
    for (int i = 0; i < Nsrc; i++) {
      res[i] = verifyInversion(out[i].data(), _hp_multi_x[i].data(), in[i].data(), check.data(), gauge_param, inv_param,
                               gauge.data(), clover.data(), clover_inv.data());
    }
  }
  return res;
}
*/





}

// *******************************************************************
}
