
(1)  All of the fields of the QudaInvertParam struct are listed below, with
     enum listed with their possible choices.
     
(2)  How are defaults set?  The function  newQudaInvertParam() is used to 
     start setting a new struct.  This routine does
        QudaInvertParam ret;
     makes a pointer to it, then calls checkInvertParam. This function
     checks and sets the defaults.  I have included the defaults below
     in square brackets (not done yet)



  typedef struct QudaInvertParam_s {

    /** Size of this struct in bytes.  Used to ensure that the host application and QUDA see the same struct size */
    size_t struct_size;     [INVALID_INT]

    QudaFieldLocation input_location; /**< The location of the input field */
    QudaFieldLocation output_location; /**< The location of the output field */

typedef enum QudaFieldLocation_s {
  QUDA_CPU_FIELD_LOCATION = 1,
  QUDA_CUDA_FIELD_LOCATION = 2,
  QUDA_INVALID_FIELD_LOCATION = QUDA_INVALID_ENUM
} QudaFieldLocation;



    QudaDslashType dslash_type; /**< The Dirac Dslash type that is being used */


typedef enum QudaDslashType_s {
  QUDA_WILSON_DSLASH,
  QUDA_CLOVER_WILSON_DSLASH,             <======
  QUDA_CLOVER_HASENBUSCH_TWIST_DSLASH,
  QUDA_DOMAIN_WALL_DSLASH,
  QUDA_DOMAIN_WALL_4D_DSLASH,
  QUDA_MOBIUS_DWF_DSLASH,
  QUDA_MOBIUS_DWF_EOFA_DSLASH,
  QUDA_STAGGERED_DSLASH,
  QUDA_ASQTAD_DSLASH,
  QUDA_TWISTED_MASS_DSLASH,
  QUDA_TWISTED_CLOVER_DSLASH,
  QUDA_LAPLACE_DSLASH,
  QUDA_COVDEV_DSLASH,
  QUDA_INVALID_DSLASH = QUDA_INVALID_ENUM  []
} QudaDslashType;





    QudaInverterType inv_type; /**< Which linear solver to use */

typedef enum QudaInverterType_s {
  QUDA_CG_INVERTER,
  QUDA_BICGSTAB_INVERTER,
  QUDA_GCR_INVERTER,
  QUDA_MR_INVERTER,
  QUDA_SD_INVERTER,
  QUDA_PCG_INVERTER,
  QUDA_EIGCG_INVERTER,
  QUDA_INC_EIGCG_INVERTER,
  QUDA_GMRESDR_INVERTER,
  QUDA_GMRESDR_PROJ_INVERTER,
  QUDA_GMRESDR_SH_INVERTER,
  QUDA_FGMRESDR_INVERTER,
  QUDA_MG_INVERTER,
  QUDA_BICGSTABL_INVERTER,
  QUDA_CGNE_INVERTER,
  QUDA_CGNR_INVERTER,
  QUDA_CG3_INVERTER,
  QUDA_CG3NE_INVERTER,
  QUDA_CG3NR_INVERTER,
  QUDA_CA_CG_INVERTER,
  QUDA_CA_CGNE_INVERTER,
  QUDA_CA_CGNR_INVERTER,
  QUDA_CA_GCR_INVERTER,
  QUDA_INVALID_INVERTER = QUDA_INVALID_ENUM    []
} QudaInverterType;



    double mass;  /**< Used for staggered only */            [INVALID_DOUBLE]
    double kappa; /**< Used for Wilson and Wilson-clover */  [INVALID_DOUBLE]

    double m5;    /**< Domain wall height */
    int Ls;       /**< Extent of the 5th dimension (for domain wall) */

    double_complex b_5[QUDA_MAX_DWF_LS]; /**< Mobius coefficients - only real part used if regular Mobius */
    double_complex c_5[QUDA_MAX_DWF_LS]; /**< Mobius coefficients - only real part used if regular Mobius */

    /**<
     * The following specifies the EOFA parameters. Notation follows arXiv:1706.05843
     * eofa_shift: the "\beta" in the paper
     * eofa_pm: plus or minus for the EOFA operator
     * mq1, mq2, mq3 are the three masses corresponds to Hasenbusch mass spliting.
     * As far as I know mq1 is always the same as "mass" but it's here just for consistence.
     * */
    double eofa_shift;
    int eofa_pm;
    double mq1;
    double mq2;
    double mq3;

    double mu;    /**< Twisted mass parameter */
    double tm_rho;  [0]  /**< Hasenbusch mass shift applied like twisted mass to diagonal (but not inverse) */
    double epsilon; /**< Twisted mass parameter */
    double evmax;   /** maximum of the eigenvalues of the ndeg twisted mass operator needed for fermionic forces  **/

    QudaTwistFlavorType twist_flavor;  /**< Twisted mass flavor */

typedef enum QudaTwistFlavorType_s {
  QUDA_TWIST_SINGLET = 1,
  QUDA_TWIST_NONDEG_DOUBLET = +2,
  QUDA_TWIST_NO = 0,
  QUDA_TWIST_INVALID = QUDA_INVALID_ENUM
} QudaTwistFlavorType;



    int laplace3D; /**< omit this direction from laplace operator: x,y,z,t -> 0,1,2,3 (-1 is full 4D) */
    int covdev_mu; /**< Apply forward/backward covariant derivative in direction mu(mu<=3)/mu-4(mu>3) */

    double tol;    /**< Solver tolerance in the L2 residual norm */
    double tol_restart;   /**< Solver tolerance in the L2 residual norm (used to restart InitCG) */
    double tol_hq; /**< Solver tolerance in the heavy quark residual norm */

    int compute_true_res; /** Whether to compute the true residual post solve */
    double true_res; /**< Actual L2 residual norm achieved in solver */
    double true_res_hq; /**< Actual heavy quark residual norm achieved in solver */
    int maxiter; /**< Maximum number of iterations in the linear solver */
    double reliable_delta; /**< Reliable update tolerance */
    double reliable_delta_refinement; /**< Reliable update tolerance used in post multi-shift solver refinement */
    int use_alternative_reliable; /**< Whether to use alternative reliable updates */
    int use_sloppy_partial_accumulator; /**< Whether to keep the partial solution accumuator in sloppy precision */

    /**< This parameter determines how often we accumulate into the
       solution vector from the direction vectors in the solver.
       E.g., running with solution_accumulator_pipeline = 4, means we
       will update the solution vector every four iterations using the
       direction vectors from the prior four iterations.  This
       increases performance of mixed-precision solvers since it means
       less high-precision vector round-trip memory travel, but
       requires more low-precision memory allocation. */
    int solution_accumulator_pipeline;

    /**< This parameter determines how many consecutive reliable update
    residual increases we tolerate before terminating the solver,
    i.e., how long do we want to keep trying to converge */
    int max_res_increase;

    /**< This parameter determines how many total reliable update
    residual increases we tolerate before terminating the solver,
    i.e., how long do we want to keep trying to converge */
    int max_res_increase_total;

    /**< This parameter determines how many consecutive heavy-quark
    residual increases we tolerate before terminating the solver,
    i.e., how long do we want to keep trying to converge */
    int max_hq_res_increase;

    /**< This parameter determines how many total heavy-quark residual
    restarts we tolerate before terminating the solver, i.e., how long
    do we want to keep trying to converge */
    int max_hq_res_restart_total;

    /**< After how many iterations shall the heavy quark residual be updated */
    int heavy_quark_check;

    int pipeline; /**< Whether to use a pipelined solver with less global sums */

    int num_offset; /**< Number of offsets in the multi-shift solver */

    int num_src; /**< Number of sources in the multiple source solver */

    int num_src_per_sub_partition; /**< Number of sources in the multiple source solver, but per sub-partition */

    /**< The grid of sub-partition according to which the processor grid will be partitioned.
    Should have:
      split_grid[0] * split_grid[1] * split_grid[2] * split_grid[3] * num_src_per_sub_partition == num_src. **/
    int split_grid[QUDA_MAX_DIM];

    int overlap; /**< Width of domain overlaps */

    /** Offsets for multi-shift solver */
    double offset[QUDA_MAX_MULTI_SHIFT];

    /** Solver tolerance for each offset */
    double tol_offset[QUDA_MAX_MULTI_SHIFT];

    /** Solver tolerance for each shift when refinement is applied using the heavy-quark residual */
    double tol_hq_offset[QUDA_MAX_MULTI_SHIFT];

    /** Actual L2 residual norm achieved in solver for each offset */
    double true_res_offset[QUDA_MAX_MULTI_SHIFT];

    /** Iterated L2 residual norm achieved in multi shift solver for each offset */
    double iter_res_offset[QUDA_MAX_MULTI_SHIFT];

    /** Actual heavy quark residual norm achieved in solver for each offset */
    double true_res_hq_offset[QUDA_MAX_MULTI_SHIFT];

    /** Residuals in the partial faction expansion */
    double residue[QUDA_MAX_MULTI_SHIFT];

    /** Whether we should evaluate the action after the linear solver*/
    int compute_action;

    /** Computed value of the bilinear action (complex-valued)
	invert: \phi^\dagger A^{-1} \phi
	multishift: \phi^\dagger r(x) \phi = \phi^\dagger (sum_k residue[k] * (A + offset[k])^{-1} ) \phi */
    double action[2];

    QudaSolutionType solution_type;  /**< Type of system to solve */

typedef enum QudaSolutionType_s {
  QUDA_MAT_SOLUTION,
  QUDA_MATDAG_MAT_SOLUTION,
  QUDA_MATPC_SOLUTION,
  QUDA_MATPC_DAG_SOLUTION,
  QUDA_MATPCDAG_MATPC_SOLUTION,
  QUDA_MATPCDAG_MATPC_SHIFT_SOLUTION,
  QUDA_INVALID_SOLUTION = QUDA_INVALID_ENUM
} QudaSolutionType;


    QudaSolveType solve_type;        /**< How to solve it */

typedef enum QudaSolveType_s {
  QUDA_DIRECT_SOLVE,
  QUDA_NORMOP_SOLVE,
  QUDA_DIRECT_PC_SOLVE,
  QUDA_NORMOP_PC_SOLVE,
  QUDA_NORMERR_SOLVE,
  QUDA_NORMERR_PC_SOLVE,
  QUDA_NORMEQ_SOLVE = QUDA_NORMOP_SOLVE,       // deprecated
  QUDA_NORMEQ_PC_SOLVE = QUDA_NORMOP_PC_SOLVE, // deprecated
  QUDA_INVALID_SOLVE = QUDA_INVALID_ENUM
} QudaSolveType;


  // We have the following four cases (plus preconditioned variants):
  //
  // solution_type    solve_type    Effect
  // -------------    ----------    ------
  // MAT              DIRECT        Solve Ax=b
  // MATDAG_MAT       DIRECT        Solve A^dag y = b, followed by Ax=y
  // MAT              NORMOP        Solve (A^dag A) x = (A^dag b)
  // MATDAG_MAT       NORMOP        Solve (A^dag A) x = b
  // MAT              NORMERR       Solve (A A^dag) y = b, then x = A^dag y
  //
  // We generally require that the solution_type and solve_type
  // preconditioning match.  As an exception, the unpreconditioned MAT
  // solution_type may be used with any solve_type, including
  // DIRECT_PC and NORMOP_PC.  In these cases, preparation of the
  // preconditioned source and reconstruction of the full solution are
  // taken care of by Dirac::prepare() and Dirac::reconstruct(),
  // respectively.


    QudaMatPCType matpc_type;        /**< The preconditioned matrix type */

// Whether the preconditioned matrix is (1-k^2 Deo Doe) or (1-k^2 Doe Deo)
//
// For the clover-improved Wilson Dirac operator, QUDA_MATPC_EVEN_EVEN
// defaults to the "symmetric" form, (1 - k^2 A_ee^-1 D_eo A_oo^-1 D_oe),
// and likewise for QUDA_MATPC_ODD_ODD.
//
// For the "asymmetric" form, (A_ee - k^2 D_eo A_oo^-1 D_oe), select
// QUDA_MATPC_EVEN_EVEN_ASYMMETRIC.
//
typedef enum QudaMatPCType_s {
  QUDA_MATPC_EVEN_EVEN,
  QUDA_MATPC_ODD_ODD,
  QUDA_MATPC_EVEN_EVEN_ASYMMETRIC,
  QUDA_MATPC_ODD_ODD_ASYMMETRIC,
  QUDA_MATPC_INVALID = QUDA_INVALID_ENUM
} QudaMatPCType;




    QudaDagType dagger;              /**< Whether we are using the Hermitian conjugate system or not */

typedef enum QudaDagType_s { QUDA_DAG_NO, QUDA_DAG_YES, QUDA_DAG_INVALID = QUDA_INVALID_ENUM } QudaDagType;




    QudaMassNormalization mass_normalization; /**< The mass normalization is being used by the caller */

typedef enum QudaMassNormalization_s {
  QUDA_KAPPA_NORMALIZATION,
  QUDA_MASS_NORMALIZATION,
  QUDA_ASYMMETRIC_MASS_NORMALIZATION,
  QUDA_INVALID_NORMALIZATION = QUDA_INVALID_ENUM
} QudaMassNormalization;




    QudaSolverNormalization solver_normalization; /**< The normalization desired in the solver */

typedef enum QudaSolverNormalization_s {
  QUDA_DEFAULT_NORMALIZATION, // leave source and solution untouched
  QUDA_SOURCE_NORMALIZATION   // normalize such that || src || = 1
} QudaSolverNormalization;



    QudaPreserveSource preserve_source;       /**< Preserve the source or not in the linear solver (deprecated) */

typedef enum QudaPreserveSource_s {
  QUDA_PRESERVE_SOURCE_NO,  // use the source for the residual
  QUDA_PRESERVE_SOURCE_YES, // keep the source intact
  QUDA_PRESERVE_SOURCE_INVALID = QUDA_INVALID_ENUM
} QudaPreserveSource;



    QudaPrecision cpu_prec;                /**< The precision used by the input fermion fields */
    QudaPrecision cuda_prec;               /**< The precision used by the QUDA solver */
    QudaPrecision cuda_prec_sloppy;        /**< The precision used by the QUDA sloppy operator */
    QudaPrecision cuda_prec_refinement_sloppy; /**< The precision of the sloppy gauge field for the refinement step in multishift */
    QudaPrecision cuda_prec_precondition;  /**< The precision used by the QUDA preconditioner */
    QudaPrecision cuda_prec_eigensolver;   /**< The precision used by the QUDA eigensolver */

typedef enum QudaPrecision_s {
  QUDA_QUARTER_PRECISION = 1,
  QUDA_HALF_PRECISION = 2,
  QUDA_SINGLE_PRECISION = 4,
  QUDA_DOUBLE_PRECISION = 8,
  QUDA_INVALID_PRECISION = QUDA_INVALID_ENUM
} QudaPrecision;




    QudaDiracFieldOrder dirac_order;       /**< The order of the input and output fermion fields */

typedef enum QudaDiracFieldOrder_s {
  QUDA_INTERNAL_DIRAC_ORDER,    // internal dirac order used, varies on precision and dslash type
  QUDA_DIRAC_ORDER,             // even-odd, color inside spin
  QUDA_QDP_DIRAC_ORDER,         // even-odd, spin inside color
  QUDA_QDPJIT_DIRAC_ORDER,      // even-odd, complex-color-spin-spacetime
  QUDA_CPS_WILSON_DIRAC_ORDER,  // odd-even, color inside spin
  QUDA_LEX_DIRAC_ORDER,         // lexicographical order, color inside spin
  QUDA_TIFR_PADDED_DIRAC_ORDER, // padded z dimension for TIFR RHMC code
  QUDA_INVALID_DIRAC_ORDER = QUDA_INVALID_ENUM
} QudaDiracFieldOrder;



    QudaGammaBasis gamma_basis;            /**< Gamma basis of the input and output host fields */


typedef enum QudaGammaBasis_s {
  QUDA_DEGRAND_ROSSI_GAMMA_BASIS,
  QUDA_UKQCD_GAMMA_BASIS,
  QUDA_CHIRAL_GAMMA_BASIS,
  QUDA_INVALID_GAMMA_BASIS = QUDA_INVALID_ENUM
} QudaGammaBasis;


    QudaFieldLocation clover_location;     /**< The location of the clover field */



    QudaPrecision clover_cpu_prec;         /**< The precision used for the input clover field */
    QudaPrecision clover_cuda_prec;        /**< The precision used for the clover field in the QUDA solver */
    QudaPrecision clover_cuda_prec_sloppy; /**< The precision used for the clover field in the QUDA sloppy operator */
    QudaPrecision clover_cuda_prec_refinement_sloppy; /**< The precision of the sloppy clover field for the refinement step in multishift */
    QudaPrecision clover_cuda_prec_precondition; /**< The precision used for the clover field in the QUDA preconditioner */
    QudaPrecision clover_cuda_prec_eigensolver;  /**< The precision used for the clover field in the QUDA eigensolver */

    QudaCloverFieldOrder clover_order;     /**< The order of the input clover field */

typedef enum QudaCloverFieldOrder_s {
  QUDA_FLOAT_CLOVER_ORDER = 1,  // even-odd float ordering
  QUDA_FLOAT2_CLOVER_ORDER = 2, // even-odd float2 ordering
  QUDA_FLOAT4_CLOVER_ORDER = 4, // even-odd float4 ordering
  QUDA_FLOAT8_CLOVER_ORDER = 8, // even-odd float8 ordering
  QUDA_PACKED_CLOVER_ORDER,     // even-odd, QDP packed
  QUDA_QDPJIT_CLOVER_ORDER,     // (diagonal / off-diagonal)-chirality-spacetime
  QUDA_BQCD_CLOVER_ORDER,       // even-odd, super-diagonal packed and reordered
  QUDA_INVALID_CLOVER_ORDER = QUDA_INVALID_ENUM
} QudaCloverFieldOrder;





    QudaUseInitGuess use_init_guess;       /**< Whether to use an initial guess in the solver or not */

typedef enum QudaUseInitGuess_s {
  QUDA_USE_INIT_GUESS_NO,
  QUDA_USE_INIT_GUESS_YES,
  QUDA_USE_INIT_GUESS_INVALID = QUDA_INVALID_ENUM
} QudaUseInitGuess;



    double clover_csw;                     /**< Csw coefficient of the clover term */
    double clover_coeff;                   /**< Coefficient of the clover term */
    double clover_rho;                     /**< Real number added to the clover diagonal (not to inverse) */

    int compute_clover_trlog;              /**< Whether to compute the trace log of the clover term */
    double trlogA[2];                      /**< The trace log of the clover term (even/odd computed separately) */

    int compute_clover;                    /**< Whether to compute the clover field */
    int compute_clover_inverse;            /**< Whether to compute the clover inverse field */
    int return_clover;                     /**< Whether to copy back the clover matrix field */
    int return_clover_inverse;             /**< Whether to copy back the inverted clover matrix field */

    QudaVerbosity verbosity;               /**< The verbosity setting to use in the solver */

typedef enum QudaVerbosity_s {
  QUDA_SILENT,
  QUDA_SUMMARIZE,
  QUDA_VERBOSE,
  QUDA_DEBUG_VERBOSE,
  QUDA_INVALID_VERBOSITY = QUDA_INVALID_ENUM
} QudaVerbosity;



    int iter;                              /**< The number of iterations performed by the solver */
    double gflops;                         /**< The Gflops rate of the solver */
    double secs;                           /**< The time taken by the solver */

    QudaTune tune; /**< Enable auto-tuning? (default = QUDA_TUNE_YES) */

typedef enum QudaTune_s { QUDA_TUNE_NO, QUDA_TUNE_YES, QUDA_TUNE_INVALID = QUDA_INVALID_ENUM } QudaTune;


    /** Number of steps in s-step algorithms */
    int Nsteps;

    /** Maximum size of Krylov space used by solver */
    int gcrNkrylov;

    /*
     * The following parameters are related to the solver
     * preconditioner, if enabled.
     */

    /**
     * The inner Krylov solver used in the preconditioner.  Set to
     * QUDA_INVALID_INVERTER to disable the preconditioner entirely.
     */
    QudaInverterType inv_type_precondition;

    /** Preconditioner instance, e.g., multigrid */
    void *preconditioner;

    /** Deflation instance */
    void *deflation_op;

    /** defines deflation */
    void *eig_param;

    /** If true, deflate the initial guess */
    QudaBoolean deflate;

typedef enum QudaBoolean_s {
  QUDA_BOOLEAN_FALSE = 0,
  QUDA_BOOLEAN_TRUE = 1,
  QUDA_BOOLEAN_INVALID = QUDA_INVALID_ENUM
} QudaBoolean;



    /** Dirac Dslash used in preconditioner */
    QudaDslashType dslash_type_precondition;


    /** Verbosity of the inner Krylov solver */
    QudaVerbosity verbosity_precondition;

    /** Tolerance in the inner solver */
    double tol_precondition;

    /** Maximum number of iterations allowed in the inner solver */
    int maxiter_precondition;

    /** Relaxation parameter used in GCR-DD (default = 1.0) */
    double omega;

    /** Basis for CA algorithms */
    QudaCABasis ca_basis;

typedef enum QudaCABasis_s {
  QUDA_POWER_BASIS,
  QUDA_CHEBYSHEV_BASIS,
  QUDA_INVALID_BASIS = QUDA_INVALID_ENUM
} QudaCABasis;


    /** Minimum eigenvalue for Chebyshev CA basis */
    double ca_lambda_min;

    /** Maximum eigenvalue for Chebyshev CA basis */
    double ca_lambda_max;

    /** Basis for CA algorithms in a preconditioned solver */
    QudaCABasis ca_basis_precondition;

    /** Minimum eigenvalue for Chebyshev CA basis in a preconditioner solver */
    double ca_lambda_min_precondition;

    /** Maximum eigenvalue for Chebyshev CA basis in a preconditioner solver */
    double ca_lambda_max_precondition;

    /** Number of preconditioner cycles to perform per iteration */
    int precondition_cycle;

    /** Whether to use additive or multiplicative Schwarz preconditioning */
    QudaSchwarzType schwarz_type;

typedef enum QudaSchwarzType_s {
  QUDA_ADDITIVE_SCHWARZ = 0,
  QUDA_MULTIPLICATIVE_SCHWARZ = 1,
  QUDA_INVALID_SCHWARZ = QUDA_INVALID_ENUM
} QudaSchwarzType;



    /** The type of accelerator type to use for preconditioner */
    QudaAcceleratorType accelerator_type_precondition;

typedef enum QudaAcceleratorType_s {
  QUDA_MADWF_ACCELERATOR = 0, // Use the MADWF accelerator
  QUDA_INVALID_ACCELERATOR = QUDA_INVALID_ENUM
} QudaAcceleratorType;



    /**
     * The following parameters are the ones used to perform the adaptive MADWF in MSPCG
     * See section 3.3 of [arXiv:2104.05615]
     */

    /** The diagonal constant to suppress the low modes when performing 5D transfer */
    double madwf_diagonal_suppressor;

    /** The target MADWF Ls to be used in the accelerator */
    int madwf_ls;

    /** The minimum number of iterations after which to generate the null vectors for MADWF */
    int madwf_null_miniter;

    /** The maximum tolerance after which to generate the null vectors for MADWF */
    double madwf_null_tol;

    /** The maximum number of iterations for the training iterations */
    int madwf_train_maxiter;

    /** Whether to load the MADWF parameters from the file system */
    QudaBoolean madwf_param_load;

    /** Whether to save the MADWF parameters to the file system */
    QudaBoolean madwf_param_save;

    /** Path to load from the file system */
    char madwf_param_infile[256];

    /** Path to save to the file system */
    char madwf_param_outfile[256];

    /**
     * Whether to use the L2 relative residual, Fermilab heavy-quark
     * residual, or both to determine convergence.  To require that both
     * stopping conditions are satisfied, use a bitwise OR as follows:
     *
     * p.residual_type = (QudaResidualType) (QUDA_L2_RELATIVE_RESIDUAL
     *                                     | QUDA_HEAVY_QUARK_RESIDUAL);
     */
    QudaResidualType residual_type;

typedef enum QudaResidualType_s {
  QUDA_L2_RELATIVE_RESIDUAL = 1, // L2 relative residual [default]
  QUDA_L2_ABSOLUTE_RESIDUAL = 2, // L2 absolute residual
  QUDA_HEAVY_QUARK_RESIDUAL = 4, // Fermilab heavy quark residual
  QUDA_INVALID_RESIDUAL = QUDA_INVALID_ENUM
} QudaResidualType;


    /**Parameters for deflated solvers*/
    /** The precision of the Ritz vectors */
    QudaPrecision cuda_prec_ritz;
    /** How many vectors to compute after one solve
     *  for eigCG recommended values 8 or 16
    */
    int n_ev;
    /** EeigCG  : Search space dimension
     *  gmresdr : Krylov subspace dimension
     */
    int max_search_dim;
    /** For systems with many RHS: current RHS index */
    int rhs_idx;
    /** Specifies deflation space volume: total number of eigenvectors is n_ev*deflation_grid */
    int deflation_grid;
    /** eigCG: selection criterion for the reduced eigenvector set */
    double eigenval_tol;
    /** mixed precision eigCG tuning parameter:  minimum search vector space restarts */
    int eigcg_max_restarts;
    /** initCG tuning parameter:  maximum restarts */
    int max_restart_num;
    /** initCG tuning parameter:  tolerance for cg refinement corrections in the deflation stage */
    double inc_tol;

    /** Whether to make the solution vector(s) after the solve */
    int make_resident_solution;

    /** Whether to use the resident solution vector(s) */
    int use_resident_solution;

    /** Whether to use the solution vector to augment the chronological basis */
    int chrono_make_resident;

    /** Whether the solution should replace the last entry in the chronology */
    int chrono_replace_last;

    /** Whether to use the resident chronological basis */
    int chrono_use_resident;

    /** The maximum length of the chronological history to store */
    int chrono_max_dim;

    /** The index to indicate which chrono history we are augmenting */
    int chrono_index;

    /** Precision to store the chronological basis in */
    QudaPrecision chrono_precision;

    /** Which external library to use in the linear solvers (Eigen) */
    QudaExtLibType extlib_type;

typedef enum QudaExtLibType_s {
  QUDA_CUSOLVE_EXTLIB,
  QUDA_EIGEN_EXTLIB,
  QUDA_EXTLIB_INVALID = QUDA_INVALID_ENUM
} QudaExtLibType;


    /** Whether to use the platform native or generic BLAS / LAPACK */
    QudaBoolean native_blas_lapack;

    /** Whether to use fused kernels for mobius */
    QudaBoolean use_mobius_fused_kernel;

    /**
     * Parameters for distance preconditioning algorithm proposed in arXiv:1006.4028,
     * which is useful to solve a precise heavy quark propagator.
     * alpha0 and t0 follow Eq.(9) in the article.
     */

    /** The alpha0 parameter for distance preconditioning, related to the pseudoscalar meson mass */
    double distance_pc_alpha0;
    /** The t0 parameter for distance preconditioning, the timeslice where the source is located */
    int distance_pc_t0;

  } QudaInvertParam;

