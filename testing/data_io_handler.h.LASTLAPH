#ifndef LAPH_DATA_IO_HANDLER_H
#define LAPH_DATA_IO_HANDLER_H

#include "io_map.h"
#include "filelist_info.h"
#include "xml_handler.h"
#include <set>

namespace LaphEnv {


 // *********************************************************************************
 // *                                                                               *
 // *   The classes defined in this file that are important are                     *
 // *                                                                               *
 // *         DataPutHandlerMF   (multi-file)                                       *
 // *         DataGetHandlerMF   (multi-file)                                       *
 // *         DataPutHandlerSF   (single file)                                      *
 // *         DataGetHandlerSF   (single file)                                      *
 // *                                                                               *
 // *                                                                               *
 // *   The "DataPutHandlerMF" and "DataGetHandlerMF" (multi-file) classes handle   *
 // *   inserting data into IOMap records in files specified in a FileListInfo and  *
 // *   subsequently reading the data.  The file key determines which file to       *
 // *   access, and the record key determines which IOMap record in a given file    *
 // *   to access.  This version does NOT store results in memory.  Do not use      *
 // *   the "put" and "get" classes simultaneously;  use "put" to build up the data *
 // *   in the files, then destroy the insert object; after this, a "get" object    *
 // *   can be created to access the  data in the files.                            *
 // *                                                                               *
 // *   Objects of these "put" handlers always assume an "updating" mode. Existing  *
 // *   files are never erased, and new files are created as needed.  New records   *
 // *   are added to the files.  If the key of a record to be put already exists    *
 // *   in a file, the put will only occur if "overwrite" is specified AND the      *
 // *   size of the data to be put does not exceed the size of the data already in  *
 // *   the file for that key.  For the multi-file handler, the "overwrite" bool    *
 // *   must be given in the FileListInfo; for the single-file handler, the         *
 // *   constructor takes an explicit bool parameter.                               *
 // *                                                                               *
 // *   To use these classes, one needs the following ingredients:                  *
 // *                                                                               *
 // *    (a) a FileListInfo object and an IOHandler file ID string                  *
 // *                                                                               *
 // *    (b) a handler class "H" that has members                                   *
 // *                                                                               *
 // *            bool checkHeader(XMLHandler& xmlr, int suffix)       MF            *
 // *            bool checkHeader(XMLHandler& xmlr)                   SF            *
 // *                                                                               *
 // *          that checks that the header information in the file is good,         *
 // *          returning a boolean value, and                                       *
 // *                                                                               *
 // *            void writeHeader(XMLHandler&,const F&,int)           MF            *
 // *            void writeHeader(XMLHandler&)                        SF            *
 // *                                                                               *
 // *        where "F" is the file key type, that writes out the header string      *
 // *        for each file                                                          *
 // *                                                                               *
 // *    (c) both classes need to extract the file key from the header string, so   *
 // *          the file key type must have a constructor that takes only an         *
 // *          XMLHandler and an output(XMLHandler&) member; you need to specify the*
 // *          header tag that the file key will be enclosed in; the file key must  *
 // *          also have a "<" operator and an "==" operator defined                *
 // *                                                                               *
 // *    (d) the record key class must have all of the features of an IOMap key:    *
 // *                                                                               *
 // *       -- since used in a C++ map, a less than operator must be define         *
 // *              const K& K::operator<(const K& rhs);                             *
 // *       -- a numbytes(ioh,K) function, where ioh is an IOHandler, must be       *
 // *           defined to give the number of bytes each key occupies in an         *
 // *           IOHandler file                                                      *
 // *       -- a copy constructor K(const K& in) must be defined                    *
 // *           (a default constructor is not needed)                               *
 // *       -- a multi_read(ioh, vector<K>&,n) must be defined to read n keys       *
 // *       -- a multi_write(ioh, const vector<K>&) must be defined                 *
 // *                                                                               *
 // *    (e) the value type must have the following features:                       *
 // *                                                                               *
 // *       -- a write(ioh, const V&) must be defined (ioh is an IOHandler object)  *
 // *       -- a read(ioh, V&) must be defined                                      *
 // *       -- a numbytes(ioh,V) must be defined giving number of bytes occupied    *
 // *            by V in an IOHandler file                                          *
 // *                                                                               *
 // *                                                                               *
 // *   Usage:  (inserting)                                                         *
 // *                                                                               *
 // *     FileListInfo files;     // specify overwrite mode in here                 *
 // *     string fid("id string");                                                  *
 // *     string HeaderTag("HeaderTag");                                            *
 // *     SomeHandler H;  //  R=record type, F=file type, D=data type               *
 // *                                                                               *
 // *     DataPutHandlerMF<SomeHandler,F,R,D>                                       *
 // *               DIH(H,files,fid,HeaderTag);                                     *
 // *                                                                               *
 // *        // best to insert data having same file key                            *
 // *        // in sequence to minimize file open/close                             *
 // *                                                                               *
 // *     F fkey; R rkey; D data;                                                   *
 // *     DIH.openFile(fkey);                                                       *
 // *     DIH.putData(rkey,data);                                                   *
 // *     R rkey2; D data2;                                                         *
 // *     DIH.putData(rkey2,data2);                                                 *
 // *     R rkey3; D data3;                                                         *
 // *     DIH.queryData(fkey,rkey3); // check if exists                             *
 // *                                                                               *
 // *        // other members                                                       *
 // *                                                                               *
 // *     DIH.getFileListInfo();                                                    *
 // *     DIH.setOverWrite();                                                       *
 // *     DIH.setNoOverWrite();                                                     *
 // *     DIH.close();    // manual close current file                              *
 // *                                                                               *
 // *                                                                               *
 // *   Usage:  (reading)                                                           *
 // *                                                                               *
 // *     FileListInfo files;                                                       *
 // *     string fid("id string");                                                  *
 // *     string HeaderTag("HeaderTag");                                            *
 // *     SomeHandler H;  //  R=record type, F=file type, D=data type               *
 // *                                                                               *
 // *     DataGetHandlerMF<SomeHandler,F,R,D>                                       *
 // *               DRH(H,files,fid,HeaderTag);                                     *
 // *                                                                               *
 // *     F fkey; R rkey; D data;                                                   *
 // *     bool flag=DRH.getData(fkey,rkey,data);                                    *
 // *     bool flag1=DRH.queryData(fkey,rkey);                                      *
 // *     bool flag2=DRH.queryData(fkey);                                           *
 // *                                                                               *
 // *        // other members                                                       *
 // *                                                                               *
 // *     DRH.getFileListInfo();                                                    *
 // *     XMLHandler xmlout;                                                        *
 // *     DRH.getFileMap(xmlout);                                                   *
 // *     list<pair<F,list<R> > > keys=DRH.getKeys();                               *
 // *     DRH.outputKeys(xmlout);                                                   *
 // *                                                                               *
 // *                                                                               *
 // *   The "DataPutHandlerSF" and "DataGetHandlerSF" classes are similar to their  *
 // *   "MF" (multi-file) counterpart but only one single file (SF) is handled.     *
 // *                                                                               *
 // *                                                                               *
 // *             KEY KEEPER VERSION of DataGetHandlerSF                            *
 // *                                                                               *
 // *  This version of DataGetHandlerSF requires that the Handler of type H         *
 // *  has some addition member functions:                                          *
 // *                                                                               *
 // *        H.keep(const K&)   -->  bool function to keep only certain  keys       *
 // *                                                                               *
 // *  Only the keys for which the "keep" member returns true will be maintained    *
 // *  in the file map.  In other words, "getData" will only work for those keys    *
 // *  specified by the boolean function.  The boolean function must take a         *
 // *  single argument, a key, and return true if the key is to be kept, and        *
 // *  false otherwise.  This is an important feature if the file contains a lot    *
 // *  of keys, but you only need access to a handful of them.  This reduces the    *
 // *  memory footprint of the IOMap objects, which might be important if several   *
 // *  files are involved.                                                          *
 // *                                                                               *
 // *                                                                               *
 // *********************************************************************************
 
 
   // **************************************************************
   // *                                                            *
   // *                      DataGetHandlerMF                      *
   // *                                                            *
   // **************************************************************


   // "fileMap" is a map associating a file key to a FileMapValue, 
   // which contains a suffix and an IOMap pointer.  Upon construction, 
   // "fileMap" is assigned by opening each file one by one, reading the 
   // header string, and extracting the file key.  None of the files is
   // left open.  As data is accessed, the files are opened and left
   // open.  While a file is open, the IOMap keeps all of the record
   // keys in memory.
   
   // "queryData" and "getData" open files as needed, and leave them open.


template <typename H, typename F, typename R, typename D>
class DataGetHandlerMF
{

    struct FileMapValue
    {
      int suffix;
      IOMap<R,D> *fptr;
      FileMapValue(int in_suff) : suffix(in_suff), fptr(0) {}
      ~FileMapValue() {delete fptr;}
    };

    typedef std::map<F,FileMapValue>  FileMapType;
 
    FileListInfo finfo;
    FileMapType  fileMap;
    H& handler;
    bool checksums;
    std::string fid;


 public:

    DataGetHandlerMF(H& in_handler, const FileListInfo& in_filelist,
                     const std::string& filetype_id, 
                     const std::string& header_tag, 
                     bool use_checksums=false);

    ~DataGetHandlerMF() {clear();}

    const FileListInfo& getFileListInfo() const {return finfo;}

    bool queryData(const F& fkey, const R& rkey);

    bool queryFile(const F& fkey);


    bool getData(const F& fkey, const R& rkey, D& data);

    void clear();

    void close(const F& fkey);

    void getFileMap(XMLHandler& xmlout) const;

    std::map<int,F> getSuffixMap() const;

    std::set<F> getFileKeys() const;

    std::set<R> getKeys(const F& fkey);

    void outputKeys(XMLHandler& xmlout);


 private:

    void fail(const F& fkey, const R& rkey);
    
    void fail(const F& fkey);

    void fail(const std::string& msg);
    
    IOMap<R,D>* get_file_ptr(const F& fkey);
    
    void open(FileMapValue& fmv);
    
    void close(FileMapValue& fmv);

          // disallow copies
    DataGetHandlerMF(const DataGetHandlerMF& in);
    DataGetHandlerMF& operator=(const DataGetHandlerMF& in);

};



   // Constructor checks that the information in the headers
   // of all existing files is consistent, then sets up the
   // file map.  Each files is opened (one by one), the header string
   // is read, and then the file is closed.

template <typename H, typename F, typename R, typename D>
DataGetHandlerMF<H,F,R,D>::DataGetHandlerMF(H& in_handler,
                                            const FileListInfo& in_filelist,
                                            const std::string& filetype_id,
                                            const std::string& header_tag,
                                            bool use_checksums)
  :  finfo(in_filelist), handler(in_handler),
     checksums(use_checksums), fid(tidyString(filetype_id))
{
 for (int suffix=finfo.getMinFileNumber();
          suffix<=finfo.getMaxFileNumber();suffix++){

    std::string filename=finfo.getFileName(suffix);

         // open all existing files and check consistency of headers
    std::string headerxml;
    bool exists;
    {IOMap<R,D> iom;
     exists=iom.peekHeader(headerxml,filename,fid);}
    if (!exists) continue;

    XMLHandler xmlr; xmlr.set_from_string(headerxml);
    if (!handler.checkHeader(xmlr,suffix)){
       fail("Header string in file is\n"+headerxml+"header info in file "
                  +filename+" does not match info in current Handler\n\n"
                  +"...execution aborted...\n");}

            // extract the file key from this file
    try{
       XMLHandler xmlf(xmlr,header_tag);
       F fkey(xmlf);
       typename FileMapType::iterator it=fileMap.find(fkey);
       if (it!=fileMap.end()){
          fail(std::string("duplicate keys in fileMap in current Handler\n")
               +" ... too confusing to continue\n file suffix "
               +make_string(suffix)+" and suffix "+make_string((it->second).suffix)
               +" have same file key\n");}
       fileMap.insert(std::make_pair(fkey, FileMapValue(suffix)));}
    catch(const std::exception& xp){
       fail("Could not extract FileKey from file "+filename+"\n");}
    }
}


template <typename H, typename F, typename R, typename D>
IOMap<R,D>* DataGetHandlerMF<H,F,R,D>::get_file_ptr(const F& fkey)
{
 typename FileMapType::iterator it=fileMap.find(fkey);
 if (it==fileMap.end()) return 0;
 if (it->second.fptr==0) open(it->second);
 return it->second.fptr;
}


template <typename H, typename F, typename R, typename D>
void DataGetHandlerMF<H,F,R,D>::open(FileMapValue& fmv)
{
 std::string filename=finfo.getFileName(fmv.suffix);
 try {
    fmv.fptr=new IOMap<R,D>;
    fmv.fptr->openReadOnly(filename,fid,checksums);}
 catch(const std::exception& xp){
    fail("failure opening file "+filename+" in DataGetHandlerMF");}
}


template <typename H, typename F, typename R, typename D>
void DataGetHandlerMF<H,F,R,D>::close(FileMapValue& fmv)
{
 delete fmv.fptr; 
 fmv.fptr=0;
}


template <typename H, typename F, typename R, typename D>
bool DataGetHandlerMF<H,F,R,D>::getData(const F& fkey, const R& rkey, D& result)
{
 IOMap<R,D> *fptr=get_file_ptr(fkey);
 if (fptr==0) return false;
 try {fptr->get(rkey,result);}
 catch(const std::exception& xp){return false;}
 return true;
}

template <typename H, typename F, typename R, typename D>
void DataGetHandlerMF<H,F,R,D>::close(const F& fkey)
{
 typename FileMapType::iterator it=fileMap.find(fkey);
 if (it==fileMap.end()) return;
 delete it->second.fptr;
 it->second.fptr=0;
}


template <typename H, typename F, typename R, typename D>
void DataGetHandlerMF<H,F,R,D>::fail(const F& fkey, const R& rkey)
{
 std::cout << "DataGetHandlerMF could not find requested record:"<<std::endl;
 std::cout << " File stub: "<< finfo.getFileStub()<<std::endl;
 XMLHandler xmlout;
 xmlout.set_root("FileRecordKey");
 XMLHandler xmlh;
 fkey.output(xmlh);
 xmlout.put_child(xmlh);
 rkey.output(xmlh);
 xmlout.put_child(xmlh);
 std::cout << xmlout.str()<<std::endl;
 std::cout << "...execution aborted..."<<std::endl;
 clear();
 exit(1);
}


template <typename H, typename F, typename R, typename D>
void DataGetHandlerMF<H,F,R,D>::fail(const F& fkey)
{
 std::cout << "DataGetHandlerMF could not find requested file key:"<<std::endl;
 std::cout << " File stub: "<< finfo.getFileStub()<<std::endl;
 XMLHandler xmlout;
 fkey.output(xmlout);
 std::cout << xmlout.str()<<std::endl;
 std::cout << "...execution aborted..."<<std::endl;
 clear();
 exit(1);
}


template <typename H, typename F, typename R, typename D>
void DataGetHandlerMF<H,F,R,D>::fail(const std::string& msg)
{
 std::cout << "DataGetHandlerMF error: "<<msg<<std::endl;
 exit(1);
 clear();
}


template <typename H, typename F, typename R, typename D>
bool DataGetHandlerMF<H,F,R,D>::queryData(const F& fkey, const R& rkey)
{
 IOMap<R,D> *fptr=get_file_ptr(fkey);
 if (fptr==0) return false;
 return fptr->exist(rkey);
}


template <typename H, typename F, typename R, typename D>
bool DataGetHandlerMF<H,F,R,D>::queryFile(const F& fkey)
{
 typename FileMapType::iterator it=fileMap.find(fkey);
 return (it!=fileMap.end());
}


template <typename H, typename F, typename R, typename D>
void DataGetHandlerMF<H,F,R,D>::clear()
{
 for (typename FileMapType::iterator 
      it=fileMap.begin();it!=fileMap.end();it++) close(it->second);
 fileMap.clear();
}


template <typename H, typename F, typename R, typename D>
void DataGetHandlerMF<H,F,R,D>::getFileMap(XMLHandler& xmlout) const
{
 xmlout.set_root("FileMap");
 for (typename FileMapType::const_iterator it=fileMap.begin();
      it!=fileMap.end();it++){
    XMLHandler xmlt("Entry");
    XMLHandler xmlp;
    it->first.output(xmlp); xmlt.put_child(xmlp);
    xmlt.put_child("Suffix",make_string((it->second).suffix));
    xmlout.put_child(xmlt);}
}

template <typename H, typename F, typename R, typename D>
std::map<int,F> DataGetHandlerMF<H,F,R,D>::getSuffixMap() const
{
 std::map<int,F> filekeys;
 for (typename FileMapType::const_iterator it=fileMap.begin();
      it!=fileMap.end();it++)
    filekeys.insert(std::make_pair((it->second).suffix,it->first));
 return filekeys;
} 


template <typename H, typename F, typename R, typename D>
std::set<F> DataGetHandlerMF<H,F,R,D>::getFileKeys() const
{
 std::set<F> filekeys;
 for (typename FileMapType::const_iterator it=fileMap.begin();
      it!=fileMap.end();it++)
    filekeys.insert(it->first);
 return filekeys;
} 


template <typename H, typename F, typename R, typename D>
std::set<R> DataGetHandlerMF<H,F,R,D>::getKeys(const F& fkey)
{
 std::set<R> keys;
 IOMap<R,D>* fptr=get_file_ptr(fkey);
 if (fptr!=0) fptr->getKeys(keys);
 return keys;
}
 


template <typename H, typename F, typename R, typename D>
void DataGetHandlerMF<H,F,R,D>::outputKeys(XMLHandler& xmlout)
{
 xmlout.set_root("AvailableKeys");
 for (typename FileMapType::iterator it=fileMap.begin();
      it!=fileMap.end();it++){
    std::set<R> keys;
    if (it->second.fptr!=0) 
       it->second.fptr->getKeys(keys);
    else{
       open(it->second);
       it->second.fptr->getKeys(keys);
       close(it->second);} 
    for (typename std::set<R>::const_iterator 
            kt=keys.begin();kt!=keys.end();kt++){
       XMLHandler xmli,xmlk;
       it->first.output(xmli);
       kt->output(xmlk);
       XMLHandler xmlt("Key");
       xmlt.put_child(xmli);
       xmlt.put_child(xmlk);
       xmlout.put_child(xmlt);}}
}




   // **************************************************************
   // *                                                            *
   // *                      DataPutHandlerMF                      *
   // *                                                            *
   // **************************************************************

   // "fileMap" is a map associating a file key to a FileMapValue, 
   // which contains a suffix and an IOMap pointer.  Upon construction, 
   // "fileMap" is assigned by opening each file one by one, reading the 
   // header string, and extracting the file key.  None of the files is
   // left open.  "current" is an iterator that keeps track of the
   // current file available for data insertion.
   
   // To insert data, you must first call "open" with a file key.  If the
   // file key refers to a file that is already open, then all that happens
   // is that the current file pointer is changed. If this file is not opened,
   // then it is opened for writing.  If no file is associated with the
   // file key, then a new file is created and opened.   After the "open"
   // command, you then use "putData" to insert records into that one file.
   // Subsequently calling "open" with another file key changes the current
   // file pointer.  The previous file is left open.
   
   // "queryData" and "queryFile" opens the files, and they are left open.
   
   // "flush" and "flushAll" can be used to flush the data in one or all 
   // files.  Flushing means writing out the current IOMap record map to
   // file.  If a program crashing, an IOMap that has not been flushed is
   // corrupted.  If flushed, it will be okay for subsequent programs.
   // Note that flushing does not close the file.  Use "close" or "closeAll"
   // to actually close files.  Keep in mind that while a file is open,
   // its IOMap must maintain the map of record keys in memory.


template <typename H, typename F, typename R, typename D>
class DataPutHandlerMF
{

    struct FileMapValue
    {
      int suffix;
      IOMap<R,D> *fptr;
      FileMapValue(int in_suff) : suffix(in_suff), fptr(0) {}
      ~FileMapValue() {delete fptr;}
    };

    typedef std::map<F,FileMapValue>  FileMapType;


    FileListInfo finfo;
    FileMapType fileMap;
    H& handler;
    bool checksums;
    std::string fid;
    typename FileMapType::iterator current;


 public:

    DataPutHandlerMF(H& in_handler, const FileListInfo& in_filelist,
                     const std::string& filetype_id,  
                     const std::string& header_tag, 
                     bool use_checksums=false);

    ~DataPutHandlerMF() {fileMap.clear();}

    void setOverWrite() {finfo.setOverWrite();}

    void setNoOverWrite() {finfo.setNoOverWrite();}

    const FileListInfo& getFileListInfo() const {return finfo;}
    
    std::string getCurrentFileName() const;


    void open(const F& fkey);

    void putData(const R& rkey, const D& data);  // insert into current file

    void flush();   // flush current file

    void close();   // close current file

             // calls openFile(fkey) first, then inserts
             
    void putData(const F& fkey, const R& rkey, const D& data);

    void flush(const F& fkey);

    void close(const F& fkey);
    
    void flushAll();

    void closeAll();



    bool queryData(const F& fkey, const R& rkey);

    bool queryData(const R& rkey);  // query in current open file

    bool queryFile(const F& fkey);



    void merge(const FileListInfo& infiles,        // adds data from the "infiles"
               const std::string& header_tag);     // into this file list
                                                   // use in serial code ONLY
                                              
    void merge(const std::vector<FileListInfo>& infiles,  
               const std::string& header_tag);     

    void merge(const std::vector<FileListInfo>& infiles,  
               const std::string& header_tag,
               const std::set<F>& keep_keys);   // only keys in "keep_keys" are merged

    void getFileMap(XMLHandler& xmlout) const;

    std::map<int,F> getSuffixMap() const;

    std::set<F> getFileKeys() const;


 private:


    void fail(const std::string& msg);
    
    void fail(const F& fkey, const R& rkey);

    typename FileMapType::iterator get_file_ptr(const F& fkey);
    
    void openUpdate(FileMapValue& fmv);
    
    void openNew(const F& fkey, FileMapValue& fmv);

    void close(typename FileMapType::iterator it);

    void flush(typename FileMapType::iterator it);


          // disallow copies
    DataPutHandlerMF(const DataPutHandlerMF& in);
    DataPutHandlerMF& operator=(const DataPutHandlerMF& in);

};



   // constructor checks that the information in the headers
   // of all existing files is consistent, then sets up the
   // file map

template <typename H, typename F, typename R, typename D>
DataPutHandlerMF<H,F,R,D>::DataPutHandlerMF(H& in_handler,
                                            const FileListInfo& in_filelist,
                                            const std::string& filetype_id,
                                            const std::string& header_tag,
                                            bool use_checksums)
  :  finfo(in_filelist), handler(in_handler), checksums(use_checksums),
     fid(tidyString(filetype_id)), current(fileMap.end())
{
 for (int suffix=finfo.getMinFileNumber();
          suffix<=finfo.getMaxFileNumber();suffix++){

    std::string filename=finfo.getFileName(suffix);

         // open all existing files and check consistency of headers
    std::string headerxml;
    bool exists;
    {IOMap<R,D> iom;
     exists=iom.peekHeader(headerxml,filename,fid);}
    if (!exists) continue;

    XMLHandler xmlr; xmlr.set_from_string(headerxml);
    if (!handler.checkHeader(xmlr,suffix)){
       fail("Header string in file is\n"+headerxml+"header info in file "
                  +filename+" does not match info in current Handler\n\n"
                  +"...execution aborted...\n");}

            // extract the file key from this file
    try{
       XMLHandler xmlf(xmlr,header_tag);
       F fkey(xmlf);
       typename FileMapType::iterator it=fileMap.find(fkey);
       if (it!=fileMap.end()){
          fail(std::string("duplicate keys in fileMap in current Handler\n")
               +" ... too confusing to continue\n file suffix "
               +make_string(suffix)+" and suffix "+make_string((it->second).suffix)
               +" have same file key\n");}
       fileMap.insert(std::make_pair(fkey, FileMapValue(suffix)));}
    catch(const std::exception& xp){
       fail("Could not extract FileKey from file "+filename+"\n");}
    }
}


     //  Get file pointer corresponding to fkey.  If "fkey" is already in the
     //  fileMap, then check if the file is open (fptr assigned).  If not open,
     //  open the file.  If already open, we are done.  If "fkey" is not in the
     //  fileMap, then we find a new suffix and open a new file.

template <typename H, typename F, typename R, typename D>
typename DataPutHandlerMF<H,F,R,D>::FileMapType::iterator 
        DataPutHandlerMF<H,F,R,D>::get_file_ptr(const F& fkey)
{
 typename FileMapType::iterator it=fileMap.find(fkey);
 if (it!=fileMap.end()){
    if (it->second.fptr==0) openUpdate(it->second);}
 else{
    int findex=0;
    try{ findex=finfo.getFirstAvailableSuffix();}
    catch(const std::exception& xp){
       fail(std::string("could not create file...no more suffix indices")
                  +" available...execution aborted...\n");}
    std::pair< typename FileMapType::iterator, bool > pr;
    pr=fileMap.insert(std::make_pair(fkey,FileMapValue(findex)));
    if (pr.second==true) it=pr.first;
    else{ fail("DataPutHandlerMF insertion failed on index "+make_string(findex));}
    openNew(fkey,it->second);}
 return it;
}


template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::openUpdate(FileMapValue& fmv)
{
 std::string filename=finfo.getFileName(fmv.suffix);
 try {
    fmv.fptr=new IOMap<R,D>;
    std::string header;
    fmv.fptr->openUpdate(filename,fid,header,'L',checksums,finfo.isModeOverwrite());}
 catch(const std::exception& xp){
    fail("failure opening file "+filename+" in DataPutHandlerMF");}
}


template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::openNew(const F& fkey, FileMapValue& fmv)
{
 std::string filename=finfo.getFileName(fmv.suffix);
 if (fileExists(filename)){
    fail(std::string("file collision: another process has created a file")
         +" during execution of this program..best to abort\n");}
 try {
    fmv.fptr=new IOMap<R,D>;
    XMLHandler headerxml;
    handler.writeHeader(headerxml,fkey,fmv.suffix);  // write header info 
    fmv.fptr->openNew(filename,fid,headerxml.str(),false,'L',checksums,
                      finfo.isModeOverwrite());}
 catch(const std::exception& xp){
    fail("failure opening file "+filename+" in DataPutHandlerMF");}
}


template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::close(typename FileMapType::iterator it)
{
 if (it==fileMap.end()) return;
 delete it->second.fptr; 
 it->second.fptr=0;
}


template <typename H, typename F, typename R, typename D>
std::string DataPutHandlerMF<H,F,R,D>::getCurrentFileName() const
{
 if (current==fileMap.end()) return std::string("No file currently open");
 return finfo.getFileName(current->second.suffix);

}


template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::flush(typename FileMapType::iterator it)
{
 if (it==fileMap.end()) return;
 if (it->second.fptr!=0) it->second.fptr->flush();
}


template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::fail(const std::string& msg)
{
 std::cout << "DataPutHandlerMF error: "<<msg<<std::endl;
 fileMap.clear();
 exit(1);
}

template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::fail(const F& fkey, const R& rkey)
{
 std::cout << "DataPutHandlerMF could not insert requested record:"<<std::endl;
 std::cout << " File stub: "<< finfo.getFileStub()<<std::endl;
 XMLHandler xmlout;
 xmlout.set_root("FileRecordKey");
 XMLHandler xmlh;
 fkey.output(xmlh);
 xmlout.put_child(xmlh);
 rkey.output(xmlh);
 xmlout.put_child(xmlh);
 std::cout << xmlout.str()<<std::endl;
 std::cout << "...execution aborted..."<<std::endl;
 fileMap.clear();
 exit(1);
}


    // opens file, resets the current file pointer

template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::open(const F& fkey)
{
 current=get_file_ptr(fkey);
}


template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::putData(const R& rkey, const D& data)
{
 if (current==fileMap.end()) { fail("No current file; cannot insert Data");}
 if (current->second.fptr==0) openUpdate(current->second);
 try{current->second.fptr->put(rkey,data);}
 catch(const std::exception& xp){
    fail(current->first,rkey);}
}


template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::flush()
{
 flush(current);
}

template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::close()
{
 close(current);
}


template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::flushAll()
{
 for (typename FileMapType::iterator it=fileMap.begin();it!=fileMap.end();it++)
    flush(it);
}


template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::closeAll()
{
 for (typename FileMapType::iterator it=fileMap.begin();it!=fileMap.end();it++)
    close(it);
}


template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::putData(
                 const F& fkey, const R& rkey, const D& data)
{
 open(fkey);
 try{ current->second.fptr->put(rkey,data);}
 catch(const std::exception& xp){
    fail(fkey,rkey);}
}


template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::flush(const F& fkey)
{
 typename FileMapType::iterator it=fileMap.find(fkey);
 flush(it);
}


template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::close(const F& fkey)
{
 typename FileMapType::iterator it=fileMap.find(fkey);
 close(it);
}


template <typename H, typename F, typename R, typename D>
bool DataPutHandlerMF<H,F,R,D>::queryData(
                 const F& fkey, const R& rkey)
{
 typename FileMapType::iterator it=fileMap.find(fkey);
 if (it==fileMap.end()) return false;
 if (it->second.fptr==0) openUpdate(it->second);
 return (it->second.fptr)->exist(rkey);
}


template <typename H, typename F, typename R, typename D>
bool DataPutHandlerMF<H,F,R,D>::queryData(const R& rkey)
{
 if (current==fileMap.end()) { fail("No current file; cannot query Data");}
 if (current->second.fptr==0) openUpdate(current->second);
 return current->second.fptr->exist(rkey);
}


template <typename H, typename F, typename R, typename D>
bool DataPutHandlerMF<H,F,R,D>::queryFile(const F& fkey)
{
 typename FileMapType::iterator it=fileMap.find(fkey);
 return (it!=fileMap.end());
}



template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::getFileMap(XMLHandler& xmlout) const
{
 xmlout.set_root("FileMap");
 for (typename FileMapType::const_iterator it=fileMap.begin();
      it!=fileMap.end();it++){
    XMLHandler xmlt("Entry");
    XMLHandler xmlp;
    it->first.output(xmlp); xmlt.put_child(xmlp);
    xmlt.put_child("Suffix",make_string((it->second).suffix));
    xmlout.put_child(xmlt);}
} 

template <typename H, typename F, typename R, typename D>
std::map<int,F> DataPutHandlerMF<H,F,R,D>::getSuffixMap() const
{
 std::map<int,F> filekeys;
 for (typename FileMapType::const_iterator it=fileMap.begin();
      it!=fileMap.end();it++)
    filekeys.insert(std::make_pair((it->second).suffix,it->first));
 return filekeys;
} 


template <typename H, typename F, typename R, typename D>
std::set<F> DataPutHandlerMF<H,F,R,D>::getFileKeys() const
{
 std::set<F> filekeys;
 for (typename FileMapType::const_iterator it=fileMap.begin();
      it!=fileMap.end();it++)
    filekeys.insert(it->first);
 return filekeys;
} 



template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::merge(const FileListInfo& infiles,
                                      const std::string& header_tag)
{
 DataGetHandlerMF<H,F,R,D> inmerge(handler,infiles,fid,header_tag);
 std::set<F> fkeys=inmerge.getFileKeys();
 std::cout << "  number of file keys = "<<fkeys.size()<<std::endl;
 for (typename std::set<F>::const_iterator ft=fkeys.begin();ft!=fkeys.end();ft++){
    open(*ft);
    std::set<R> rkeys=inmerge.getKeys(*ft);
    std::cout << "  file suffix "<<current->second.suffix
                <<": number of records to be added = "<<rkeys.size()<<std::endl;
    for (typename std::set<R>::const_iterator rt=rkeys.begin();rt!=rkeys.end();rt++){
       D data;
       bool flag=inmerge.getData(*ft,*rt,data);
       if (flag) putData(*rt,data);}
//    close(*ft);
    }
} 


   //  The merge subroutine above causes lustre lock up on ranger when several
   //  jobs are running simultaneously.  Hence, it has been revised below in such
   //  a way to slow down directory searches.

template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::merge(const std::vector<FileListInfo>& infiles,
                                      const std::string& header_tag)
{
 for (unsigned int k=0;k<infiles.size();k++){
    std::cout << "merging file list k = "<<k<<std::endl;
    std::string instub=infiles[k].getFileStub();
    int nfkeys=0;
    for (int suffix=infiles[k].getMinFileNumber();suffix<=infiles[k].getMaxFileNumber();suffix++){
       FileListInfo inf(instub,suffix,suffix);
       DataGetHandlerMF<H,F,R,D> inmerge(handler,inf,fid,header_tag);
       std::set<F> fkeys=inmerge.getFileKeys();
       nfkeys+=fkeys.size();
       for (typename std::set<F>::const_iterator ft=fkeys.begin();ft!=fkeys.end();ft++){
          open(*ft);
          std::set<R> rkeys=inmerge.getKeys(*ft);
          std::cout << " file list "<<k<<":  from suffix "<<suffix
                      << " into merged suffix "<<current->second.suffix
                      <<": number of records added = "<<rkeys.size()<<std::endl;
          for (typename std::set<R>::const_iterator rt=rkeys.begin();rt!=rkeys.end();rt++){
             D data;
             bool flag=inmerge.getData(*ft,*rt,data);
             if (flag) putData(*rt,data);}
//        close(*ft);
          }}
    std::cout << "  number of file keys merged in list "<<k<<" was "<<nfkeys<<std::endl; 
    }
}

    // only the keys in "keep_keys" are merged

template <typename H, typename F, typename R, typename D>
void DataPutHandlerMF<H,F,R,D>::merge(const std::vector<FileListInfo>& infiles,
                                      const std::string& header_tag,
                                      const std::set<F>& keep_keys)
{
 for (unsigned int k=0;k<infiles.size();k++){
    std::cout << "merging file list k = "<<k<<std::endl;
    std::string instub=infiles[k].getFileStub();
    int nfkeys=0;
    for (int suffix=infiles[k].getMinFileNumber();suffix<=infiles[k].getMaxFileNumber();suffix++){
       FileListInfo inf(instub,suffix,suffix);
       DataGetHandlerMF<H,F,R,D> inmerge(handler,inf,fid,header_tag);
       std::set<F> fkeys=inmerge.getFileKeys();
       for (typename std::set<F>::const_iterator ft=fkeys.begin();ft!=fkeys.end();ft++)
          if (keep_keys.find(*ft)!=keep_keys.end()){
             ++nfkeys;
             open(*ft);
             std::set<R> rkeys=inmerge.getKeys(*ft);
             std::cout << " file list "<<k<<":  from suffix "<<suffix
                         << " into merged suffix "<<current->second.suffix
                         <<": number of records added = "<<rkeys.size()<<std::endl;
             for (typename std::set<R>::const_iterator rt=rkeys.begin();rt!=rkeys.end();rt++){
                D data;
                bool flag=inmerge.getData(*ft,*rt,data);
                if (flag) putData(*rt,data);}
          }}
    std::cout << "  number of file keys merged in list "<<k<<" was "<<nfkeys<<std::endl; 
    }
}


   // **************************************************************
   // *                                                            *
   // *                      DataGetHandlerSF                      *
   // *                                                            *
   // **************************************************************


template <typename H, typename R, typename D>
class DataGetHandlerSF
{

    IOMap<R,D> *iomptr;
    H& handler;
    
 public:

    DataGetHandlerSF(H& in_handler, const std::string& file_name, 
                     const std::string& filetype_id,
                     bool use_checksums=false);

    ~DataGetHandlerSF() {delete iomptr;}

    std::string getFileName() const {return iomptr->getFileName();}


    bool queryData(const R& rkey);

    bool getData(const R& rkey, D& data);


    std::set<R> getKeys();

    void outputKeys(XMLHandler& xmlout);
    
    unsigned int size() const {return iomptr->size();}



 private:

    void fail(const R& rkey);

    void fail(const std::string& msg);

          // disallow copies
    DataGetHandlerSF(const DataGetHandlerSF& in);
    DataGetHandlerSF& operator=(const DataGetHandlerSF& in);

};



   // constructor checks that the information in the header
   // is consistent

template <typename H, typename R, typename D>
DataGetHandlerSF<H,R,D>::DataGetHandlerSF(H& in_handler, const std::string& filename,
                                          const std::string& filetype_id, 
                                          bool use_checksums)
                       :  handler(in_handler)
{
 std::string headerxml; 
 {IOMap<R,D> iom;
 bool exists=iom.peekHeader(headerxml,filename,filetype_id);
 if (!exists) throw(std::invalid_argument(std::string("could not open file ")+filename
                  +std::string(" for reading")));}

 XMLHandler xmlr; xmlr.set_from_string(headerxml);
 if (!handler.checkHeader(xmlr)){
    throw(std::invalid_argument(std::string("Header string in file is \n")+headerxml
         +std::string("\n header info in file ")+filename
         +std::string(" does not match info in current Handler\n ...execution aborted...\n")));}
 try{
    iomptr=new IOMap<R,D>; 
    iomptr->openReadOnly(filename,filetype_id,headerxml,handler,use_checksums);}
 catch(const std::exception& xp) {
    fail("could not open file "+filename+" for reading");}
}


template <typename H, typename R, typename D>
bool DataGetHandlerSF<H,R,D>::getData(const R& rkey, D& data)
{
 try {iomptr->get(rkey,data);}
 catch(const std::exception& xp){return false;}
 return true;
}


template <typename H, typename R, typename D>
bool DataGetHandlerSF<H,R,D>::queryData(const R& rkey)
{
 return iomptr->exist(rkey);
}


template <typename H, typename R, typename D>
std::set<R> DataGetHandlerSF<H,R,D>::getKeys()
{
 std::set<R> keys;
 iomptr->getKeys(keys);
 return keys;
} 


template <typename H, typename R, typename D>
void DataGetHandlerSF<H,R,D>::outputKeys(XMLHandler& xmlout)
{
 xmlout.set_root("AvailableKeys");
 std::set<R> keys;
 iomptr->getKeys(keys);
 for (typename std::set<R>::const_iterator 
            kt=keys.begin();kt!=keys.end();kt++){
    XMLHandler xmlk;
    kt->output(xmlk);
    XMLHandler xmlt("Key");
    xmlt.put_child(xmlk);
    xmlout.put_child(xmlt);}
}



template <typename H, typename R, typename D>
void DataGetHandlerSF<H,R,D>::fail(const R& rkey)
{
 std::cout << "DataGetHandlerSF could not find requested record:"<<std::endl;
 std::cout << " File name: "<< iomptr->getFileName() <<std::endl;
 XMLHandler xmlout;
 xmlout.set_root("RecordKey");
 XMLHandler xmlh;
 rkey.output(xmlh);
 xmlout.put_child(xmlh);
 std::cout << xmlout.str()<<std::endl;
 std::cout << "...execution aborted..."<<std::endl;
 delete iomptr;
 exit(1);
}



template <typename H, typename R, typename D>
void DataGetHandlerSF<H,R,D>::fail(const std::string& msg)
{
// std::cout << "DataGetHandlerSF error: "<<msg<<std::endl;
 delete iomptr;
 throw(std::invalid_argument(std::string("DataGetHandlerSF error: ")+msg));
}



   // **************************************************************
   // *                                                            *
   // *                      DataPutHandlerSF                      *
   // *                                                            *
   // **************************************************************


template <typename H, typename R, typename D>
class DataPutHandlerSF
{

    H& handler;
    IOMap<R,D> *iomptr;


 public:

    DataPutHandlerSF(H& inptr, const std::string& file_name, 
                     const std::string& filetype_id,
                     bool overwrite=false, bool use_checksums=false);

    ~DataPutHandlerSF() {delete iomptr;}

    std::string getFileName() const {return iomptr->getFileName();}


    void putData(const R& rkey, const D& data);

    void flush();

    bool queryData(const R& rkey);


 private:
 
    void fail(const std::string& msg);

    void fail(const R& rkey);


          // disallow copies
    DataPutHandlerSF(const DataPutHandlerSF& in);
    DataPutHandlerSF& operator=(const DataPutHandlerSF& in);

};



   // constructor checks that the information in the header
   // is consistent

template <typename H, typename R, typename D>
DataPutHandlerSF<H,R,D>::DataPutHandlerSF(H& in_handler,
                                          const std::string& file_name,
                                          const std::string& filetype_id,
                                          bool overwrite, bool use_checksums)
                     :  handler(in_handler)
{
 XMLHandler headerxml;
 handler.writeHeader(headerxml);  // write header info 
 try{
   iomptr=new IOMap<R,D>;
   std::string header(headerxml.str());
   iomptr->openUpdate(file_name,filetype_id,header,'L',
                      use_checksums,overwrite);
   if (!(iomptr->isNewFile())){
      XMLHandler xmlr; xmlr.set_from_string(header);
      if (!handler.checkHeader(xmlr)){
         fail("Header string in file is \n"+header+"\n header info in file "
              +file_name+" does not match info in current Handler\n "
              +"...execution aborted...\n");}}}
 catch(const std::exception& xp) {
    fail("could not open file "+file_name+" for writing"); }
}


template <typename H, typename R, typename D>
void DataPutHandlerSF<H,R,D>::putData(const R& rkey, const D& data)
{
 try{
    iomptr->put(rkey,data);}
 catch(const std::exception& xp){
    fail(rkey);}
}


template <typename H, typename R, typename D>
void DataPutHandlerSF<H,R,D>::flush()
{
 iomptr->flush();
}


template <typename H, typename R, typename D>
bool DataPutHandlerSF<H,R,D>::queryData(const R& rkey)
{
 return iomptr->exist(rkey);
}



template <typename H, typename R, typename D>
void DataPutHandlerSF<H,R,D>::fail(const std::string& msg)
{
 std::cout << "DataPutHandlerSF error: "<<msg<<std::endl;
 delete iomptr;
 exit(1);
}


template <typename H, typename R, typename D>
void DataPutHandlerSF<H,R,D>::fail(const R& rkey)
{
 std::cout << "DataPutHandlerSF could not insert requested record:"<<std::endl;
 std::cout << " File name: "<< iomptr->getFileName() <<std::endl;
 XMLHandler xmlout;
 xmlout.set_root("RecordKey");
 XMLHandler xmlh;
 rkey.output(xmlh);
 xmlout.put_child(xmlh);
 std::cout << xmlout.str()<<std::endl;
 std::cout << "...execution aborted..."<<std::endl;
 delete iomptr;
 exit(1);
}


// **************************************************************
}
#endif
