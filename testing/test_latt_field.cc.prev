#ifdef TESTING
#include <string>
#include <fstream>
#include "task_tests.h"
#include "xml_handler.h"
#include "laph_stdio.h"
#include "latt_field.h"
#include "layout_info.h"
#include "utils.h"
#include "field_smearing_info.h"
#include "dilution_scheme_info.h"
#include "dilution_handler.h"
#include <memory>
#if defined(USE_GSL_CBLAS)
#include "gsl_cblas.h"
#elif defined(USE_OPENBLAS)
#include "openblas.h"
#endif
#include "array.h"
#include "laph_noise_info.h"
#include "laph_noise.h"

#ifdef ARCH_PARALLEL
#include <mpi.h>
#endif

typedef std::complex<double> dcmplx;
typedef std::complex<float>  fcmplx;


using namespace std;
using namespace LaphEnv;

namespace QLTestEnv {


// ************************************************

    //   Want assignment method that is reproducible for checking.

LatticeAssigner::LatticeAssigner(uint in_mtseed, double in_minval, double in_maxval, bool in_random) 
                      : random_set(in_random), mtseed(seedval(in_mtseed,in_random)), Q(mtseed)
{
 dprec=(LattField::get_cpu_prec_bytes()==sizeof(dcmplx));
 minval=in_minval;
 maxval=in_maxval;
 if (maxval<minval){
    range=maxval; maxval=minval; minval=range;}
 if ((maxval-minval)<1.0){ maxval=minval+1.0;}
 range=maxval-minval;
 setup_gen();
 if (random_set){
    printLaph(make_str("Lattice Assigner created: mtseed = ",mtseed," is_random = yes"));}
 else{
    printLaph(make_str("Lattice Assigner created: mtseed = ",mtseed," is_random = no  gcoef = ",gcoef));}
}


void LatticeAssigner::reSeed(uint in_mtseed)
{
 uint inmtseed=seedval(in_mtseed,random_set);
 if (inmtseed!=mtseed){
    mtseed=inmtseed;
    Q.Reseed(mtseed);
    setup_gen();
    if (random_set){
       printLaph(make_str("Lattice Assigner reseeded: mtseed = ",mtseed," is_random = yes"));}
    else{
       printLaph(make_str("Lattice Assigner reseeded: mtseed = ",mtseed," is_random = no  gcoef = ",gcoef));}}
}

void LatticeAssigner::setup_gen()
{
 if (!random_set){
    for (int k=0;k<32;++k){
       gcoef=generate();}}
}

uint LatticeAssigner::seedval(uint inseed, bool inrandom)
{
 return ((!inrandom)&&(inseed==0))?16777216:inseed;
}


double LatticeAssigner::generate()
{
 double gen=double(Q.generate() % 1073741824)/1073741824.0;
 return minval+gen*range;
}


void LatticeAssigner::assign_field(LattField& latfield, const string& fieldname)
{
 vector<char> sitedata(latfield.bytesPerSite());
 vector<int> coord(LayoutInfo::Ndim);
 for (int x=0;x<LayoutInfo::getLattSizes()[0];++x)
 for (int y=0;y<LayoutInfo::getLattSizes()[1];++y)
 for (int z=0;z<LayoutInfo::getLattSizes()[2];++z)
 for (int t=0;t<LayoutInfo::getLattSizes()[3];++t){
    coord[0]=x; coord[1]=y; coord[2]=z; coord[3]=t;
    assign_site(coord,sitedata,latfield.elemsPerSite());
    latfield.putSiteData(coord,sitedata);}
 printLaph(make_strf("Lattice field %s assigned using putSiteData",fieldname));
 printLaph(make_strf("  Bytes per site is %d",latfield.bytesPerSite()));
 printLaph(make_strf("  Bytes per word is %d",latfield.bytesPerWord()));
 printLaph(make_strf(" Elements per site is %d\n",latfield.elemsPerSite()));

// const complex<float>* zd=reinterpret_cast<const complex<float>*>(latfield.getDataConstPtr());
// int ncmplx=latfield.getDataRef().size()/sizeof(complex<float>);
// for (int k=0;k<ncmplx;++k,++zd){ printLaph(make_str("val[",k,"] = ",*zd));}
}


void LatticeAssigner::assign_site(const std::vector<int>& coord, std::vector<char>& result, 
                                  int cmplx_per_site)
{
 vector<dcmplx> buffer(cmplx_per_site);
 if (random_set){
     site_random_assigner(coord,buffer);}
 else{
     site_basic_assigner(coord,buffer);}
 if (dprec){
    dcmplx* dptr=reinterpret_cast<dcmplx*>(result.data());
    for (int k=0;k<cmplx_per_site;++k,++dptr){
       *dptr=buffer[k];}}
 else{
    complex<float>* fptr=reinterpret_cast<complex<float>*>(result.data());
    for (int k=0;k<cmplx_per_site;++k,++fptr){
       *fptr=complex<float>(real(buffer[k]),imag(buffer[k]));}}
}


void LatticeAssigner::site_random_assigner(const std::vector<int>& coord, 
                                           std::vector<dcmplx>& result)
{
 for (uint k=0;k<result.size();++k){
    result[k]=dcmplx(generate(),generate());}
 if (result.size()==9) reunitarize(result);
}


void LatticeAssigner::site_basic_assigner(const std::vector<int>& coord, 
                                          std::vector<dcmplx>& result)
{
 double x=double(coord[0]);
 double y=double(coord[1]);
 double z=double(coord[2]);
 double t=double(coord[3]);
 double res1=2.5*x-3.7*y+0.334*z+1.32*t+0.25*gcoef;
 double res2=-4.12*t+x+0.153*z+0.632*y-1.25*gcoef;
 for (uint k=0;k<result.size();++k){
    double gen1=res1+double(k)*res2;
    double gen2=res2+double(k)*res1;
    while (gen1>maxval) gen1-=range;
    while (gen1<minval) gen1+=range;
    while (gen2>maxval) gen2-=range;
    while (gen2<minval) gen2+=range;
    result[k]=dcmplx(gen1,gen2);}
 if (result.size()==9) reunitarize(result);
}


vector<int> LatticeAssigner::getRandomSite()
{
 vector<int> randsite(LayoutInfo::Ndim);
 if (isPrimaryRank()){
    for (int k=0;k<LayoutInfo::Ndim;++k){
       randsite[k]=Q.generate() % LayoutInfo::getLattSizes()[k];}}
#ifdef ARCH_PARALLEL
 comm_broadcast((char*)randsite.data(),LayoutInfo::Ndim*sizeof(int),0);
#endif
 return randsite;
}


void LatticeAssigner::reunitarize(std::vector<dcmplx>& result)
{
 double r=1.0/sqrt((result[0]*conj(result[0])+result[1]*conj(result[1])+result[2]*conj(result[2])).real());
 result[0]*=r; result[1]*=r; result[2]*=r;  // this is u1
 dcmplx b1=result[3]+result[6];
 dcmplx b2=result[4]+result[7];
 dcmplx b3=result[5]+result[8];
    // take cross product u1 X v1 then unit normalize
 cross_prod(b1,b2,b3,result[0],result[1],result[2],result[3],result[4],result[5]);
 cross_prod(conj(result[0]),conj(result[1]),conj(result[2]),result[3],result[4],result[5],result[6],result[7],result[8]);
   // check unitarity
 //dcmplx U11=result[0]; dcmplx U12=result[1]; dcmplx U13=result[2];
 //dcmplx U21=result[3]; dcmplx U22=result[4]; dcmplx U23=result[5];
 //dcmplx U31=result[6]; dcmplx U32=result[7]; dcmplx U33=result[8]; dcmplx one(1.0,0.0);
 //if (std::abs( U11*conj(U11) + U12*conj(U12) + U13*conj(U13)-one)>1e-10) printLaph("unitarity1 failed\n");
 //if (std::abs( U11*conj(U21) + U12*conj(U22) + U13*conj(U23)    )>1e-10) printLaph("unitarity2 failed\n");  
 //if (std::abs( U11*conj(U31) + U12*conj(U32) + U13*conj(U33)    )>1e-10) printLaph("unitarity3 failed\n");
 //if (std::abs( U21*conj(U11) + U22*conj(U12) + U23*conj(U13)    )>1e-10) printLaph("unitarity4 failed\n");  
 //if (std::abs( U21*conj(U21) + U22*conj(U22) + U23*conj(U23)-one)>1e-10) printLaph("unitarity5 failed\n");
 //if (std::abs( U21*conj(U31) + U22*conj(U32) + U23*conj(U33)    )>1e-10) printLaph("unitarity6 failed\n");
 //if (std::abs( U31*conj(U11) + U32*conj(U12) + U33*conj(U13)    )>1e-10) printLaph("unitarity7 failed\n"); 
 //if (std::abs( U31*conj(U21) + U32*conj(U22) + U33*conj(U23)    )>1e-10) printLaph("unitarity8 failed\n"); 
 //if (std::abs( U31*conj(U31) + U32*conj(U32) + U33*conj(U33)-one)>1e-10) printLaph("unitarity9 failed\n");
}

    // sets C = A X B* then unit normalizes C
void LatticeAssigner::cross_prod(const dcmplx& A1, const dcmplx& A2, const dcmplx& A3,
                                 const dcmplx& B1, const dcmplx& B2, const dcmplx& B3,
                                 dcmplx& C1, dcmplx& C2, dcmplx& C3)
{
 C1=A2*conj(B3)-A3*conj(B2);
 C2=A3*conj(B1)-A1*conj(B3);
 C3=A1*conj(B2)-A2*conj(B1);
 double r=1.0/sqrt((C1*conj(C1)+C2*conj(C2)+C3*conj(C3)).real());
 C1*=r; C2*=r; C3*=r; 
}

bool LatticeAssigner::dprec;

// ************************************************



bool LatticeChecker::check_field(const LattField& latfield, const string& fieldname, bool full)
{
 if (latassigner.isDblePrec()){  printLaph("double precision check");
    double tolerance=1e-10;
    return do_check_field(latfield,fieldname,full,tolerance);}
 else{
    float tolerance=1e-5;  printLaph("single precision check");
    return do_check_field(latfield,fieldname,full,tolerance);}
}


template <typename T>
bool LatticeChecker::do_check_field(const LattField& latfield, const string& fieldname, bool full,
                                    const T& tolerance)
{
 bool flag;
 printLaph(" Starting field check");
 printLaph(make_strf("  Bytes per site is %d",latfield.bytesPerSite()));
 printLaph(make_strf("  Bytes per word is %d",latfield.bytesPerWord()));
 printLaph(make_strf(" Elements per site is %d",latfield.elemsPerSite()));
 if (full) flag=check_field_full(latfield,fieldname,tolerance);
 else flag=check_field_random(latfield,fieldname,tolerance);
 printLaph("\n");
 return flag;
}


template <typename T>
bool LatticeChecker::check_field_full(const LattField& latfield, const string& fieldname,
                                      const T& tolerance)
{
 bool result=true;
 printLaph(make_strf("Do full lattice field check for %s",fieldname));
 for (int y=0;y<LayoutInfo::getLattSizes()[1];++y)
 for (int x=0;x<LayoutInfo::getLattSizes()[0];++x)
 for (int t=0;t<LayoutInfo::getLattSizes()[3];++t)
 for (int z=0;z<LayoutInfo::getLattSizes()[2];++z){
    vector<int> coord(LayoutInfo::Ndim);
    coord[0]=x; coord[1]=y; coord[2]=z; coord[3]=t;
    result = result && do_site_checker(latfield,coord,tolerance);}
 printLaph(make_strf("Full lattice check of %s is done",fieldname));
 return result;
}


template <typename T>
bool LatticeChecker::check_field_random(const LattField& latfield, const string& fieldname,
                                        const T& tolerance)
{
 bool result=true;
 printLaph(make_strf("Do random lattice field check for %s",fieldname));
 for (int k=0;k<256;++k){
    vector<int> coord(latassigner.getRandomSite());
    result = result && do_site_checker(latfield,coord,tolerance);}
 printLaph(make_strf("Random lattice check of %s is done",fieldname));
 return result;
}


template <typename T>
bool LatticeChecker::do_site_checker(const LattField& latfield, const vector<int>& coord, 
                                     const T& tolerance)
{
 vector<char> cv(latfield.getSiteData(coord));  
 vector<char> check(latfield.bytesPerSite());
 latassigner.assign_site(coord,check,latfield.elemsPerSite());
 bool flag=true;
 complex<T>* dptr=reinterpret_cast<complex<T>*>(cv.data());
 complex<T>* cptr=reinterpret_cast<complex<T>*>(check.data());
 for (uint k=0;k<latfield.elemsPerSite();++k,++dptr,++cptr){
    T df=std::abs((*dptr)-(*cptr));    //  /(0.5*(std::abs((*dptr))+std::abs((*cptr))));
    flag=flag && (df<tolerance);}
#ifdef ARCH_PARALLEL
 flag=globalAnd(flag);
#endif
 if (!flag){
    printLaph(make_strf("MISMATCH for site (%d,%d,%d,%d)",coord[0],coord[1],coord[2],coord[3]));
    dptr=reinterpret_cast<complex<T>*>(cv.data());
    cptr=reinterpret_cast<complex<T>*>(check.data());    
    for (uint k=0;k<latfield.elemsPerSite();++k,++dptr,++cptr){
       printLaph(make_strf("For element %d GOT: (%f,%f) EXPECTED (%f,%f)",k,dptr->real(),dptr->imag(),
                  cptr->real(),cptr->imag()));}}
 return flag;
}


// *************************************************************************************


void GaugeFieldAssigner::assign_gauge_field(std::vector<LattField>& gauge_field, const string& fieldname)
{
 gauge_field.resize(LayoutInfo::Ndim);
 for (int dir=0;dir<LayoutInfo::Ndim;++dir){
    gauge_field[dir].reset(FieldSiteType::ColorMatrix);
    LA.reSeed(mtseeds[dir]);
    LA.assign_field(gauge_field[dir],fieldname);}
}


bool GaugeFieldChecker::check_gauge_field(const vector<LattField>& gffield, const string& fieldname, bool full)
{
 bool flag=true;
 for (int dir=0;dir<LayoutInfo::Ndim;++dir){
    LC.reSeed(GF_assigner.mtseeds[dir]);
    flag=flag && LC.check_field(gffield[dir],fieldname,full);}
 return flag;
}


// ********************************************************************************

void testLatticeField(XMLHandler& xml_in)
{
 if (xml_tag_count(xml_in,"TestLatticeField")==0)
 return;

 uint MTseed1=0, MTseed2=0, MTseed3=0, MTseed4=0;
 XMLHandler xmlr(xml_in,"TestLatticeField");
 xmlreadif(xmlr,"MTSeed1",MTseed1,"TestLatticeField");
 xmlreadif(xmlr,"MTSeed2",MTseed2,"TestLatticeField");
 xmlreadif(xmlr,"MTSeed3",MTseed3,"TestLatticeField");
 xmlreadif(xmlr,"MTSeed4",MTseed4,"TestLatticeField");
 double minval=-10.0;
 double maxval=10.0;
 xmlreadif(xmlr,"MinValue",minval,"TestLatticeField");
 xmlreadif(xmlr,"MaxValue",maxval,"TestLatticeField");

 printLaph(make_strf("MTSeed1 is %d",MTseed1));
 printLaph(make_strf("MTSeed2 is %d",MTseed2));
 printLaph(make_strf("MTSeed3 is %d",MTseed3));
 printLaph(make_strf("MTSeed4 is %d",MTseed4));
 printLaph(make_strf("MinValue is %f",minval));
 printLaph(make_strf("MaxValue is %f",maxval));

 LatticeAssigner Q(MTseed1,minval,maxval);
 LatticeChecker LC(Q);

 {LattField tmp;
 printLaph(make_strf("Initial tmp size is %d (should be 0)",tmp.getDataConstRef().size()));

 tmp.reset(FieldSiteType::ColorVector);
 printLaph(make_strf("After reset, tmp size is %d (should be %d)",tmp.getDataConstRef().size(),
             LayoutInfo::getRankLatticeNumSites()*3*LattField::get_cpu_prec_bytes()));
 Q.assign_field(tmp,"First ColorVector");
 LC.check_field(tmp,"First ColorVector",true);

 //printField(tmp,"First ColorVector Field");

 LattField tmp2(FieldSiteType::Complex);
 Q.reSeed(MTseed2);
 Q.assign_field(tmp2,"First Complex");
 LC.check_field(tmp2,"First Complex",false);

 LattField tmp3(tmp);
 Q.reSeed(MTseed1);
 LC.check_field(tmp3,"tmp3 copy",false);
 
 LattField tmp4(FieldSiteType::ColorSpinVector);
 tmp4=tmp3;
 LC.check_field(tmp4,"tmp4 assigned",false);

 tmp2.reset(FieldSiteType::ColorSpinVector);
 Q.reSeed(MTseed3);
 Q.assign_field(tmp2,"Reset ColorSpinVector");
 LC.check_field(tmp2,"Reset ColorSpinVector",true);}


 {LattField tmp;
 printLaph(make_strf("Initial tmp size is %d (should be 0)",tmp.getDataConstRef().size()));

 tmp.reset(FieldSiteType::ColorVector);
 printLaph(make_strf("After reset, tmp size is %d (should be %d)",tmp.getDataConstRef().size(),
             LayoutInfo::getRankLatticeNumSites()*3*LattField::get_cpu_prec_bytes()));
 Q.reSeed(MTseed1);
 Q.assign_field(tmp,"Second ColorVector");
 LC.check_field(tmp,"Second ColorVector",true);

 LattField tmp2(FieldSiteType::Complex);
 Q.reSeed(MTseed2);
 Q.assign_field(tmp2,"Second Complex");
 LC.check_field(tmp2,"Second Complex",false);

 LattField tmp3(tmp);
 Q.reSeed(MTseed1);
 LC.check_field(tmp3,"Second tmp3 copy",false);
 
 LattField tmp4(FieldSiteType::ColorSpinVector);
 tmp4=tmp3;
 LC.check_field(tmp4,"Second tmp4 assigned",false);

 tmp2.reset(FieldSiteType::ColorSpinVector);
 Q.reSeed(MTseed2);
 Q.assign_field(tmp2,"Reset ColorSpinVector");
 LC.check_field(tmp2,"Reset ColorSpinVector",true);}

 printLaph("Doing a gauge field assignment");
 GaugeFieldAssigner GC(MTseed1,MTseed2,MTseed3,MTseed4);
 vector<LattField> GF1;
 GC.assign_gauge_field(GF1,"GaugeField1");
 
 GaugeFieldChecker GFC(GC);
 GFC.check_gauge_field(GF1,"GaugeField1",true);

 printLaph("Doing another gauge field assignment");
 vector<LattField> GF2;
 GC.reSeed(MTseed3,MTseed1,MTseed4,MTseed2);
 GC.assign_gauge_field(GF2,"GaugeField2");
 GFC.check_gauge_field(GF2,"GaugeField2",true);

}


void make_quark_source_slow_dp(LattField& ferm_src, const Array<dcmplx>& laph_noise, 
                               const std::vector<LattField>& evs, const list<int>& on_times, 
                               const list<int>& on_spins, const list<int>& on_eigs)
{
 printLaph(" Slow making source for this inversion...");
 if (evs.size()==0){
    errorLaph("Cannot make fermion source since no Laph eigenvectors available");}
 ferm_src.reset(FieldSiteType::ColorSpinVector);
 vector<int> latt_coords(LayoutInfo::Ndim);
 for (latt_coords[0]=0;latt_coords[0]<LayoutInfo::getLattSizes()[0];++latt_coords[0])
 for (latt_coords[1]=0;latt_coords[1]<LayoutInfo::getLattSizes()[1];++latt_coords[1])
 for (latt_coords[2]=0;latt_coords[2]<LayoutInfo::getLattSizes()[2];++latt_coords[2])
 for (latt_coords[3]=0;latt_coords[3]<LayoutInfo::getLattSizes()[3];++latt_coords[3]){
    vector<char> siteData(ferm_src.bytesPerSite());
    complex<double>* sd=reinterpret_cast<complex<double>*>(siteData.data());
    for (uint k=0;k<ferm_src.elemsPerSite();++k){
       *(sd+k)=complex<double>(0.0,0.0);}
    bool onflag=false;
    for (list<int>::const_iterator it0=on_times.begin();it0!=on_times.end();it0++){
       if ((*it0)==latt_coords[3]) onflag=true;}
    if (onflag){
       //printLaph(make_str(" this time is ON: (",latt_coords[0],",",latt_coords[1],",",latt_coords[2],",",latt_coords[3],")"));
       for (list<int>::const_iterator smask= on_spins.begin(); smask!=on_spins.end(); smask++){
       for (list<int>::const_iterator vmask= on_eigs.begin(); vmask!=on_eigs.end(); vmask++){
          //printLaph(make_str(" on spin = ",*smask," on eig ind = ",*vmask));
          std::vector<char> buf(evs[*vmask].getSiteData(latt_coords));
          complex<double>* vv=reinterpret_cast<complex<double>*>(buf.data());
          //for (int c=0;c<FieldNcolor;++c) printLaph(make_str("ev component ",*(vv+c)));
          complex<double> zrho(laph_noise(latt_coords[3],*smask,*vmask)); //printLaph(make_str("zrho is ",zrho));
          for (int c=0;c<FieldNcolor;++c){
             *(sd+(*smask)*FieldNcolor+c)+=zrho*(*(vv+c));}}}
             //printLaph("site data follows:");
             //for (int k=0;k<12;++k){ printLaph(make_str(" site data element ",k," is ",*(sd+k)));}
             }
    ferm_src.putSiteData(latt_coords,siteData);}
 printLaph("Slow source for this inversion created");
}

void make_quark_source_slow_sp(LattField& ferm_src, const Array<dcmplx>& laph_noise, 
                               const std::vector<LattField>& evs, const list<int>& on_times, 
                               const list<int>& on_spins, const list<int>& on_eigs)
{
 printLaph(" Slow making source for this inversion...");
 if (evs.size()==0){
    errorLaph("Cannot make fermion source since no Laph eigenvectors available");}
 ferm_src.reset(FieldSiteType::ColorSpinVector);
 vector<int> latt_coords(LayoutInfo::Ndim);
 for (latt_coords[0]=0;latt_coords[0]<LayoutInfo::getLattSizes()[0];++latt_coords[0])
 for (latt_coords[1]=0;latt_coords[1]<LayoutInfo::getLattSizes()[1];++latt_coords[1])
 for (latt_coords[2]=0;latt_coords[2]<LayoutInfo::getLattSizes()[2];++latt_coords[2])
 for (latt_coords[3]=0;latt_coords[3]<LayoutInfo::getLattSizes()[3];++latt_coords[3]){
    vector<char> siteData(ferm_src.bytesPerSite());
    complex<float>* sd=reinterpret_cast<complex<float>*>(siteData.data());
    for (uint k=0;k<ferm_src.elemsPerSite();++k){
       *(sd+k)=complex<float>(0.0,0.0);}
    bool onflag=false;
    for (list<int>::const_iterator it0=on_times.begin();it0!=on_times.end();it0++){
       if ((*it0)==latt_coords[3]) onflag=true;}
    if (onflag){
       //printLaph(make_str(" this time is ON: (",latt_coords[0],",",latt_coords[1],",",latt_coords[2],",",latt_coords[3],")"));
       for (list<int>::const_iterator smask= on_spins.begin(); smask!=on_spins.end(); smask++){
       for (list<int>::const_iterator vmask= on_eigs.begin(); vmask!=on_eigs.end(); vmask++){
          //printLaph(make_str(" on spin = ",*smask," on eig ind = ",*vmask));
          std::vector<char> buf(evs[*vmask].getSiteData(latt_coords));
          complex<float>* vv=reinterpret_cast<complex<float>*>(buf.data());
          complex<double> zdrho(laph_noise(latt_coords[3],*smask,*vmask));
          complex<float> zrho(real(zdrho),imag(zdrho));  //printLaph(make_str("zrho is ",zrho));
          for (int c=0;c<FieldNcolor;++c){
             *(sd+(*smask)*FieldNcolor+c)+=zrho*(*(vv+c));}}}
             //printLaph("site data follows:");
             //for (int k=0;k<12;++k){ printLaph(make_str(" site data element ",k," is ",*(sd+k)));}
             }
    ferm_src.putSiteData(latt_coords,siteData);}
 printLaph("Slow source for this inversion created");
}


 // below is the fast (on the cpu) version to be tested
 
void QuarkHandler_make_source(LattField& ferm_src, const Array<cmplx>& laph_noise, 
                              std::vector<void*> evList, const list<int>& on_times, 
                              const list<int>& on_spins, const list<int>& on_eigs)
{
 printLaph(" Making source for this inversion...");
 if (evList.size()==0){
    errorLaph("Cannot make fermion source since no Laph eigenvectors available");}
 ferm_src.reset(FieldSiteType::ColorSpinVector);
 bool dp=(ferm_src.bytesPerWord()==sizeof(std::complex<double>));
    // initialize source field to zero
 int nsites=LayoutInfo::getRankLatticeNumSites();
 int ncmplx_per_site=ferm_src.elemsPerSite();
 int ncmplx=ncmplx_per_site*nsites;
 int cbytes;
 dcmplx zrhodp;
 fcmplx zrhosp;
 char *zrho;
 if (dp){
 //printLaph("filling dp with zeros");
    double* z0=reinterpret_cast<double*>(ferm_src.getDataPtr());
    std::fill(z0,z0+2*ncmplx,0.0);
    cbytes=sizeof(std::complex<double>);
    zrho=reinterpret_cast<char*>(&zrhodp);}
 else{
 //printLaph("filling sp with zeros");
    float* z0=reinterpret_cast<float*>(ferm_src.getDataPtr());
    std::fill(z0,z0+2*ncmplx,0.0);
    cbytes=sizeof(std::complex<float>);
    zrho=reinterpret_cast<char*>(&zrhosp);}

 int start_parity=LayoutInfo::getMyStartParity();
 int mytmin=LayoutInfo::getMyCommCoords()[3]*LayoutInfo::getRankLattSizes()[3];
 int mytmax=mytmin+LayoutInfo::getRankLattSizes()[3]-1;
 int tstride=LayoutInfo::getRankLattSizes()[0]*LayoutInfo::getRankLattSizes()[1]
            *LayoutInfo::getRankLattSizes()[2];
 int loc_nsites=LayoutInfo::getRankLatticeNumSites();
 int incx=FieldNcolor;
 int incy=FieldNcolor*FieldNspin;

 for (list<int>::const_iterator it0=on_times.begin();it0!=on_times.end();it0++){
    if (((*it0)>=mytmin)&&((*it0)<=mytmax)){
       int tloc=((*it0)-mytmin);
       int parshift=loc_nsites/2*((start_parity+tloc)%2);
       int start1=tstride*tloc/2 + parshift;
       int stop1=(1+tstride*(tloc+1))/2 + parshift;
       int n1=stop1-start1;
       parshift=loc_nsites/2*((start_parity+1+tloc)%2);
       int start2=(1+tstride*tloc)/2 + parshift;
       int stop2=(tstride*(tloc+1))/2 + parshift;
       int n2=stop2-start2;
       int xstart1=start1*incx*cbytes;
       int xstart2=start2*incx*cbytes;
       char* ystart1=ferm_src.getDataPtr()+start1*incy*cbytes;
       char* ystart2=ferm_src.getDataPtr()+start2*incy*cbytes;
       
       for (list<int>::const_iterator vmask= on_eigs.begin(); vmask!=on_eigs.end(); vmask++){
          char* x0=reinterpret_cast<char*>(evList[*vmask]);
          for (list<int>::const_iterator smask= on_spins.begin(); smask!=on_spins.end(); smask++){
             if (dp){
                zrhodp=laph_noise(*it0,*smask,*vmask);}
             else{
                zrhodp=laph_noise(*it0,*smask,*vmask);
                zrhosp=complex<float>(real(zrhodp),imag(zrhodp));}
             char* x1=x0+xstart1;
             char* x2=x0+xstart2;
             char* y1=ystart1+(*smask)*incx*cbytes;
             char* y2=ystart2+(*smask)*incx*cbytes;
             for (int c=0;c<FieldNcolor;++c){
                if (dp){
                   cblas_zaxpy(n1,(dcmplx*)(zrho),(dcmplx*)(x1),incx,(dcmplx*)(y1),incy);
                   cblas_zaxpy(n2,(dcmplx*)(zrho),(dcmplx*)(x2),incx,(dcmplx*)(y2),incy);}
                else{
                   cblas_caxpy(n1,(fcmplx*)(zrho),(fcmplx*)(x1),incx,(fcmplx*)(y1),incy);
                   cblas_caxpy(n2,(fcmplx*)(zrho),(fcmplx*)(x2),incx,(fcmplx*)(y2),incy);}
                x1+=cbytes; y1+=cbytes; x2+=cbytes; y2+=cbytes;}}}}}
//    QDPIO::cout << "source created...starting inversion"<<endl;
//    bulova.stop(); srctime+=bulova.getTimeInSeconds();
//    seiko.stop(); rotatetime+=seiko.getTimeInSeconds();*/
 printLaph("Source for this inversion created");
}

bool compare_sites_dp(const vector<char>& site1, const vector<char>& site2, int nelem)
{
 const complex<double>* z1=reinterpret_cast<const complex<double>*>(site1.data());
 const complex<double>* z2=reinterpret_cast<const complex<double>*>(site2.data());
 for (int k=0;k<nelem;++k){

    const vector<int> N=LayoutInfo::getLattSizes();
    vector<int> s(4),ss(4);

    int ival1=round(z1->real());
    s[0]=ival1 % N[0]; int b=(ival1-s[0])/N[0];
    s[1]=b % N[1];  b=(b-s[1])/N[1];
    s[2]=b % N[2];  s[3]=(b-s[2])/N[2];


    int ival2=round(z2->real());
    ss[0]=ival2 % N[0]; b=(ival2-ss[0])/N[0];
    ss[1]=b % N[1];  b=(b-ss[1])/N[1];
    ss[2]=b % N[2];  ss[3]=(b-ss[2])/N[2];

    //printLaph(make_str("dp spin = ",k/4," color = ",k%3," ",*z1," ",*z2));
    if (std::abs((*z1)-(*z2))>1e-12){
       printLaph(make_str("DISAGREE ",*z1," ",*z2)); //," ",ival1," ",ival2));
       printLaph(make_strf("DISAGREE (%d %d %d %d) (%d %d %d %d)",s[0],s[1],s[2],s[3],ss[0],ss[1],ss[2],ss[3]));
       /*return false;*/}
    ++z1;++z2;}
 return true;
}

bool compare_sites_sp(const vector<char>& site1, const vector<char>& site2, int nelem)
{
 const complex<float>* z1=reinterpret_cast<const complex<float>*>(site1.data());
 const complex<float>* z2=reinterpret_cast<const complex<float>*>(site2.data());
 for (int k=0;k<nelem;++k){
    //printLaph(make_str("sp spin = ",k/4," color = ",k%3," ",*z1," ",*z2));
    if (std::abs((*z1)-(*z2))>1e-5){
       printLaph(make_str("DISAGREE ",*z1," ",*z2));
       /*return false;*/}
    ++z1;++z2;}
 return true;
}

bool compare_sites(const vector<char>& site1, const vector<char>& site2, int nelem)
{
 if (site1.size()!=site2.size()){
    printLaph("Size mismatch"); return false;}
 if (site1.size()==sizeof(complex<double>)*nelem){
    return compare_sites_dp(site1,site2,nelem);}
 else{
    return compare_sites_sp(site1,site2,nelem);}
}


void compare_fields(const LattField& src1, const LattField& src2)
{
 bool flag=true;
 int n1=src1.elemsPerSite();
 int n2=src2.elemsPerSite();
 if (n1!=n2){ flag=false;}
 else{
 vector<int> latt_coords(LayoutInfo::Ndim);
 for (latt_coords[0]=0;latt_coords[0]<LayoutInfo::getLattSizes()[0];++latt_coords[0])
 for (latt_coords[1]=0;latt_coords[1]<LayoutInfo::getLattSizes()[1];++latt_coords[1])
 for (latt_coords[2]=0;latt_coords[2]<LayoutInfo::getLattSizes()[2];++latt_coords[2])
 for (latt_coords[3]=0;latt_coords[3]<LayoutInfo::getLattSizes()[3];++latt_coords[3]){
    //printLaph(make_str("site(",latt_coords[0],",",latt_coords[1],",",latt_coords[2],",",latt_coords[3],")"));
    vector<char> site1(src1.getSiteData(latt_coords));
    vector<char> site2(src2.getSiteData(latt_coords));
    flag=flag && compare_sites(site1,site2,n1);}}
 if (flag) printLaph("Sources AGREE");
 else printLaph("Sources DISAGREE");
}


void testMakeQuarkSource(XMLHandler& xml_in)
{
 if (xml_tag_count(xml_in,"TestMakeQuarkSource")==0)
 return;
 
 XMLHandler xmlr(xml_in,"TestMakeQuarkSource");
 DilutionSchemeInfo dilscheme(xmlr);
 QuarkSmearingInfo qSmear(xmlr);
 LaphNoiseInfo noise(xmlr);
 uint MTseed=0;
 xmlreadif(xmlr,"MTSeed",MTseed,"TestMakeQuarkSource");
 double minval=-10.0;
 double maxval=10.0;
 xmlreadif(xmlr,"MinValue",minval,"TestLatticeField");
 xmlreadif(xmlr,"MaxValue",maxval,"TestLatticeField");
 printLaph(make_str("Mersenne Twister seed: ",MTseed));
 printLaph(make_str(" random min value is ",minval));
 printLaph(make_str(" random max value is ",maxval));

 printLaph("Dilution Scheme :");
 printLaph(dilscheme.output());
 printLaph("Quark Smearing:");
 printLaph(qSmear.output());
 printLaph("Noise Info:");
 printLaph(noise.output());

 DilutionHandler dilHandler(dilscheme,qSmear);
 int nEigs = qSmear.getNumberOfLaplacianEigenvectors();
 printLaph("Dilution Handler successfully set up");

        // generate the source noise field
 LaphZnNoise rho(noise.getZNGroup(),noise.getSeed());
 Array<dcmplx> laph_noise=rho.generateLapHQuarkSourceForSink(LayoutInfo::getLattSizes()[3],FieldNspin,nEigs);

// for (int t=0;t<LayoutInfo::getLattSizes()[3];++t)
// for (int s=0;s<FieldNspin;++s)
// for (int v=0;v<nEigs;++v){
//    printLaph(make_str("laph_noise(",t,",",s,",",v,") = ",laph_noise(t,s,v)));}

 LatticeAssigner Q(MTseed,minval,maxval);
 printLaph("LatticeAssigner created");

 vector<LattField> laph_evs(nEigs,FieldSiteType::ColorVector);
 vector<void*> evList(nEigs);
 for (int k=0;k<nEigs;++k){
    printLaph(make_str("creating eigenvector",k));
    //MTseed/=(k+117);
    //MTseed+=713245239;
    //Q.reSeed(MTseed);
    Q.assign_field(laph_evs[k],"AssignedLaphEv");
    evList[k]=reinterpret_cast<void*>(laph_evs[k].getDataPtr());}

 printLaph("Now beginning source creation tests...");
 int ndil=dilHandler.getNumberOfSpinEigvecProjectors();
 for (int time_proj_index=0;time_proj_index<dilHandler.getNumberOfTimeProjectors();++time_proj_index){
    for (int dil=0;dil<ndil;dil++){
       printLaph(make_str("Starting source creation test for time_proj_index = ",time_proj_index," and dil = ",dil));
       const list<int>& on_times=dilHandler.getOnTimes(time_proj_index);
       const list<int>& on_spins=dilHandler.getOnSpinIndices(dil);
       const list<int>& on_eigs=dilHandler.getOnEigvecIndices(dil);
       LattField ferm_src1, ferm_src2;
       QuarkHandler_make_source(ferm_src1,laph_noise,evList,on_times,on_spins,on_eigs);
       if (ferm_src1.bytesPerWord()==sizeof(complex<double>)){
          make_quark_source_slow_dp(ferm_src2,laph_noise,laph_evs,on_times,on_spins,on_eigs);}
       else{
          make_quark_source_slow_sp(ferm_src2,laph_noise,laph_evs,on_times,on_spins,on_eigs);}
       compare_fields(ferm_src1,ferm_src2);
       }}
}

  // This is useful for debugging only; very slow.  "nsites" is the number of
  // sites to print in order from (0,0,0,0).  An input value of -1 means print all.

void printField(const LattField& field, const std::string& fieldname, int nsites)
{
 printLaph(make_str("Lattice Field named ",fieldname));
 bool dp=(field.bytesPerWord()==sizeof(complex<double>)); 
 int nelem_site=field.elemsPerSite();
 vector<char> siteData(field.bytesPerSite());
 vector<int> coord(LayoutInfo::Ndim);
 uint count=0;
 uint ncount=(nsites>0)?nsites:LayoutInfo::getLatticeNumSites();
 for (coord[3]=0;coord[3]<LayoutInfo::getLattSizes()[3];++coord[3])
 for (coord[2]=0;coord[2]<LayoutInfo::getLattSizes()[2];++coord[2])
 for (coord[1]=0;coord[1]<LayoutInfo::getLattSizes()[1];++coord[1])
 for (coord[0]=0;coord[0]<LayoutInfo::getLattSizes()[0];++coord[0],++count){
    if (count==ncount) return;
    printLaph(make_str(" field site (",coord[0],",",coord[1],",",coord[2],",",coord[3],"):"));
    vector<char> sitedata(field.getSiteData(coord));
    if (dp){
       complex<double>* z=reinterpret_cast<complex<double>*>(sitedata.data());
       for (int k=0;k<nelem_site;++k,++z){
          printLaph(make_str("  field_comp[",k,"] = ",*z));}}
    else{
       complex<float>* z=reinterpret_cast<complex<float>*>(sitedata.data());
       for (int k=0;k<nelem_site;++k,++z){
          printLaph(make_str("  field_comp[",k,"] = ",*z));}}}
}


void printFieldToFile(const LattField& field, const std::string& infostring, const std::string& filename)
{
 ofstream fout;
 if (isPrimaryRank()){
    fout.open(filename);
    fout << infostring<<endl;
    fout.precision(14);}
 bool dp=(field.bytesPerWord()==sizeof(complex<double>)); 
 int nelem_site=field.elemsPerSite();
 vector<char> siteData(field.bytesPerSite());
 vector<int> coord(LayoutInfo::Ndim);
 for (coord[3]=0;coord[3]<LayoutInfo::getLattSizes()[3];++coord[3])
 for (coord[2]=0;coord[2]<LayoutInfo::getLattSizes()[2];++coord[2])
 for (coord[1]=0;coord[1]<LayoutInfo::getLattSizes()[1];++coord[1])
 for (coord[0]=0;coord[0]<LayoutInfo::getLattSizes()[0];++coord[0]){
    if (isPrimaryRank()){
       fout << " field site ("<<coord[0]<<","<<coord[1]<<","<<coord[2]<<","<<coord[3]<<"):"<<endl;}
    vector<char> sitedata(field.getSiteData(coord));
    if (dp){
       complex<double>* z=reinterpret_cast<complex<double>*>(sitedata.data());
       for (int k=0;k<nelem_site;++k,++z){
          if (isPrimaryRank()){
             fout <<"  field_comp["<<k<<"] = "<<*z<<endl;}}}
    else{
       complex<float>* z=reinterpret_cast<complex<float>*>(sitedata.data());
       for (int k=0;k<nelem_site;++k,++z){
          if (isPrimaryRank()){
             fout <<"  field_comp["<<k<<"] = "<<*z<<endl;}}}}
 if (isPrimaryRank()){
    fout.close();}
}


void printField(const LattField& field, const std::string& fieldname, 
                const std::vector<std::vector<int>>& sites)
{
 printLaph(make_str("Lattice Field named ",fieldname));
 bool dp=(field.bytesPerWord()==sizeof(complex<double>)); 
 int nelem_site=field.elemsPerSite();
 vector<char> siteData(field.bytesPerSite());
 for (int count=0;count<int(sites.size());++count){
    const std::vector<int>& coord=sites[count];
    printLaph(make_str(" field site (",coord[0],",",coord[1],",",coord[2],",",coord[3],"):"));
    vector<char> sitedata(field.getSiteData(coord));
    if (dp){
       complex<double>* z=reinterpret_cast<complex<double>*>(sitedata.data());
       for (int k=0;k<nelem_site;++k,++z){
          printLaph(make_str("  field_comp[",k,"] = ",*z));}}
    else{
       complex<float>* z=reinterpret_cast<complex<float>*>(sitedata.data());
       for (int k=0;k<nelem_site;++k,++z){
          printLaph(make_str("  field_comp[",k,"] = ",*z));}}}
}


void setConstantField(LattField& field, const std::complex<double>& zconst)
{
 bool dp=(field.bytesPerWord()==sizeof(complex<double>));
 int n=field.elemsPerSite()*LayoutInfo::getRankLatticeNumSites();
 if (dp){
    complex<double>* z=reinterpret_cast<complex<double>*>(field.getDataPtr());
    for (int k=0;k<n;++k,++z){
       *z=zconst;}}
 else{
    complex<float> zfconst(float(real(zconst)),float(imag(zconst)));
    complex<float>* z=reinterpret_cast<complex<float>*>(field.getDataPtr());
    for (int k=0;k<n;++k,++z){
       *z=zfconst;}}
}


void setUnitField(LattField& field)
{
 setConstantField(field,complex<double>(1.0,0.0));
}


void setZeroField(LattField& field)
{
 setConstantField(field,complex<double>(0.0,0.0));
}


void setFieldLexicoIndex(LattField& field)
{
 const vector<int>& N=LayoutInfo::getRankLattSizes();
 const vector<int>& GN=LayoutInfo::getLattSizes();
 const vector<int>& comm_coord=LayoutInfo::getMyCommCoords();
 vector<int> xstart(LayoutInfo::Ndim);
 vector<int> xstop(LayoutInfo::Ndim);
 vector<int> x(LayoutInfo::Ndim);
 int bps=field.bytesPerSite();
 bool dp=(field.bytesPerWord()==sizeof(std::complex<double>));
 int nelem=field.elemsPerSite();
 for (int dir=0;dir<LayoutInfo::Ndim;++dir){
    xstart[dir]=comm_coord[dir]*N[dir];
    xstop[dir]=xstart[dir]+N[dir];}
 char* fp=field.getDataPtr();
 for (int par=0;par<2;++par){
    for (x[3]=xstart[3];x[3]<xstop[3];++x[3]){
       for (x[2]=xstart[2];x[2]<xstop[2];++x[2]){
          for (x[1]=xstart[1];x[1]<xstop[1];++x[1]){
             for (x[0]=xstart[0];x[0]<xstop[0];++x[0]){
                if (((x[0]+x[1]+x[2]+x[3])%2)==par){
                   int ival=x[0]+GN[0]*(x[1]+GN[1]*(x[2]+GN[2]*x[3]));
                   if (dp){
                      complex<double>* dt=reinterpret_cast<complex<double>*>(fp);
                      double rval=double(ival);
                      complex<double> zval(rval,rval);
                      for (int k=0;k<nelem;++k,++dt){*dt=zval;}}
                   else{
                      complex<float>* dt=reinterpret_cast<complex<float>*>(fp);
                      float rval=float(ival);
                      complex<float> zval(rval,rval);
                      for (int k=0;k<nelem;++k,++dt){*dt=zval;}}
                   fp+=bps;}}}}}}
}


   // assigns y[d] from x[d]; if d==dir, y[d]=(x[d]+1) % N[d]

void index_increaser(int dir, int d, vector<int>& y, const vector<int>& x, 
                     const vector<int>& N)
{
 if (dir==d){ y[d]=(x[d]==(N[d]-1))?0:x[d]+1;}
 else{ y[d]=x[d];}
}

   // assigns y[d] from x[d]; if d==dir, y[d]=(x[d]-1+N[d]) % N[d]

void index_decreaser(int dir, int d, vector<int>& y, const vector<int>& x, 
                     const vector<int>& N)
{
 if (dir==d){ y[d]=(x[d]==0)?N[d]-1:x[d]-1;}
 else{ y[d]=x[d];}
}


#ifdef ARCH_SERIAL


      //  This routine is slow: meant only for debugging, testing
      //   outfield(x) <=  infield(x+dir)  if fwd_or_bwd=='F'
      //   outfield(x) <=  infield(x-dir)  if fwd_or_bwd=='B'

      // linear index for site (x,y,z,t) is
      //      (x+Nx*(y+Ny*(z+Nz*t)))/2 + (nsites/2)*((x+y+z+t)%2);

void latt_shifter(LattField& outfield, const LattField& infield, int dir, 
                 void (*indexfunc)(int,int,vector<int>&,const vector<int>&, 
                                   const vector<int>&))
{
 if ((dir<0)||(dir>3)){
    errorLaph("Invalid direction in lattice field shift");}
 outfield.reset(infield.getFieldSiteType());
 const vector<int>& N=LayoutInfo::getLattSizes();
 int nsites=LayoutInfo::getLatticeNumSites();
 int npsites=nsites/2;
 int bps=infield.bytesPerSite();
 char* oute=outfield.getDataPtr();
 char* outo=oute+npsites*bps;
 const char* ine=infield.getDataConstPtr();
 const char* ino=ine+npsites*bps;
 vector<int> x(LayoutInfo::Ndim);
 vector<int> y(LayoutInfo::Ndim);
 for (x[3]=0;x[3]<N[3];++x[3]){
    indexfunc(dir,3,y,x,N);
    for (x[2]=0;x[2]<N[2];++x[2]){
       indexfunc(dir,2,y,x,N);
       for (x[1]=0;x[1]<N[1];++x[1]){
          indexfunc(dir,1,y,x,N);
          for (x[0]=0;x[0]<N[0];++x[0]){
             indexfunc(dir,0,y,x,N);
             int shift=bps*((y[0]+N[0]*(y[1]+N[1]*(y[2]+N[2]*y[3])))/2);
             if ((x[0]+x[1]+x[2]+x[3])%2){
                const char* inp=ine+shift;
                std::memcpy(outo,inp,bps);
                outo+=bps;}
             else{
                const char* inp=ino+shift;
                std::memcpy(oute,inp,bps);
                oute+=bps;}}}}}
}

      //  This routine is slow: meant only for debugging, testing
      //   outfield(x) <=  infield(x+dir)  if fwd_or_bwd=='F'
      //   outfield(x) <=  infield(x-dir)  if fwd_or_bwd=='B'

void lattice_shift(LattField& outfield, const LattField& infield, int dir, char fwd_or_bwd)
{
 if (fwd_or_bwd=='F'){
    latt_shifter(outfield,infield,dir,&index_increaser);}
 else if (fwd_or_bwd=='B'){
    latt_shifter(outfield,infield,dir,&index_decreaser);}
 else{
    errorLaph("lattice shift needs F or B for forward/backward");}
}


#else                // parallel version now


bool fwd_stay_local(int dir, const vector<int>& x, const vector<int>& N, bool nocomm)
{
 if (x[dir]<(N[dir]-1)) return true;
 return nocomm;
}

bool bwd_stay_local(int dir, const vector<int>& x, const vector<int>& N, bool nocomm)
{
 if (x[dir]>0) return true;
 return nocomm;
}


void get_fwd_comm_to_from(int dir, int& send_to, int& recv_from)
{
 vector<int> rank_coord(LayoutInfo::getMyCommCoords());  // rank coords of this node
       // get mpi rank where to send
 if (rank_coord[dir]>0) rank_coord[dir]--;
 else rank_coord[dir]=LayoutInfo::getCommNumPartitions()[dir]-1;
 send_to=LayoutInfo::getRankFromCommCoords(rank_coord);
       // get mpi rank where to receive from
 rank_coord=LayoutInfo::getMyCommCoords();
 rank_coord[dir]++;
 if (rank_coord[dir]==LayoutInfo::getCommNumPartitions()[dir]) rank_coord[dir]=0;
 recv_from=LayoutInfo::getRankFromCommCoords(rank_coord);
}

void get_bwd_comm_to_from(int dir, int& send_to, int& recv_from)
{
 vector<int> rank_coord(LayoutInfo::getMyCommCoords());  // rank coords of this node
       // get mpi rank where to receive from
 if (rank_coord[dir]>0) rank_coord[dir]--;
 else rank_coord[dir]=LayoutInfo::getCommNumPartitions()[dir]-1;
 recv_from=LayoutInfo::getRankFromCommCoords(rank_coord);
       // get mpi rank where to send
 rank_coord=LayoutInfo::getMyCommCoords();
 rank_coord[dir]++;
 if (rank_coord[dir]==LayoutInfo::getCommNumPartitions()[dir]) rank_coord[dir]=0;
 send_to=LayoutInfo::getRankFromCommCoords(rank_coord);
}


      //  This routine is slow: meant only for debugging, testing
      //   outfield(x) <=  infield(x+dir)  if fwd_or_bwd=='F'
      //   outfield(x) <=  infield(x-dir)  if fwd_or_bwd=='B'

      // linear index for site (x,y,z,t) is
      //      (x+Nx*(y+Ny*(z+Nz*t)))/2 + (nsites/2)*((x+y+z+t)%2);


//  WRONG FOR THE FOLLOWING CASES:  O=odd, E=even  sites in each rank

//    NX  NY  NZ  NT
//     O   E   E   E    x-dir wrong
//     O   O   E   E    x,y-dirs wrong
//     O   E   O   E    x-dir wrong
//     O   E   E   O    x-dir wrong
//     O   O   O   E    x,y,z dir wrong
//     O   O   E   O    x,y dirs wrong
//     O   E   O   O    x-dir wrong


void latt_shifter(LattField& outfield, const LattField& infield, int dir, 
                 void (*indexfunc)(int,int,vector<int>&,const vector<int>&, 
                                   const vector<int>&),
                 bool (*staylocal)(int,const vector<int>&,const vector<int>&,bool),
                 void (*neighbors)(int,int&,int&))
{
 int start_parity=LayoutInfo::getMyStartParity();
 if ((dir<0)||(dir>3)){
    errorLaph("Invalid direction in lattice field shift");}
 outfield.reset(infield.getFieldSiteType());
 const vector<int>& N=LayoutInfo::getRankLattSizes();
 int nsites=LayoutInfo::getRankLatticeNumSites();
 int npsites=nsites/2;
 int bps=infield.bytesPerSite();
 char* oute=outfield.getDataPtr();
 char* outo=oute+npsites*bps;
 const char* ine=infield.getDataConstPtr();
 const char* ino=ine+npsites*bps;
 vector<int> x(LayoutInfo::Ndim);
 vector<int> y(LayoutInfo::Ndim);
 bool needcomm=(LayoutInfo::getCommNumPartitions()[dir]>1);
 bool nocm=!needcomm;
 vector<char> sendbuffer,recvbuffer;
 char *snde=0;
 char *sndo=0;
 int nbuf=0;
 bool nospflip=((N[dir]%2)==0); //nospflip=true;
 if (needcomm){
    nbuf=nsites/N[dir]; nbuf+=nbuf%2;
    sendbuffer.resize(nbuf*bps);
    recvbuffer.resize(nbuf*bps);
    snde=sendbuffer.data();
    sndo=snde+(nbuf/2)*bps;
    if (!nospflip){
       sndo=sendbuffer.data();
       snde=sndo+(nbuf/2)*bps;}}


        // make local changes and put data in send buffer

//printLaph("Doing local shift and filling send buffer if necessary");
/*
cout << "Hello from node "<<LayoutInfo::getMyRank()<<" my start parity is "<<LayoutInfo::getMyStartParity()<<endl;

string sendfileelog("sendfileelog"); sendfileelog+=make_string(LayoutInfo::getMyRank());
ofstream foute(sendfileelog);
string sendfileolog("sendfileolog"); sendfileolog+=make_string(LayoutInfo::getMyRank());
ofstream fouto(sendfileolog);
vector<int> x0(4);
for (int k=0;k<4;++k) x0[k]=LayoutInfo::getMyCommCoords()[k]*LayoutInfo::getRankLattSizes()[k];
*/


 for (x[3]=0;x[3]<N[3];++x[3]){
    indexfunc(dir,3,y,x,N);
    for (x[2]=0;x[2]<N[2];++x[2]){
       indexfunc(dir,2,y,x,N);
       for (x[1]=0;x[1]<N[1];++x[1]){
          indexfunc(dir,1,y,x,N);
          for (x[0]=0;x[0]<N[0];++x[0]){
             indexfunc(dir,0,y,x,N);
             int site_parity=(start_parity+x[0]+x[1]+x[2]+x[3])%2;
             int shift=bps*((y[0]+N[0]*(y[1]+N[1]*(y[2]+N[2]*y[3])))/2);
             if (site_parity){
                if (staylocal(dir,x,N,nocm)){ const char* inp=ine+shift; std::memcpy(outo,inp,bps);}
                else{                 const char* inp=(nospflip?ine:ino)+shift;
/*fouto << "x=("<<x0[0]+x[0]<<","<<x0[1]+x[1]<<","<<x0[2]+x[2]<<","<<x0[3]+x[3]<<") ";
                      fouto << "y=("<<x0[0]+y[0]<<","<<x0[1]+y[1]<<","<<x0[2]+y[2]<<","<<x0[3]+y[3]<<") ";   


                     const complex<double>* tmp=reinterpret_cast<const complex<double>*>(inp);

    int gival=round(tmp->real());
    vector<int> gs(4);
    gs[0]=gival % N[0]; int gb=(gival-gs[0])/N[0];
    gs[1]=gb % N[1];  gb=(gb-gs[1])/N[1];
    gs[2]=gb % N[2];  gs[3]=(gb-gs[2])/N[2];
    fouto << "("<<gs[0]<<","<<gs[1]<<","<<gs[2]<<","<<gs[3]<<")"<<endl;
*/

                            std::memcpy(sndo,inp,bps);sndo+=bps;}
                outo+=bps;}
             else{
                
                if (staylocal(dir,x,N,nocm)){ const char* inp=ino+shift; std::memcpy(oute,inp,bps);}
                else{ const char* inp=(nospflip?ino:ine)+shift; /* foute << "x=("<<x0[0]+x[0]<<","<<x0[1]+x[1]<<","<<x0[2]+x[2]<<","<<x0[3]+x[3]<<") ";
                      foute << "y=("<<x0[0]+y[0]<<","<<x0[1]+y[1]<<","<<x0[2]+y[2]<<","<<x0[3]+y[3]<<") ";  
                     const complex<double>* tmp=reinterpret_cast<const complex<double>*>(inp);

    int gival=round(tmp->real());
    vector<int> gs(4);
    gs[0]=gival % N[0]; int gb=(gival-gs[0])/N[0];
    gs[1]=gb % N[1];  gb=(gb-gs[1])/N[1];
    gs[2]=gb % N[2];  gs[3]=(gb-gs[2])/N[2];
    foute << "("<<gs[0]<<","<<gs[1]<<","<<gs[2]<<","<<gs[3]<<")"<<endl;
*/

                      std::memcpy(snde,inp,bps);snde+=bps;}
                oute+=bps;}}}}}
/*
foute.close();
fouto.close();

sendfileelog="sendfileall"; sendfileelog+=make_string(LayoutInfo::getMyRank());
ofstream foutall(sendfileelog);
complex<double> *fptr=reinterpret_cast<complex<double>*>(sendbuffer.data());
for (int k=0;k<nbuf;++k,++fptr){
    int ival=round(fptr->real());
    vector<int> s(4);
    s[0]=ival % N[0]; int b=(ival-s[0])/N[0];
    s[1]=b % N[1];  b=(b-s[1])/N[1];
    s[2]=b % N[2];  s[3]=(b-s[2])/N[2];
    foutall << "("<<s[0]<<","<<s[1]<<","<<s[2]<<","<<s[3]<<")"<<endl;}
foutall.close();
*/








 if (!needcomm){
    return;}

//printLaph("Doing the communication");

      // do the communication (send and receive) 
 int send_to=0;
 int recv_from=0;
 neighbors(dir,send_to,recv_from);


//std::cout << "my rank is "<<LayoutInfo::getMyRank()<<" sendto="<<send_to<<"with tag="
//          << LayoutInfo::getMyRank()<<" recvfrom="<<recv_from<<" with tag="<<recv_from<<endl;

 MPI_Status mpistatus;
 int status=MPI_Sendrecv(sendbuffer.data(), nbuf*bps, MPI_BYTE, send_to, LayoutInfo::getMyRank(), 
                         recvbuffer.data(), nbuf*bps, MPI_BYTE, recv_from, recv_from, 
                         MPI_COMM_WORLD, &mpistatus);
 if (status!=MPI_SUCCESS){
    errorLaph("Error in communication while doing shift");}

     // put data received into local memory appropriately

//printLaph("Completing shift from the receive buffer");

/*
sendfileelog="recvfileall"; sendfileelog+=make_string(LayoutInfo::getMyRank());
ofstream foutall2(sendfileelog);
fptr=reinterpret_cast<complex<double>*>(recvbuffer.data());
for (int k=0;k<nbuf;++k,++fptr){
    int ival=round(fptr->real());
    vector<int> s(4);
    s[0]=ival % N[0]; int b=(ival-s[0])/N[0];
    s[1]=b % N[1];  b=(b-s[1])/N[1];
    s[2]=b % N[2];  s[3]=(b-s[2])/N[2];
    foutall2 << "("<<s[0]<<","<<s[1]<<","<<s[2]<<","<<s[3]<<")"<<endl;}
foutall2.close();
*/


 sendbuffer.clear();
 oute=outfield.getDataPtr();
 outo=oute+npsites*bps;
 const char* rcve=recvbuffer.data();
 const char* rcvo=rcve+(nbuf/2)*bps;
   // switch if start_parity of receive rank different and dir==0
// if ((dir==0)&&(N[dir]%2)){
//    rcvo=rcve;
//    rcve=rcvo+(nbuf/2)*bps;}
 for (x[3]=0;x[3]<N[3];++x[3]){
    for (x[2]=0;x[2]<N[2];++x[2]){
       for (x[1]=0;x[1]<N[1];++x[1]){
          for (x[0]=0;x[0]<N[0];++x[0]){
             if ((start_parity+x[0]+x[1]+x[2]+x[3])%2){
                if (!staylocal(dir,x,N,nocm)){ std::memcpy(outo,rcvo,bps); rcvo+=bps;}
                outo+=bps;}
             else{
                if (!staylocal(dir,x,N,nocm)){ std::memcpy(oute,rcve,bps); rcve+=bps;}
                oute+=bps;}}}}}
}

     //  This routine is slow: meant only for debugging, testing
      //   outfield(x) <=  infield(x+dir)  if fwd_or_bwd=='F'
      //   outfield(x) <=  infield(x-dir)  if fwd_or_bwd=='B'

void lattice_shift(LattField& outfield, const LattField& infield, int dir, char fwd_or_bwd)
{
 if (fwd_or_bwd=='F'){
    latt_shifter(outfield,infield,dir,&index_increaser,&fwd_stay_local,&get_fwd_comm_to_from);}
 else if (fwd_or_bwd=='B'){
    latt_shifter(outfield,infield,dir,&index_decreaser,&bwd_stay_local,&get_bwd_comm_to_from);}
 else{
    errorLaph("lattice shift needs F or B for forward/backward");}
 MPI_Barrier(MPI_COMM_WORLD);
}


#endif 


void check_shift_forward(LattField& outfield, const LattField& infield, int dir)
{
 bool flag=true;
 int nelem=infield.elemsPerSite();
 if (nelem!=int(outfield.elemsPerSite())){ flag=false;}
 else{
 vector<int> coord(LayoutInfo::Ndim);
 for (coord[3]=0;coord[3]<LayoutInfo::getLattSizes()[3];++coord[3])
 for (coord[2]=0;coord[2]<LayoutInfo::getLattSizes()[2];++coord[2])
 for (coord[1]=0;coord[1]<LayoutInfo::getLattSizes()[1];++coord[1])
 for (coord[0]=0;coord[0]<LayoutInfo::getLattSizes()[0];++coord[0]){
    vector<char> outsitedata(outfield.getSiteData(coord));
    vector<int> shifted(coord);
    shifted[dir]++;
    if (shifted[dir]==LayoutInfo::getLattSizes()[dir]){
       shifted[dir]=0;}
    vector<char> insitedata(infield.getSiteData(shifted));
    //printLaph(make_strf("shifted site (%d %d %d %d)\n",coord[0],coord[1],coord[2],coord[3]));
    flag=flag && compare_sites(outsitedata,insitedata,nelem);}}
 if (flag) printLaph("Shift checks OK");
 else printLaph("Shift is WRONG");
}
    
void check_shift_backward(LattField& outfield, const LattField& infield, int dir)
{
 bool flag=true;
 int nelem=infield.elemsPerSite();
 if (nelem!=int(outfield.elemsPerSite())){ flag=false;}
 else{
 vector<int> coord(LayoutInfo::Ndim);
 for (coord[3]=0;coord[3]<LayoutInfo::getLattSizes()[3];++coord[3])
 for (coord[2]=0;coord[2]<LayoutInfo::getLattSizes()[2];++coord[2])
 for (coord[1]=0;coord[1]<LayoutInfo::getLattSizes()[1];++coord[1])
 for (coord[0]=0;coord[0]<LayoutInfo::getLattSizes()[0];++coord[0]){
    vector<char> outsitedata(outfield.getSiteData(coord));
    vector<int> shifted(coord);
    if (shifted[dir]==0){
       shifted[dir]=LayoutInfo::getLattSizes()[dir]-1;}
    else{
       --shifted[dir];}
    vector<char> insitedata(infield.getSiteData(shifted));
    flag=flag && compare_sites(outsitedata,insitedata,nelem);}}
 if (flag) printLaph("Shift checks OK");
 else printLaph("Shift is WRONG");
}
    

void checkShift(LattField& outfield, const LattField& infield, int dir, char fwd_or_bwd)
{
  if (fwd_or_bwd=='F'){
    check_shift_forward(outfield,infield,dir);}
 else if (fwd_or_bwd=='B'){
    check_shift_backward(outfield,infield,dir);}
 else{
    errorLaph("lattice shift needs F or B for forward/backward");}
}




void testShift(XMLHandler& xml_in)
{
 if (xml_tag_count(xml_in,"TestShift")==0)
 return;

 uint MTseed1=0, MTseed2;
 XMLHandler xmlr(xml_in,"TestShift");
 xmlreadif(xmlr,"MTSeed1",MTseed1,"TestClover");
 xmlreadif(xmlr,"MTSeed2",MTseed2,"TestClover");
 double minval=-10.0;
 double maxval=10.0;
 xmlreadif(xmlr,"MinValue",minval,"TestClover");
 xmlreadif(xmlr,"MaxValue",maxval,"TestClover");

 printLaph(make_strf("MTSeed1 is %d",MTseed1));
 printLaph(make_strf("MTSeed2 is %d",MTseed2));
 printLaph(make_strf("MinValue is %f",minval));
 printLaph(make_strf("MaxValue is %f",maxval));

 LattField FC(FieldSiteType::Complex);
// setUnitField(FC);
// printFieldToFile(FC,"Should be unit field","UnitField");
// setZeroField(FC);
// printFieldToFile(FC,"Should be zero field","ZeroField");
// setConstantField(FC,complex<double>(2.0,0.5));
// printFieldToFile(FC,"Should be constant field with value (2.0,0.5)","ConstField");
 setFieldLexicoIndex(FC);
// printFieldToFile(FC,"Lexico values","LexicoField");

 for (int dir=0;dir<4;dir++){
    printLaph(make_str("Doing a forward shift of Complex Lexico in dir ",dir));
    LattField FS(FieldSiteType::ColorVector);
    lattice_shift(FS,FC,dir,'F');
    checkShift(FS,FC,dir,'F');}
 for (int dir=0;dir<4;dir++){
    printLaph(make_str("Doing a backward shift of Complex Lexico in dir ",dir));
    LattField FS(FieldSiteType::ColorVector);
    lattice_shift(FS,FC,dir,'B');
    checkShift(FS,FC,dir,'B');}


 printLaph("Doing a Lattice color vector assignment");
 bool random=true;
 LatticeAssigner LA(MTseed1,minval,maxval,random);
 LattField F1(FieldSiteType::ColorVector);
 LA.assign_field(F1,"ColorVectorField");
 LattField F2(FieldSiteType::ColorSpinVector);
 LA.reSeed(MTseed2);
 LA.assign_field(F2,"ColorVectorField");

 for (int dir=0;dir<4;dir++){
    printLaph(make_str("Doing a forward shift of ColorVectorField in dir ",dir));
    LattField FS(FieldSiteType::ColorVector);
    lattice_shift(FS,F1,dir,'F');
    checkShift(FS,F1,dir,'F');}
 for (int dir=0;dir<4;dir++){
    printLaph(make_str("Doing a backward shift of ColorVectorField in dir ",dir));
    LattField FS(FieldSiteType::ColorVector);
    lattice_shift(FS,F1,dir,'B');
    checkShift(FS,F1,dir,'B');}
 for (int dir=0;dir<4;dir++){
    printLaph(make_str("Doing a forward shift of ColorSpinVectorField in dir ",dir));
    LattField FS(FieldSiteType::ColorSpinVector);
    lattice_shift(FS,F2,dir,'F');
    checkShift(FS,F2,dir,'F');}
 for (int dir=0;dir<4;dir++){
    printLaph(make_str("Doing a backward shift of ColorSpinVectorField in dir ",dir));
    LattField FS(FieldSiteType::ColorSpinVector);
    lattice_shift(FS,F2,dir,'B');
    checkShift(FS,F2,dir,'B');} 
}


    //  Lattice-site-wise color-matrix multiplies outfield = fieldL * fieldR
    //  Any spin indices go along untouched.

void su3_mult(LattField& outfield, const LattField& fieldL, const LattField& fieldR)
{}

    //  Lattice-site-wise color-matrix multiplies outfield = colorAdj(fieldL) * fieldR
    //  Any spin indices go along untouched.

void su3adj_mult(LattField& outfield, const LattField& fieldL, const LattField& fieldR)
{}



    //   outfield(x) <=  U_dir(x) infield(x+mu)            if fwd_or_bwd=='F'
    //   outfield(x) <=  U^dag_dir(x-mu) infield(x-mu)     if fwd_or_bwd=='B'

    //   for 'F', su3mult( U[dir], shift(infield, mu, 'F') )
    //   for 'B', shift(  su3mult( adj(U[dir]), infield ), mu, 'B')

void lattice_cov_shift(LattField& outfield, const LattField& infield, const vector<LattField>& gauge_field,
                       int dir, char fwd_or_bwd)
{
 LattField tmp(FieldSiteType::ColorSpinVector);
 if (fwd_or_bwd=='F'){ 
    lattice_shift(tmp,infield,dir,'F');
    su3_mult(outfield,gauge_field[dir],tmp);}
 else if (fwd_or_bwd=='B'){
    su3adj_mult(tmp,gauge_field[dir],infield);
    lattice_shift(outfield,tmp,dir,'B');}
 else{
    errorLaph("lattice shift needs F or B for forward/backward");}
}


template <typename T>
void su3mult(complex<T>* prod, const complex<T>* link1, const complex<T>* link2)
{
 complex<T>* res=prod;
 for (int i=0;i<3;++i)
 for (int j=0;j<3;++j,++res){
    *res=complex<T>(0.0,0.0);
    const complex<T>* l1=link1+3*i;
    const complex<T>* l2=link2+j;
    for (int k=0;k<3;++k,++l1,l2+=3){
       *res+=(*l1)*(*l2);}}
}

void su3mult(vector<char>& prod, const vector<char>& link1, const vector<char>& link2, bool dp)
{
 if (dp){
    su3mult<double>(reinterpret_cast<complex<double>*>(prod.data()),
                    reinterpret_cast<const complex<double>*>(link1.data()),
                    reinterpret_cast<const complex<double>*>(link2.data()));}
else{
    su3mult<float>(reinterpret_cast<complex<float>*>(prod.data()),
                    reinterpret_cast<const complex<float>*>(link1.data()),
                    reinterpret_cast<const complex<float>*>(link2.data()));}
}

void extend(vector<char>& path, const vector<char>& link, bool dp)
{
 vector<char> tmp(link.size());
 su3mult(tmp,path,link,dp);
 path=tmp;
}

template <typename T>
void hc_assign(complex<T>* outlink, const complex<T>* inlink)
{
 complex<T>* res=outlink;
 for (int i=0;i<3;++i){
    const complex<T>* in=inlink+i;
 for (int j=0;j<3;++j,++res,in+=3){
    *res+=std::conj(*in);}}
}

void hc_assign(vector<char>& outlink, const vector<char>& inlink, bool dp)
{
 if (dp){
    hc_assign(reinterpret_cast<complex<double>*>(outlink.data()),
              reinterpret_cast<const complex<double>*>(inlink.data()));}
 else{
    hc_assign(reinterpret_cast<complex<float>*>(outlink.data()),
              reinterpret_cast<const complex<float>*>(inlink.data()));}
}

void hc_extend(vector<char>& path, const vector<char>& link, bool dp)
{
 vector<char> tmp(link.size());
 hc_assign(tmp,link,dp);
 su3mult(path,tmp,link,dp);
}

void start_path(vector<char>& path, int dir, bool forward, vector<int>& coord, 
                const vector<LattField>& gauge_field, bool dp)
{
 if (forward){
    path=gauge_field[dir].getSiteData(coord);
    if (coord[dir]<(LayoutInfo::getLattSizes()[dir]-1)){
       coord[dir]+=1;}
    else{
       coord[dir]=0;}}
 else{
    if (coord[dir]==0){
       coord[dir]=(LayoutInfo::getLattSizes()[dir]-1);}
    else{
       coord[dir]-=1;}
    hc_assign(path,gauge_field[dir].getSiteData(coord),dp);}
} 
    
void extend_path(vector<char>& path, int dir, bool forward, vector<int>& coord, 
                 const vector<LattField>& gauge_field, bool dp)
{
 if (forward){
    extend(path,gauge_field[dir].getSiteData(coord),dp);
    if (coord[dir]<(LayoutInfo::getLattSizes()[dir]-1)){
       coord[dir]+=1;}
    else{
       coord[dir]=0;}}
 else{
    if (coord[dir]==0){
       coord[dir]=(LayoutInfo::getLattSizes()[dir]-1);}
    else{
       coord[dir]-=1;}
    hc_extend(path,gauge_field[dir].getSiteData(coord),dp);}
}

template <typename T>
void add_to(complex<T>* result, const complex<T>* link, const complex<T>& coef)
{
 complex<T>* res=result;
 const complex<T>* l=link;
 for (int k=0;k<9;++k,++res,++l){
    *res+=coef*(*l);}
}

void add_to(vector<char>& linksum, const vector<char>& link, const complex<double>& coef, bool dp)
{
 if (dp){
    add_to(reinterpret_cast<complex<double>*>(linksum.data()),
           reinterpret_cast<const complex<double>*>(link.data()),coef);}
 else{
    complex<float> zcf(real(coef),imag(coef));
    add_to(reinterpret_cast<complex<float>*>(linksum.data()),
           reinterpret_cast<const complex<float>*>(link.data()),zcf);}
}

template <typename T>
void assign_zero(complex<T>* link)
{
 complex<T>* res=link;
 for (int i=0;i<9;++i,++res){
    *res=complex<T>(0.0,0.0);}
}

void assign_zero(vector<char>& link, bool dp)
{
 if (dp){
    assign_zero(reinterpret_cast<complex<double>*>(link.data()));}
 else{
    assign_zero(reinterpret_cast<complex<float>*>(link.data()));}
}


void calcQmunu(vector<char>& siteData, int mu, int nu, const std::vector<LattField>& gauge_field,
               const vector<int>& coord, bool dp)
{
 vector<char> path(siteData.size());
 vector<int> current(coord);
 start_path(path,mu,true,current,gauge_field,dp);
 extend_path(path,nu,true,current,gauge_field,dp);
 extend_path(path,mu,false,current,gauge_field,dp);
 extend_path(path,nu,false,current,gauge_field,dp);

 vector<char> path2(siteData.size());
 current=coord;
 start_path(path2,nu,true,current,gauge_field,dp);
 extend_path(path2,mu,false,current,gauge_field,dp);
 extend_path(path2,nu,false,current,gauge_field,dp);
 extend_path(path2,mu,true,current,gauge_field,dp);

 vector<char> path3(siteData.size());
 current=coord;
 start_path(path3,mu,false,current,gauge_field,dp);
 extend_path(path3,nu,false,current,gauge_field,dp);
 extend_path(path3,mu,true,current,gauge_field,dp);
 extend_path(path3,nu,true,current,gauge_field,dp);

 vector<char> path4(siteData.size());
 current=coord;
 start_path(path4,nu,false,current,gauge_field,dp);
 extend_path(path4,mu,true,current,gauge_field,dp);
 extend_path(path4,nu,true,current,gauge_field,dp);
 extend_path(path4,mu,false,current,gauge_field,dp);

 siteData=path;
 add_to(siteData,path2,complex<double>(1.0,0.0),dp);
 add_to(siteData,path3,complex<double>(1.0,0.0),dp);
 add_to(siteData,path4,complex<double>(1.0,0.0),dp);
}

void calcFmunu(vector<char>& siteData, int mu, int nu, const std::vector<LattField>& gauge_field,
               const vector<int>& coord, bool dp)
{
 vector<char> path1(siteData.size());
 calcQmunu(path1,mu,nu,gauge_field,coord,dp);
 vector<char> path2(siteData.size());
 calcQmunu(path2,nu,mu,gauge_field,coord,dp);
 assign_zero(siteData,dp);
 add_to(siteData,path1,complex<double>(0.0,-1.0/8.0),dp);
 add_to(siteData,path2,complex<double>(0.0,1.0/8.0),dp);
}



void calcFmunu(LattField& Fmunu, int mu, int nu, const std::vector<LattField>& gauge_field)
{
 Fmunu.reset(FieldSiteType::ColorMatrix);
 bool dp=(gauge_field[0].bytesPerWord()==sizeof(complex<double>)); 
// int nelem_site=gauge_field[0].elemsPerSite();
 vector<char> siteData(gauge_field[0].bytesPerSite());
 vector<int> coord(LayoutInfo::Ndim);
 for (coord[3]=0;coord[3]<LayoutInfo::getLattSizes()[3];++coord[3])
 for (coord[2]=0;coord[2]<LayoutInfo::getLattSizes()[2];++coord[2])
 for (coord[1]=0;coord[1]<LayoutInfo::getLattSizes()[1];++coord[1])
 for (coord[0]=0;coord[0]<LayoutInfo::getLattSizes()[0];++coord[0]){
    calcFmunu(siteData,mu,nu,gauge_field,coord,dp);
    Fmunu.putSiteData(coord,siteData);}
}

   //   NEVER TESTED THIS ROUTINE
/*
void testClover(XMLHandler& xml_in)
{
 if (xml_tag_count(xml_in,"TestClover")==0)
 return;

 uint MTseed1=0, MTseed2=0, MTseed3=0, MTseed4=0;
 XMLHandler xmlr(xml_in,"TestClover");
 xmlreadif(xmlr,"MTSeed1",MTseed1,"TestClover");
 xmlreadif(xmlr,"MTSeed2",MTseed2,"TestClover");
 xmlreadif(xmlr,"MTSeed3",MTseed3,"TestClover");
 xmlreadif(xmlr,"MTSeed4",MTseed4,"TestClover");
 double minval=-10.0;
 double maxval=10.0;
 xmlreadif(xmlr,"MinValue",minval,"TestClover");
 xmlreadif(xmlr,"MaxValue",maxval,"TestClover");

 printLaph(make_strf("MTSeed1 is %d",MTseed1));
 printLaph(make_strf("MTSeed2 is %d",MTseed2));
 printLaph(make_strf("MTSeed3 is %d",MTseed3));
 printLaph(make_strf("MTSeed4 is %d",MTseed4));
 printLaph(make_strf("MinValue is %f",minval));
 printLaph(make_strf("MaxValue is %f",maxval));

 printLaph("Doing a gauge field assignment");
 GaugeFieldAssigner GC(MTseed1,MTseed2,MTseed3,MTseed4);
 vector<LattField> GF;
 GC.assign_gauge_field(GF,"GaugeField1");

 printLaph("Now starting computation of the clover field\n");
 LattField Fmunu;
 printLaph("Computing F[mu,nu] for mu=1 and nu=2\n");
 int mu=1; int nu=2;

// vector<int> coord(4); coord[0]=3; coord[1]=2; coord[2]=4; coord[3]=5;
// vector<char> siteData(GF[0].bytesPerSite());
// calcFmunu(siteData,mu,nu,GF,coord,true);
 
// complex<double>* z=reinterpret_cast<complex<double>*>(siteData.data());
// for (int k=0;k<9;++k,++z){
//    printLaph(make_str("z[",k,"] = ",*z));}

 calcFmunu(Fmunu,mu,nu,GF);
 printField(Fmunu,"F[mu,nu] mu=1 nu=2");

}
*/

// ***********************************************
}
#endif
