#include "quark_handler.h"
#include "multi_compare.h"
#include "array.h"
#include "stop_watch.h"

#if defined(USE_GSL_CBLAS)
#include "gsl_cblas.h"
#elif defined(USE_OPENBLAS)
#include "cblas.h"
#endif


#include "task_tests.h"
using namespace QLTestEnv;


using namespace std;

typedef std::complex<double> dcmplx;
typedef std::complex<float>  fcmplx;

namespace LaphEnv {
   
// *************************************************************************

void QuarkHandler::RecordKey::output(XMLHandler& xmlw) const 
{
 xmlw.set_root("RecordKey");
 xmlw.put_child("Spin",make_string(getSpin()));
 xmlw.put_child("Time",make_string(getTime()));
 xmlw.put_child("SpinLaphEigvecIndex",make_string(getSpinLaphEigvecIndex()));
}

// *************************************************************************


QuarkHandler::FileKey::FileKey(const LaphNoiseInfo& in_noise, int tprojind)
    : noise(in_noise), time_proj_index(tprojind) {}

QuarkHandler::FileKey::FileKey(XMLHandler& xmlr)
{
 try{
    XMLHandler xmlf(xmlr,"FileKey");
    noise=LaphNoiseInfo(xmlf);
    xmlread(xmlf,"TimeProjectorIndex",time_proj_index,"QuarkHandler::FileKey");}
 catch(const std::exception& xp){
    errorLaph("Could not read QuarkHandler::FileKey");}
}

QuarkHandler::FileKey::FileKey(const FileKey& rhs)
    : noise(rhs.noise), time_proj_index(rhs.time_proj_index) {}

QuarkHandler::FileKey& QuarkHandler::FileKey::operator=(const FileKey& rhs)
{
 noise=rhs.noise;
 time_proj_index=rhs.time_proj_index;
 return *this;
}

void QuarkHandler::FileKey::output(XMLHandler& xmlw) const
{
 xmlw.set_root("FileKey");
 XMLHandler xmln;
 noise.output(xmln);
 xmlw.put_child(xmln);
 xmlw.put_child("TimeProjectorIndex",make_string(time_proj_index));
}

bool QuarkHandler::FileKey::operator<(const FileKey& rhs) const
{
 return multiLessThan(time_proj_index,rhs.time_proj_index,  noise,rhs.noise);
}

bool QuarkHandler::FileKey::operator==(const FileKey& rhs) const
{
 return multiEqual(time_proj_index,rhs.time_proj_index,  noise,rhs.noise);
}

bool QuarkHandler::FileKey::operator!=(const FileKey& rhs) const
{
 return multiNotEqual(time_proj_index,rhs.time_proj_index,  noise,rhs.noise);
}

// *************************************************************************


QuarkHandler::StorageKey::StorageKey(const FileKey& in_fkey, 
                                     const RecordKey& in_stkey,
                                     const DirPath& in_disp, int in_disp_length)
    : fkey(in_fkey), rkey(in_stkey), disp(in_disp), 
      disp_length(in_disp_length)
{
 if (disp.Length()==0) disp_length=0;
 if ((disp.Length()>0)&&(disp_length<=0)){
    errorLaph("Invalid displacement length");}
}

QuarkHandler::StorageKey::StorageKey(const FileKey& in_fkey, 
                                     const RecordKey& in_stkey)
    : fkey(in_fkey), rkey(in_stkey), disp_length(0)
{}

QuarkHandler::StorageKey::StorageKey(
           const QuarkHandler::StorageKey& in)
    : fkey(in.fkey), rkey(in.rkey), disp(in.disp), 
      disp_length(in.disp_length) {}


QuarkHandler::StorageKey& QuarkHandler::StorageKey::operator=(
        const QuarkHandler::StorageKey& in)
{
 fkey=in.fkey;
 rkey=in.rkey;
 disp=in.disp;
 disp_length=in.disp_length;
 return *this;
}

bool QuarkHandler::StorageKey::operator<(const QuarkHandler::StorageKey& rhs) const
{
 return multiLessThan(rkey,rhs.rkey,  disp,rhs.disp,  
                      disp_length,rhs.disp_length,  fkey,rhs.fkey);
}

bool QuarkHandler::StorageKey::operator==(const QuarkHandler::StorageKey& rhs) const
{
 return multiEqual(rkey,rhs.rkey,  disp,rhs.disp,  
                   disp_length,rhs.disp_length,  fkey,rhs.fkey);
}

bool QuarkHandler::StorageKey::operator!=(const QuarkHandler::StorageKey& rhs) const
{
 return multiNotEqual(rkey,rhs.rkey,  disp,rhs.disp,  
                      disp_length,rhs.disp_length,  fkey,rhs.fkey);
} 


// *************************************************************************




QuarkHandler::QuarkHandler()
          : uPtr(0), gSmearPtr(0), qSmearPtr(0), dilPtr(0), qactionPtr(0),
            fPtr(0), invertPtr(0), compute_mode(false), dilHandler(0), DHputPtr(0), 
            DHgetPtr(0), normal_mode(true)  {}


QuarkHandler::QuarkHandler(const GaugeConfigurationInfo& gaugeinfo,
                           const GluonSmearingInfo& gluonsmear,
                           const QuarkSmearingInfo& quarksmear,
                           const DilutionSchemeInfo& dil,
                           const QuarkActionInfo& quark,
                           const FileListInfo& flist,
                           const string& smeared_quark_filestub,
                           const string& smeared_gauge_filename,
                           bool setComputeMode)
          : invertPtr(0), compute_mode(setComputeMode), dilHandler(0), 
            DHputPtr(0), DHgetPtr(0), normal_mode(true)
{
 set_info(gaugeinfo,gluonsmear,quarksmear,dil,quark,flist,
          smeared_quark_filestub,smeared_gauge_filename);
}

void QuarkHandler::setInfo(const GaugeConfigurationInfo& gaugeinfo,
                           const GluonSmearingInfo& gluonsmear,
                           const QuarkSmearingInfo& quarksmear,
                           const DilutionSchemeInfo& dil,
                           const QuarkActionInfo& quark,
                           const FileListInfo& flist,
                           const string& smeared_quark_filestub,
                           const string& smeared_gauge_filename,
                           bool setComputeMode)
{
 clear();
 compute_mode=setComputeMode;
 set_info(gaugeinfo,gluonsmear,quarksmear,dil,quark,flist,
          smeared_quark_filestub,smeared_gauge_filename);
}


void QuarkHandler::set_info(const GaugeConfigurationInfo& gaugeinfo,
                            const GluonSmearingInfo& gluonsmear,
                            const QuarkSmearingInfo& quarksmear,
                            const DilutionSchemeInfo& dil,
                            const QuarkActionInfo& quark,
                            const FileListInfo& flist,
                            const string& smeared_quark_filestub,
                            const string& smeared_gauge_filename)
{
 try{
    uPtr = new GaugeConfigurationInfo(gaugeinfo);
    gSmearPtr = new GluonSmearingInfo(gluonsmear);
    qSmearPtr = new QuarkSmearingInfo(quarksmear);
    dilPtr = new DilutionSchemeInfo(dil);
    qactionPtr = new QuarkActionInfo(quark);
    fPtr = new FileListInfo(flist);
    if (compute_mode){
       DHputPtr=new DataPutHandlerMF<QuarkHandler,FileKey,RecordKey,DataType>(
                       *this,*fPtr,"Laph--QuarkSink","QuarkHandlerDataFile");}
    else{
       DHgetPtr=new DataGetHandlerMF<QuarkHandler,FileKey,RecordKey,DataType>(
                       *this,*fPtr,"Laph--QuarkSink","QuarkHandlerDataFile");}
    }
 catch(const std::exception& xp){
    errorLaph(make_strf("allocation problem in QuarkHandler: %s",xp.what()));}

 connectGaugeConfigurationHandler();
 connectGluonSmearingHandler(smeared_gauge_filename);
 connectQuarkSmearingHandler(smeared_quark_filestub);
 connectDilutionHandler();
}


void QuarkHandler::setInverter(const InverterInfo& invinfo)
{
 if (!compute_mode){
    errorLaph("Cannot setInverter in QuarkHandler unless in compute mode");}
 if (!isInfoSet()){
    errorLaph("Cannot setInverter in QuarkHandler unless info is set");}
 try{
    delete invertPtr;
    invertPtr = new InverterInfo(invinfo);}
 catch(const std::exception& xp){
    errorLaph("allocation error in QuarkHandler::setInverter");}
}


const InverterInfo& QuarkHandler::getInverterInfo() const 
{
 if (invertPtr!=0){
    errorLaph("error in QuarkHandler: must setInverter before calling getInverterInfo");}
 return *invertPtr;
}


void QuarkHandler::clearSinkComputations()
{
 sinkComps.computations.clear();
}


void QuarkHandler::setSinkComputations(const XMLHandler& xmlin)
{
 if (!compute_mode){
    errorLaph("Cannot setSinkComputations in QuarkHandler unless in compute mode");}
 if (!isInfoSet()){
    errorLaph("Cannot setSinkComputations in QuarkHandler unless info is set");}
 XMLHandler xmlrdr(xmlin);
 if (!sinkComps.computations.empty()) sinkComps.computations.clear();

 if (xml_tag_count(xmlrdr,"SinkComputations")==1){

    XMLHandler xmlrd(xmlrdr,"SinkComputations");

    uint nSinkLaphBatch,nSinkQudaBatch,nEigQudaBatch;
    xmlread(xmlrdr,"NumSinksBeforeProject",nSinkLaphBatch,"LAPH_QUARK_LINE_ENDS");
    xmlread(xmlrdr,"NumSinksInProjectBatch",nSinkQudaBatch,"LAPH_QUARK_LINE_ENDS");
    xmlread(xmlrdr,"NumEigsInProjectBatch",nEigQudaBatch,"LAPH_QUARK_LINE_ENDS");

    int nEigs = qSmearPtr->getNumberOfLaplacianEigenvectors();
    int ndil=dilHandler->getNumberOfSpinEigvecProjectors();
    if ((int(nSinkLaphBatch) > ndil) || (nSinkLaphBatch == 0)){
       errorLaph(make_strf("Invalid value %d for <NumSinksBeforeProject>: must be between 1 and ndil=%d",
                 nSinkLaphBatch,ndil));}
    if ((int(nEigQudaBatch) > nEigs) || (nEigQudaBatch == 0)){
       errorLaph(make_strf("Invalid value %d for <NumEigsInProjectBatch>: must be between 1 and nEigs=%d",
                 nEigQudaBatch,nEigs));}
    if ((nSinkQudaBatch > nSinkLaphBatch) || (nSinkQudaBatch == 0)){
       errorLaph(make_strf("Invalid value %d for <NumSinksInProjectBatch>: must be between 1 and %d",
                 nSinkQudaBatch,nSinkLaphBatch));}
    sinkComps.nSinkLaphBatch=nSinkLaphBatch;
    sinkComps.nSinkQudaBatch=nSinkQudaBatch;
    sinkComps.nEigQudaBatch=nEigQudaBatch;

    if (xml_tag_count(xmlrd,"NoiseList_TimeProjIndexList")==1){
       XMLHandler xmlr(xmlrd,"NoiseList_TimeProjIndexList");
       vector<int> time_proj_inds;
       if (xml_tag_count(xmlr,"TimeProjIndexList")==1){
          XMLHandler xmltpi(xmlr,"TimeProjIndexList");
          if (xml_tag_count(xmltpi,"All")==1){
             int tpnum=dilHandler->getNumberOfTimeProjectors();
             time_proj_inds.resize(tpnum);
             for (int t=0;t<tpnum;t++) time_proj_inds[t]=t;}
          else{
             xmlread(xmltpi,"Values",time_proj_inds,"LAPH_QUARK_LINE_ENDS");}}
       XMLHandler xmln(xmlr,"LaphNoiseList");
       list<XMLHandler> xmlns(xmln.find("LaphNoiseInfo"));
       for (list<XMLHandler>::iterator it=xmlns.begin();it!=xmlns.end();++it){
          LaphNoiseInfo aNoise(*it);
          for (int t=0;t<int(time_proj_inds.size());t++){
             sinkComps.computations.push_back(
                  SinkComputation(aNoise,time_proj_inds[t]));}}}

    if (xml_tag_count(xmlrd,"ComputationList")==1){
       XMLHandler xmlr(xmlrd,"ComputationList");
       list<XMLHandler> xmlcs(xmlr.find("Computation"));
       for (list<XMLHandler>::iterator it=xmlcs.begin();it!=xmlcs.end();++it){
          LaphNoiseInfo aNoise(*it);
          int time_proj_index;
          xmlread(*it,"TimeProjIndex",time_proj_index,"LAPH_QUARK_LINE_ENDS");
          sinkComps.computations.push_back(
                SinkComputation(aNoise,time_proj_index));}}
    }

 printLaph("\nLAPH_QUARK_LINE_ENDS sink computations:\n");
 printLaph(make_strf("  NumSinksBeforeProject = %d",sinkComps.nSinkLaphBatch));
 printLaph(make_strf(" NumSinksInProjectBatch = %d",sinkComps.nSinkQudaBatch));
 printLaph(make_strf("  NumEigsInProjectBatch = %d\n",sinkComps.nEigQudaBatch));
 printLaph(make_strf(" Number of sink computations = %d",sinkComps.computations.size()));
 int count=0;
 for (list<SinkComputation>::const_iterator it=sinkComps.computations.begin();
      it!=sinkComps.computations.end();count++,it++){
    XMLHandler xmlout("SinkComputation");
    XMLHandler xmln; it->Noise.output(xmln);
    xmlout.put_child(xmln);
    xmlout.put_child("TimeProjIndex",make_string(it->TimeProjIndex));
    printLaph(make_strf("\nSinkComputation %d:",count));
    printLaph(make_strf("%s",xmlout.output()));}
 printLaph("\n");
}


QuarkHandler::~QuarkHandler()
{
 clear();
}


void QuarkHandler::clear()
{
 try{
    delete uPtr;
    delete gSmearPtr;
    delete qSmearPtr;
    delete dilPtr;
    delete qactionPtr;
    delete fPtr;
    delete invertPtr;}
 catch(const std::exception& xp){
    errorLaph("abort");}
 uPtr=0;
 gSmearPtr=0;
 qSmearPtr=0;
 dilPtr=0;
 qactionPtr=0;
 fPtr=0;
 invertPtr=0;
 normal_mode=true;

 disconnectGaugeConfigurationHandler();
 disconnectGluonSmearingHandler();
 disconnectQuarkSmearingHandler();
 disconnectDilutionHandler();
 clearData();
 delete DHgetPtr; DHgetPtr=0;
 delete DHputPtr; DHputPtr=0;
}


  // ********************************
  // *
  // *    sub-handler connections  (private)
  // *
  // ********************************

void QuarkHandler::connectGaugeConfigurationHandler()
{
 if ((gaugeCounter==0)&&(gaugeHandler.get()==0)){
    try{
       gaugeHandler.reset(new GaugeConfigurationHandler(*uPtr));
       gaugeCounter=1;}
    catch(const std::exception& xp){
       errorLaph("allocation problem in QuarkHandler::connectGaugeConfigurationHandler");}}
 else{
    try{
       if (gaugeHandler.get()==0) throw(std::invalid_argument("error"));
       uPtr->checkEqual(gaugeHandler->getGaugeConfigurationInfo());
       gaugeCounter++;}
    catch(const std::exception& xp){
       errorLaph("inconsistent QuarkHandler::connectGaugeConfigurationHandler");}}
}

void QuarkHandler::disconnectGaugeConfigurationHandler()
{
 gaugeCounter--;
 if (gaugeCounter==0){
    try{ gaugeHandler.reset();}
    catch(const std::exception& xp){
       errorLaph("delete problem in QuarkHandler::disconnectGaugeConfigurationHandler");}}
}




void QuarkHandler::connectGluonSmearingHandler(const string& smeared_gauge_filename)
{
 if ((gSmearCounter==0)&&(gSmearHandler.get()==0)){
    try{
       gSmearHandler.reset(new GluonSmearingHandler(*gSmearPtr,*uPtr,smeared_gauge_filename));
       gSmearCounter=1;}
    catch(const std::exception& xp){
       clear();
       errorLaph("allocation problem in QuarkHandler::connectGluonSmearingHandler");}}
 else{
    try{
       if (gSmearHandler.get()==0) throw(std::invalid_argument("error"));
       uPtr->checkEqual(gSmearHandler->getGaugeConfigurationInfo());
       gSmearPtr->checkEqual(gSmearHandler->getGluonSmearingInfo());
       gSmearCounter++;}
    catch(const std::exception& xp){
       errorLaph("inconsistent QuarkHandler::connectGluonSmearingHandler");}}
}

void QuarkHandler::disconnectGluonSmearingHandler()
{
 gSmearCounter--;
 if (gSmearCounter==0){
    try{ gSmearHandler.reset();}
    catch(const std::exception& xp){
       errorLaph("delete problem in QuarkHandler::disconnectGluonSmearingHandler");}}
}


void QuarkHandler::connectQuarkSmearingHandler(const string& smeared_quark_filestub)
{
 if ((qSmearCounter==0)&&(qSmearHandler.get()==0)){
    try{
       qSmearHandler.reset(new QuarkSmearingHandler(*gSmearPtr,*uPtr,*qSmearPtr,
                                                    smeared_quark_filestub));
       qSmearCounter=1;}
    catch(const std::exception& xp){
       errorLaph("allocation problem in QuarkHandler::connectQuarkSmearingHandler");}}
 else{
    try{
       if (qSmearHandler.get()==0) throw(std::invalid_argument("error"));
       uPtr->checkEqual(qSmearHandler->getGaugeConfigurationInfo());
       qSmearHandler->updateSmearing(*qSmearPtr);  // increase eigvecs if needed
       qSmearCounter++;}
    catch(const std::exception& xp){
       errorLaph("inconsistent QuarkHandler::connectQuarkSmearingHandler");}}
 qSmearHandler->checkAllLevelFilesExist();
}

void QuarkHandler::disconnectQuarkSmearingHandler()
{
 qSmearCounter--;
 if (qSmearCounter==0){
    try{ qSmearHandler.reset();}
    catch(const std::exception& xp){
       errorLaph("delete problem in QuarkHandler::disconnectQuarkSmearingHandler");}}
}


void QuarkHandler::connectDilutionHandler() const
{
 if (dilHandler!=0){
    errorLaph("QuarkHandler::connectDilutionHandler already connected");}
 try{
    dilHandler = new DilutionHandler(*dilPtr,*qSmearPtr);}
 catch(const std::exception& xp){
    errorLaph("allocation problem in QuarkHandler::connectDilutionHandler");}
}

void QuarkHandler::disconnectDilutionHandler() const
{
 try{ delete dilHandler;}
 catch(const std::exception& xp){
    errorLaph("delete problem in QuarkHandler::disconnectDilutionHandler");}
 dilHandler=0;
}

void QuarkHandler::setNormalMode()
{
 if (normal_mode) return;
 clearData();
 normal_mode=true;
}

void QuarkHandler::setGamma5HermiticityMode()
{
 if (!normal_mode) return;
 clearData();
 normal_mode=false;
}
/*
void QuarkHandler::getFileMap(XmlWriter& xmlout) const
{
 if (isInfoSet()) DHgetPtr->getFileMap(xmlout);
}

void QuarkHandler::outputKeys(XmlWriter& xmlout)
{
 if (isInfoSet()) DHgetPtr->outputKeys(xmlout);
}

set<QuarkHandler::FileKey> QuarkHandler::getNoisesAndTimeProjectors() const
{
 check_info_set("getNoisesAndTimeProjectors");
 return DHgetPtr->getFileKeys();
}

void QuarkHandler::getNoisesAndTimeProjectors(set<LaphNoiseInfo>& noises,
                                              set<int>& time_proj_indices) const
{
 check_info_set("getNoisesAndTimeProjectors");
 set<NoiseAndTimeProjector> nt=DHgetPtr->getFileKeys();
 for (set<NoiseAndTimeProjector>::const_iterator it=nt.begin();
      it!=nt.end();++it){
    noises.insert(it->noise);
    time_proj_indices.insert(it->time_proj_index);}
}

void QuarkHandler::getNoisesAndSourceTimes(set<LaphNoiseInfo>& noises,
                                           set<int>& source_times) const
{
 check_info_set("getNoisesAndSourceTimes");
 set<NoiseAndTimeProjector> nt=DHgetPtr->getFileKeys();
 for (set<NoiseAndTimeProjector>::const_iterator it=nt.begin();
      it!=nt.end();++it){
    noises.insert(it->noise);
    const list<int>& onts=getOnTimes(it->time_proj_index);
    source_times.insert(onts.begin(),onts.end());}
}
*/

map<int,QuarkHandler::FileKey> QuarkHandler::getSuffixMap() const
{
 check_info_set("getSuffixMap");
 if (compute_mode){
    return DHputPtr->getSuffixMap();}
 else{
    return DHgetPtr->getSuffixMap();}
}


void QuarkHandler::outputSuffixMap()
{
 check_info_set("getSuffixMap");
 map<int,QuarkHandler::FileKey> suffixmap=getSuffixMap();
 printLaph("\nSuffix map:");
 for (map<int,QuarkHandler::FileKey>::const_iterator it=suffixmap.begin();
      it!=suffixmap.end();++it){
    printLaph(make_strf("suffix  %d:  LaphNoiseInfo seed = %d  time proj index = %d",
               it->first,it->second.noise.getSeed(),it->second.time_proj_index));}
 printLaph("\n");
}

/*
void QuarkHandler::outputSuffixMap(TextFileWriter& fout)
{
 check_info_set("getSuffixMap");
 map<int,QuarkHandler::FileKey> suffixmap=DHgetPtr->getSuffixMap();
 fout <<"\nSuffix map:\n";
 for (map<int,QuarkHandler::FileKey>::const_iterator it=suffixmap.begin();
      it!=suffixmap.end();++it){
    fout << "suffix "<<it->first<<":  LaphNoiseInfo seed = "
      << it->second.noise.getSeed()<<"  time proj index = "
      << it->second.time_proj_index << "\n";}
 fout << "\n";
}

#elif (QDP_ND == 4)
*/

/*
void QuarkHandler::getFileMap(XmlWriter& xmlout) const
{
 if (isInfoSet()) DHputPtr->getFileMap(xmlout);
}


#endif


*/

bool QuarkHandler::isInfoSet() const
{
 return ((uPtr!=0)&&(gSmearPtr!=0)&&(qSmearPtr!=0)&&(fPtr!=0)
        &&(dilPtr!=0)&&(qactionPtr!=0));
}


void QuarkHandler::check_info_set(const string& name) const
{
 if (!isInfoSet()){
    errorLaph(make_strf("error in QuarkHandler: must setInfo before calling %s",name));}
}


bool QuarkHandler::isComputeReady() const
{
 return ((isInfoSet())&&(compute_mode)&&(invertPtr!=0));
}


void QuarkHandler::check_compute_ready(const string& name) const
{
 if (!isComputeReady()){
    errorLaph(make_strf("error in QuarkHandler: must setInfo before calling %s",name));}
}


const GaugeConfigurationInfo& QuarkHandler::getGaugeConfigurationInfo() const 
{
 check_info_set("getGaugeConfigurationInfo");
 return *uPtr;
}

const GluonSmearingInfo& QuarkHandler::getGluonSmearingInfo() const
{
 check_info_set("getGluonSmearingInfo");
 return *gSmearPtr;
}

const QuarkSmearingInfo& QuarkHandler::getQuarkSmearingInfo() const
{
 check_info_set("getQuarkSmearingInfo");
 return *qSmearPtr;
}

const DilutionSchemeInfo& QuarkHandler::getDilutionSchemeInfo() const 
{
 check_info_set("getDilutionSchemeInfo");
 return *dilPtr;
}

const QuarkActionInfo& QuarkHandler::getQuarkActionInfo() const 
{
 check_info_set("getQuarkActionInfo");
 return *qactionPtr;
}

const FileListInfo& QuarkHandler::getFileListInfo() const 
{
 check_info_set("getFileListInfo");
 return *fPtr;
}

int QuarkHandler::getNumberOfSpinEigvecDilutionProjectors() const 
{
 check_info_set("getNumberOfSpinEigvecDilutionProjectors");
 return dilHandler->getNumberOfSpinEigvecProjectors();
}

int QuarkHandler::getNumberOfTimeDilutionProjectors() const 
{
 check_info_set("getNumberOfTimeDilutionProjectors");
 return dilHandler->getNumberOfTimeProjectors();
}

int QuarkHandler::getTimeDilutionProjectorIndex(int time_val) const 
{
 check_info_set("getTimeDilutionProjectorIndex");
 return dilHandler->getTimeProjectorIndex(time_val);
}

const list<int>& QuarkHandler::getOnTimes(int time_proj_index) const 
{
 check_info_set("getOnTimes");
 return dilHandler->getOnTimes(time_proj_index);
}

bool QuarkHandler::isFullTimeDilution() const 
{
 check_info_set("isFullTimeDilution");
 return dilHandler->isFullTimeDilution();
}

int QuarkHandler::getTimeExtent() const 
{
 check_info_set("getTimeExtent");
 return uPtr->getTimeExtent();
}

/*
void QuarkHandler::getHeader(XmlWriter& xmlout) const
{
 if (isInfoSet()){
    push(xmlout,"QuarkHandlerDataFile");
    uPtr->output(xmlout);
    gSmearPtr->output(xmlout);
    qSmearPtr->output(xmlout);
    dilPtr->output(xmlout);
    qactionPtr->output(xmlout);
    pop(xmlout);}
}
*/
bool QuarkHandler::checkHeader(XMLHandler& xmlin, int suffix)
{
 XMLHandler xml_in(xmlin);
 if (xml_tag_count(xml_in,"QuarkHandlerDataFile")!=1) return false;
 XMLHandler xmlr(xml_in,"QuarkHandlerDataFile");
 GaugeConfigurationInfo gauge_check(xmlr);
 GluonSmearingInfo gsmear_check(xmlr);
 QuarkSmearingInfo qsmear_check(xmlr);
 DilutionSchemeInfo dil_check(xmlr);
 QuarkActionInfo qaction_check(xmlr);
 try {
    uPtr->checkEqual(gauge_check);
    gSmearPtr->checkEqual(gsmear_check);
    qSmearPtr->checkEqual(qsmear_check);
    dilPtr->checkEqual(dil_check);
    qactionPtr->checkEqual(qaction_check); }
 catch(const std::exception& xp){ return false;}
 return true;
}

void QuarkHandler::writeHeader(XMLHandler& xmlout, 
                               const QuarkHandler::FileKey& fkey,
                               int suffix)
{
 xmlout.set_root("QuarkHandlerDataFile");
 XMLHandler xmltmp;
 uPtr->output(xmltmp); xmlout.put_child(xmltmp);
 gSmearPtr->output(xmltmp); xmlout.put_child(xmltmp);
 qSmearPtr->output(xmltmp); xmlout.put_child(xmltmp);
 dilPtr->output(xmltmp); xmlout.put_child(xmltmp);
 qactionPtr->output(xmltmp); xmlout.put_child(xmltmp);
 fkey.output(xmltmp); xmlout.put_child(xmltmp);
}


 // ************************************************************************************

void QuarkHandler::computeSinks(bool verbose)
{   
 check_compute_ready("computeSink");
 StopWatch totaltime; totaltime.start();
 
 printLaph("Task computeSinks beginnning\n");
 printLaph("Quda Projection batch parameters:");
 printLaph(make_strf("      Number of inversions before projecting is %d",sinkComps.nSinkLaphBatch));
 printLaph(make_strf("  Number of solutions projected in one batch is %d",sinkComps.nSinkQudaBatch));
 printLaph(make_strf("    Number of eigvecs projected in one batch is %d",sinkComps.nEigQudaBatch));
     // load the gauge configuration onto host and device
 StopWatch rolex; rolex.start();
 gaugeHandler->setData();  
 gaugeHandler->copyDataToDevice();
 rolex.stop();
 double grtime=rolex.getTimeInSeconds();
 printLaph("...gauge configuration loaded on host and device");
 printLaph(make_str(" time to load gauge configuration was ",grtime," seconds"));
     // load the LapH eigenvectors onto host, store pointers
 rolex.reset(); rolex.start();
 int nEigs = qSmearPtr->getNumberOfLaplacianEigenvectors();
 vector<void*> evList(nEigs);
 for (int n=0;n<nEigs;n++){
    evList[n] = (void*)(qSmearHandler->getLaphEigenvector(n).getDataConstPtr());
    printLaph(make_strf("read LapH eigvec level %d",n));}
 qSmearHandler->closeLaphLevelFiles();
 rolex.stop();
 double evreadtime=rolex.getTimeInSeconds();
 printLaph(make_str("All Laph eigvecs read in ",evreadtime," seconds\n"));
 
     // set up the inverter params for quda (will change depending on inverter type)
 QudaInvertParam inv_param=newQudaInvertParam();
 qactionPtr->setQudaInvertParam(inv_param);           // multigrid params will have to go in here!!
 invertPtr->setQudaInvertParam(inv_param);
     // check that Dirac-Pauli basis is used
// if (inv_param.gamma_basis!=QUDA_DIRAC_PAULI_GAMMA_BASIS){
//    errorQuda("The Dirac-Pauli basis must be used");}
     // check temporal boundary conditions in InverterInfo and GaugeConfigurationInfo
     // are the same
 bool tbc1=qactionPtr->isFermionTimeBCAntiPeriodic();
 bool tbc2=uPtr->isFermionTimeBCAntiPeriodic();
 if (tbc1!=tbc2){
    errorLaph("Inconsistent fermion time boundary conditions in QuarkActionInfo and GaugeConfigurationInfo",true);}
     // load the clover term 
 double clovertime=0.0;

//  double z;
//  void* fmunu=quda::gaugePrecise;
//  for (int k=0;k<24;++k){
//     cudaMemcpy(fmunu, &z, sizeof(double), cudaMemcpyDeviceToHost);
//     logQuda(QUDA_VERBOSE,"Fmunu double number %d is %f\n",k,z);}



 if (inv_param.dslash_type == QUDA_CLOVER_WILSON_DSLASH){    // NEED CHECK HERE than clover is invertible
    if (!QudaInfo::clover_on_device){                      //  Inverse done by Cholesky which fails if
    //printQudaInvertParam(&inv_param);                   // not positive definite (not just singular)
    
    //LattField clover(FieldSiteType::ColorSpinVector);
    //LattField cloverinv(FieldSiteType::ColorSpinVector);

//vector<char> clover(72*LayoutInfo::getRankLatticeNumSites()*sizeof(double));
//vector<char> cloverinv(72*LayoutInfo::getRankLatticeNumSites()*sizeof(double));

//double* z=reinterpret_cast<double*>(clover.data());
//for (int k=0;k<72*LayoutInfo::getRankLatticeNumSites();++k,++z){
//   *z=0.45123+(k%128)*0.001973;}
//   *z=1.00;}
//z=reinterpret_cast<double*>(cloverinv.data());
//for (int k=0;k<72*LayoutInfo::getRankLatticeNumSites()*2;++k,++z){
//   *z=1.234+((k+56)%128)*0.001973;}
//    void* h1=reinterpret_cast<void*>(clover.data());
//    void* h2=reinterpret_cast<void*>(cloverinv.data());
  //  void* h1=reinterpret_cast<void*>(clover.data());
  //  void* h2=reinterpret_cast<void*>(cloverinv.data());
    //size_t clover_site_size = 72;
    //void *hostClover = nullptr;
    //void *hostCloverInv = nullptr;
    //hostClover = safe_malloc((size_t)LayoutInfo::getRankLatticeNumSites() * clover_site_size * inv_param.clover_cpu_prec);
    //hostCloverInv = safe_malloc((size_t)LayoutInfo::getRankLatticeNumSites() * clover_site_size * inv_param.clover_cpu_prec);
    
       rolex.reset(); rolex.start();
       loadCloverQuda(NULL, NULL, &inv_param);  // allocates space
  //  inv_param.return_clover = 1;
  //  inv_param.return_clover_inverse = 1;
  //  inv_param.compute_clover = 1;
  //  inv_param.compute_clover_inverse = 1;
  //  inv_param.clover_location = QUDA_CPU_FIELD_LOCATION;

//   PUT IN A CHECK HERE TO ENSURE CLOVER INVERSE IS NOT NAN

   // loadCloverQuda(h1,h2, &inv_param);  // allocates space
    //createCloverQuda(&inv_param);            // initializes   (CHECK THIS)  newQudaCloverParam??
/*
printLaph("CLOVER FIELD");
const double* tmp=reinterpret_cast<const double*>(h1);
const double* tmp1=reinterpret_cast<const double*>(h1);
for (int i=0;i<72;++i,++tmp){
   printLaph(make_strf("clover[%d] = %18.12f",i,*tmp/(*tmp1)));}
tmp=reinterpret_cast<const double*>(h2);
tmp1=reinterpret_cast<const double*>(h2);
for (int i=0;i<72;++i,++tmp){
   printLaph(make_strf("clover-inverse[%d] = %18.12f",i,*tmp/(*tmp1)));}
   
//clover.print();
//printLaph("INVERSE CLOVER FIELD");
//cloverinv.print();

//printLaph("Clover field on host\n");
//z=reinterpret_cast<double*>(h1);
//for (int k=0;k<72*LayoutInfo::getRankLatticeNumSites();++k,++z){
//   printLaph(make_str(" clover double ",k," is ",*z));}
//printLaph("Inverse clover field on host\n");
//z=reinterpret_cast<double*>(h2);
//for (int k=0;k<72*LayoutInfo::getRankLatticeNumSites();++k,++z){
//   printLaph(make_str(" inv clover double ",k," is ",*z));}
*/


       printLaph("...clover term set up and loaded on device");
       printLaph(" clover inverse calculated using Cholesky so clover term must be positive-definite");
       rolex.stop();
       clovertime=rolex.getTimeInSeconds();
       printLaph(make_str(" Time to set up clover term was ",clovertime," seconds"));
       QudaInfo::clover_on_device=true;}}

 double srctime=0.0;
 double invtime=0.0;
 double evprojtime=0.0;
 double writetime=0.0;
 int count=0;
 int ncomp=sinkComps.computations.size();

 for (list<SinkComputation>::const_iterator it=sinkComps.computations.begin();
      it!=sinkComps.computations.end();count++,it++){
    printLaph("\n\n *************************************************************");
    printLaph(make_strf(" *\n *  Now starting sink computation %d (with %d as last):",
               count,ncomp-1));
    printLaph(" *");
    printLaph(" *************************************************************");

    computeSinks(inv_param,it->Noise,it->TimeProjIndex,evList,verbose,
                 srctime,invtime,evprojtime,writetime);
    }

 totaltime.stop();
 printLaph("\n\n");
 printLaph("computeQuarkSink: one noise, all dilutions, one source time: ran successfully");
 printLaph(make_str("                       Total time = ",totaltime.getTimeInSeconds()," seconds"));
 printLaph(make_str(" Time to load gauge configuration = ",grtime," seconds"));
 printLaph(make_str("            LapH eigvec read time = ",evreadtime," seconds"));
 if (inv_param.dslash_type == QUDA_CLOVER_WILSON_DSLASH){ 
    printLaph(make_str("       Time to set up clover term = ",clovertime," seconds"));}
 printLaph(make_str("         Total source set up time = ",srctime," seconds"));
 printLaph(make_str("           Total time in inverter = ",invtime," seconds"));
 printLaph(make_str("Projection onto LapH eigvecs time = ",evprojtime," seconds"));
 printLaph(make_str("          Total file writing time = ",writetime," seconds\n\n"));
}


    //  do inversions for all spin-laph-eigenvector dilution indices
    //  but for one noise, one time projector index

void QuarkHandler::computeSinks(QudaInvertParam& inv_param, const LaphNoiseInfo& noise, 
                                int time_proj_index, const std::vector<void*>& evList,
                                bool verbose, double& src_time, double& inv_time,
                                double& evproj_time, double& write_time)
{
 if (!dilHandler->isValidTimeProjectorIndex(time_proj_index)){
    printLaph(make_strf("invalid time projector index %d for compute in QuarkHandler",
               time_proj_index));
    printLaph(" ...skipping this computation");
    return;}
 
 StopWatch bulova; bulova.start();
 printLaph("\nQuark sink computation for all dilutions, one noise,");
 printLaph(" one time dilution projector beginning");
 printLaph(make_strf(" Time dilution projector index = %d",time_proj_index));

 int Textent = uPtr->getTimeExtent();
 int Nspin = FieldNspin;
 int nEigs = qSmearPtr->getNumberOfLaplacianEigenvectors();
 int ndil=dilHandler->getNumberOfSpinEigvecProjectors();
 int minTime=0;
 int maxTime=Textent-1;
 uint nSinkLaphBatch=sinkComps.nSinkLaphBatch;
 uint nSinkQudaBatch=sinkComps.nSinkQudaBatch;
 uint nEigQudaBatch=sinkComps.nEigQudaBatch;

        // generate the source noise field
 LaphZnNoise rho(noise.getZNGroup(),noise.getSeed(*uPtr));
 Array<cmplx> laph_noise=rho.generateLapHQuarkSourceForSink(Textent,Nspin,nEigs);
        // time dilution masks
 const list<int>& on_times=dilHandler->getOnTimes(time_proj_index);
 double soln_rescale=qactionPtr->getSolutionRescaleFactor();

        // allocate space for batched solutions and make pointers suitable for quda
 int iSinkBatch = 0;
 vector<int> sinkBatchInds(nSinkLaphBatch);
 vector<LattField> sinkBatchData(nSinkLaphBatch,FieldSiteType::ColorSpinVector);
 vector<void*> sinkList(nSinkLaphBatch);
 for (int iSink=0; iSink<int(nSinkLaphBatch); iSink++){
    sinkList[iSink] = (void*)(sinkBatchData[iSink].getDataPtr());}
 void** sinks_ptr=(void**)sinkList.data();
 void** evs_ptr=(void**)evList.data();

     // get the file key and open file for writing

 FileKey fkey(noise,time_proj_index);
 DHputPtr->open(fkey);
 bulova.stop();
 double srctime=bulova.getTimeInSeconds();
 double invtime=0.0;
 double writetime=0.0;
 double evprojtime=0.0;

     // loop over dilutions
 
 for (int dil=0;dil<ndil;dil++){

    printLaph(make_strf("\nStarting dilution %d (with %d as last)",dil,ndil-1));
    bool doneflag=true;
    for (int t=minTime;t<=maxTime;t++)
    for (int s=1;s<=Nspin;s++){
       if (!DHputPtr->queryData(RecordKey(s,t,dil))){
          doneflag=false; s=Nspin+1; t=Textent;}}

    if ((!fPtr->isModeOverwrite())&&(doneflag)){
       printLaph("warning: these quark sinks already computed...");
       printLaph("  skip re-computing since fileMode not overwrite");}
    else{

        // get the lists of which spins and which eigenvectors are
        // "on" for this dilution projector
        
    bulova.reset();bulova.start();
    const list<int>& on_spins=dilHandler->getOnSpinIndices(dil);
    const list<int>& on_eigs=dilHandler->getOnEigvecIndices(dil);

        //  initialize source (include gamma_4) in Dirac-Pauli basis, allocate sink
    LattField ferm_src;
    make_source(ferm_src,laph_noise,evList,on_times,on_spins,on_eigs);



LattField ferm_srcGR(FieldSiteType::ColorSpinVector);
 convertSpinBasis(ferm_srcGR,ferm_src,"DP_to_GR");


vector<vector<int>> printsites;
printsites.push_back(vector<int>{0,0,0,23});
printsites.push_back(vector<int>{6,3,7,23});
printsites.push_back(vector<int>{16,7,21,23});
printsites.push_back(vector<int>{4,16,11,23});
printsites.push_back(vector<int>{0,0,0,22});
printsites.push_back(vector<int>{6,3,7,22});
printsites.push_back(vector<int>{16,7,21,22});
printsites.push_back(vector<int>{4,16,11,22});
printsites.push_back(vector<int>{0,0,0,21});
printsites.push_back(vector<int>{6,3,7,21});
printsites.push_back(vector<int>{16,7,21,21});
printsites.push_back(vector<int>{4,16,11,21});

printField(ferm_srcGR,"SourceGR",printsites);

    bulova.stop();
    double addsrctime=bulova.getTimeInSeconds();
    printLaph(make_str(" fermion source set up in Dirac-Pauli basis in ",addsrctime," seconds"));
    srctime+=addsrctime;

    // now do the inversion (source and sink should be on host in Dirac-Pauli basis)
    bulova.reset(); bulova.start();
//    void *spinor_src = (void*)(ferm_src.getDataPtr());
//    void *spinor_snk = (void*)(sinkBatchData[iSinkBatch].getDataPtr());

    void *spinor_src = (void*)(ferm_srcGR.getDataPtr());

LattField ferm_snkGR(FieldSiteType::ColorSpinVector);
    void *spinor_snk = (void*)(ferm_snkGR.getDataPtr());


    //printQudaInvertParam(&inv_param);

    invertQuda(spinor_snk, spinor_src, &inv_param);

printField(ferm_snkGR,"SinkGR",printsites);

convertSpinBasis(sinkBatchData[iSinkBatch],ferm_snkGR,"GR_to_DP");

    //sleep(6);

    //QLTestEnv::LatticeAssigner LA(3231437854,true);
    //LA.assign_field(sinkBatchData[iSinkBatch],"TheSink");
    //inv_param.iter=12;
    //inv_param.true_res=1.23e-9;
    
    //if ((dil==11)||(dil==15)) inv_param.iter=25000;

    bulova.stop(); 
    double addinvtime=bulova.getTimeInSeconds();
    invtime+=addinvtime;

    printLaph(make_strf("Inversion done:  number of iterations = %d",inv_param.iter));
    printLaph(make_strf(" Residual = %g",inv_param.true_res));
    printLaph(make_str("  Inversion time was ",addinvtime," seconds"));

    if ((inv_param.iter>0)&&(inv_param.iter<int(invertPtr->getMaxIterations()))){
       sinkBatchInds[iSinkBatch] = dil;
       iSinkBatch++;}
    else{
       printLaph("\n\nInversion FAILED to converge before max iteration reached");
       printLaph("Solution NOT WRITTEN to file\n\n");}
    }

       // carry out projections
    if ((iSinkBatch == int(nSinkLaphBatch))||((dil==(ndil-1))&&(iSinkBatch>0))) {

       bulova.reset(); bulova.start();
       int nSinks=iSinkBatch;
       int nSinksBatch=std::min(nSinks,int(nSinkQudaBatch));

       Array<dcmplx> qudaRes(nSinks, nEigs, Textent, Nspin);
       __complex__ double* qudaResPtr = (__complex__ double*)(&qudaRes(0,0,0,0));

	   // do the projections
       printLaph("projecting batch of solutions onto LapH eigenvectors");
       laphSinkProject(qudaResPtr, sinks_ptr, nSinks, nSinksBatch, evs_ptr, nEigs, 
                       nEigQudaBatch, &inv_param, LayoutInfo::getRankLattSizes().data());



  //     Array<dcmplx> projcoefs(nSinks, nEigs, Textent, Nspin);

  //     projectOntoLaphEigvecs(latfermB,laphev_ptrs,projections,nEigs,Textent);



       bulova.stop(); 
       double addevprojtime=bulova.getTimeInSeconds();
       printLaph(make_str(" this batch of projections onto Laph evs took ",addevprojtime," seconds"));
       evprojtime+=addevprojtime;

	   // rearrange data then output to file
       bulova.reset(); bulova.start();
       for (int iSink=0; iSink<nSinks; ++iSink) {
          for (int t=minTime;t<=maxTime;t++){
             for (int iSpin=0; iSpin<Nspin; ++iSpin) {
                Array<dcmplx> quark_sink(nEigs);
                for (int iEv=0; iEv<nEigs; ++iEv) {
                   quark_sink(iEv) = soln_rescale*qudaRes(iSink, iEv, t, iSpin);}
                   DHputPtr->putData(RecordKey(iSpin+1,t,sinkBatchInds[iSink]),quark_sink);
                   if (verbose){
		      printLaph(make_strf("dil = %d, spin = %d, time = %d",sinkBatchInds[iSink],iSpin+1,t));
                      for (int n=0;n<nEigs;n++){
		         printLaph(make_strf("coef for eigenlevel %d = (%14.8f, %14.8f)",
                                    n,real(quark_sink(n)),imag(quark_sink(n))));}}}}}
       bulova.stop();
       double otime=bulova.getTimeInSeconds();
       printLaph(make_str(" Output of this batch to file took ",otime," seconds"));
       writetime+=otime;

       iSinkBatch = 0;}   // batch end
    DHputPtr->flush();}   // dilution loop end

 inv_time+=invtime;
 src_time+=srctime; 
 evproj_time+=evprojtime; 
 write_time+=writetime;
}




/*
void QuarkHandler::computeSink4(const LaphNoiseInfo& noise, int time_proj_index, bool verbose)
{
  // load gauge config
  multi1d<LatticeColorMatrix> cfg = gaugeHandler->getData();
  void *gauge[4];
  for (int dir = 0; dir < 4; dir++) {
    gauge[dir] = (void*)(&(cfg[dir]).elem(all.start()).elem().elem(0,0).real());
  }

  QudaGaugeParam gauge_param = newQudaGaugeParam();
	multi1d<int> locLatDims = Layout::subgridLattSize();
	const int X[4] = {locLatDims[0], locLatDims[1], locLatDims[2], locLatDims[3]};
  gauge_param.X[0] = X[0];
  gauge_param.X[1] = X[1];
  gauge_param.X[2] = X[2];
  gauge_param.X[3] = X[3];
  gauge_param.type = QUDA_SU3_LINKS;
  gauge_param.gauge_order = QUDA_QDP_GAUGE_ORDER;
  gauge_param.anisotropy = 1.;
  gauge_param.t_boundary = QUDA_ANTI_PERIODIC_T;
  gauge_param.cpu_prec = QUDA_DOUBLE_PRECISION;
  gauge_param.cuda_prec = QUDA_DOUBLE_PRECISION;
  gauge_param.reconstruct = QUDA_RECONSTRUCT_12;
  gauge_param.gauge_fix = QUDA_GAUGE_FIXED_NO;
  gauge_param.ga_pad = 0;
  gauge_param.struct_size = sizeof(gauge_param);
  loadGaugeQuda((void *)gauge, &gauge_param);

  loadCloverQuda(NULL, NULL, &invParam);
  createCloverQuda(&invParam);


 if ((!isInfoSet())||(invertPtr==0)){
    QDPIO::cerr << "cannot computeSink in QuarkHandler until"
                << " info and inverter set"<<endl;
    QDP_abort(1);}

 if (!dilHandler->isValidTimeProjectorIndex(time_proj_index)){
    QDPIO::cerr << "invalid time projector index "<<time_proj_index
                <<" for compute in QuarkHandler"<<endl;
    QDPIO::cerr << " skipping this computation"<<endl;
    return;}

 int Textent = uPtr->getTimeExtent();
 int minTime = uPtr->getMinTime();
 int maxTime = uPtr->getMaxTime();
 int nTimes = maxTime - minTime + 1;
 const list<int>& onTimes=dilHandler->getOnTimes(time_proj_index);

 
 QDPIO::cout << "Running computeSink4"<<endl<<endl;
 QDPIO::cout << "Quda Projection batch params:"<<endl;
 QDPIO::cout << "  nSinkLaphBatch = " << nSinkLaphBatch << endl;
 QDPIO::cout << "  nSinkQudaBatch = " << nSinkQudaBatch << endl;
 QDPIO::cout << "  nEigQudaBatch = " << nEigQudaBatch << endl << endl;
 QDPIO::cout <<endl<< "Quark sink computation for all dilutions, one noise,"
             << " one time dilution projector beginning"<<endl;
 QDPIO::cout << " Time dilution projector index = "<<time_proj_index<<endl;
 START_CODE();
 StopWatch totaltime;
 totaltime.start();
 double iotime=0.0, srctime=0.0, snktime=0.0, invtime=0.0;
 double evreadtime=0.0, sumtime=0.0, evread2time=0.0, evprojtime=0.0;
 double noisetime=0.0, inittime=0.0, rotatetime=0.0, latfermAtime=0.0;
 double invchecktime=0.0, snkrottime=0.0, peekspintime=0.0, contracttime=0.0;
 
     // set the noise vector

 StopWatch rolex,bulova; rolex.start();bulova.start();
 LaphZnNoise rho(noise.getZNGroup(),noise.getSeed(*uPtr));
 int Tdir = uPtr->getTimeDir();
 int Nspin = QDP::Ns;
 uint nEigs = qSmearPtr->getNumberOfLaplacianEigenvectors();
  
 multi3d<DComplex> laph_noise=rho.generateLapHQuarkSourceForSink(Textent,nEigs,
                          qactionPtr->getTimeBoundaryConditions());
 if (qactionPtr->getTimeBoundaryConditions()==QuarkActionInfo::ZeroDirichlet){
    QDPIO::cout << " Laph noise generated for zero Dirichlet boundary condition in time"<<endl;}
 else if (qactionPtr->getTimeBoundaryConditions()==QuarkActionInfo::AntiPeriodic){
    QDPIO::cout << " Laph noise generated for antiperiodic boundary condition in time"<<endl;}
 rolex.stop(); noisetime+=rolex.getTimeInSeconds();
 
 rolex.reset();rolex.start();
 Set timeslices;                         // needed for time slice masks
 timeslices.make(TimeSlice(Tdir)); 

 Set centLat;
 centLat.make(TimeInterval(minTime, nTimes, Tdir));

 SpinMatrix SrcRotate = Gamma(8) * DiracToDRMat();   //  multiply by gamma_4
 SpinMatrix SnkRotate = adj(DiracToDRMat());    // rotate back to Dirac-Pauli

     // get the file key and open file for writing

 FileKey fkey(noise,time_proj_index);
 DHputPtr->open(fkey);
 int ndil=dilHandler->getNumberOfSpinEigvecProjectors();
 bulova.stop(); srctime+=bulova.getTimeInSeconds();
 rolex.stop(); inittime+=rolex.getTimeInSeconds();

     // check quda projection params
     
 if ((nSinkLaphBatch > ndil) || (nSinkLaphBatch == 0)){
   QDPIO::cerr << "Invalid value for nSinkLaphBatch=" << nSinkLaphBatch << endl;
   QDPIO::cerr << "nSinkLaphBatch must be between 1 and ndil=" << ndil << endl;
   QDP_abort(1);}

 if ((nEigQudaBatch > nEigs) || (nEigQudaBatch == 0)){
   QDPIO::cerr << "Invalid value for nEigQudaBatch=" << nEigQudaBatch << endl;
   QDPIO::cerr << "nEigQudaBatch must be between 1 and nEigs=" << nEigs << endl;
   QDP_abort(1);}
 
 if ((nSinkQudaBatch > nSinkLaphBatch) || (nSinkQudaBatch == 0)){
   QDPIO::cerr << "Invalid value for nSinkQudaBatch=" << nSinkQudaBatch << endl;
   QDPIO::cerr << "nSinkQudaBatch must be between 1 and nSinkLaphBatch=" << nSinkLaphBatch << endl;
   QDP_abort(1);}

   // structure to hold a few solutions in memory to batch up EV projections
 if (ndil % nSinkLaphBatch != 0) {
   QDPIO::cerr << "quark_handler: nSinkLaphBatch does not divide ndil without remainder, projection of leftover tail sinks not implemented" << endl;
   QDP_abort(1);
 }

 int iSinkBatch = 0;
 std::vector<int> sinkBatchInds(nSinkLaphBatch);
 std::vector<LatticeFermion> sinkBatchData(nSinkLaphBatch);

     // loop over dilutions
 
 for (int dil=0;dil<ndil;dil++){

    bulova.reset();bulova.start();
    QDPIO::cout <<endl<< "Starting dilution "<<dil<<" (with "<<ndil-1<<" as last)"<<endl;
    bool doneflag=true;
    rolex.reset();rolex.start();
    for (int t=minTime;t<=maxTime;t++)
    for (int s=1;s<=Nspin;s++){
       if (!DHputPtr->queryData(RecordKey(s,t,dil))){
          doneflag=false; s=Nspin+1; t=Textent;}}
    rolex.stop(); evreadtime+=rolex.getTimeInSeconds();

    if ((!fPtr->isModeOverwrite())&&(doneflag)){
       QDPIO::cout << "warning: these quark sinks already computed..."
                   << "skip re-computing since fileMode not overwrite"<<endl;
       continue;}

        // get the lists of which spins and which eigenvectors are
        // "on" for this dilution projector
        
    const list<int>& on_spins=dilHandler->getOnSpinIndices(dil);
    const list<int>& on_eigs=dilHandler->getOnEigvecIndices(dil);

        //  initialize output field for sources
    StopWatch seiko; seiko.start();
    LatticeFermion latfermA = zero;
    seiko.stop(); latfermAtime+=seiko.getTimeInSeconds();
    for (list<int>::const_iterator vmask= on_eigs.begin(); vmask!=on_eigs.end(); vmask++){
       rolex.reset();rolex.start();
       const LatticeColorVector& Vs = qSmearHandler->getLaphEigenvector(*vmask);
       rolex.stop(); evreadtime+=rolex.getTimeInSeconds();
       seiko.reset();seiko.start();
       LatticeSpinVector sv = zero;
       for (list<int>::const_iterator smask= on_spins.begin(); smask!=on_spins.end(); smask++){
          LatticeComplex temp = zero;
               // apply time dilution projector
          for (list<int>::const_iterator it0=onTimes.begin();
             it0!=onTimes.end();it0++){
             temp[timeslices[*it0]] = laph_noise(*it0,*smask,*vmask);}
          pokeSpin(sv,temp,*smask);}
       for (list<int>::const_iterator it0=onTimes.begin();
          it0!=onTimes.end();it0++){
          latfermA[timeslices[*it0]] += sv * Vs;}
       seiko.stop(); latfermAtime+=seiko.getTimeInSeconds();
       }

    seiko.reset();seiko.start();       
    LatticeFermion latfermB = SrcRotate * latfermA;  // rotate to DeGrand-Rossi, mult by gamma_4

    QDPIO::cout << "Norm of source vector = "<<sqrt(norm2(latfermB))<<endl;
    latfermA = zero;

    QDPIO::cout << "source created...starting inversion"<<endl;
    bulova.stop(); srctime+=bulova.getTimeInSeconds();
    seiko.stop(); rotatetime+=seiko.getTimeInSeconds();
    
    // now do the inversion
    //void *spinorIn = (void*)(&latfermB.elem(rb[1].start()).elem(0).elem(0).real());
    //void *spinorOut = (void*)(&latfermA.elem(rb[1].start()).elem(0).elem(0).real());
    void *spinorIn = (void*)(&latfermB.elem(all.start()).elem(0).elem(0).real());
    void *spinorOut = (void*)(&latfermA.elem(all.start()).elem(0).elem(0).real());
    bulova.reset();bulova.start();
    invertQuda(spinorOut, spinorIn, &invParam);
    bulova.stop(); invtime+=bulova.getTimeInSeconds();

    QDPIO::cout << "Inversion done:  number of iterations = "<<invParam.iter<<endl;
    QDPIO::cout << " Residual = "<<invParam.true_res<<endl;

    if ((invParam.iter>0)&&(invParam.iter<=invertPtr->getMaxIterations())){

       rolex.reset();rolex.start();
       sinkBatchData[iSinkBatch] = SnkRotate * latfermA;         // rotate back to Dirac-Pauli
       sinkBatchInds[iSinkBatch] = dil;
       iSinkBatch++;
       rolex.stop(); snkrottime+=rolex.getTimeInSeconds();

         // go do some actual projections if batch slots filled
       if (iSinkBatch == nSinkLaphBatch) {

	   // collect ev pointers
	 rolex.reset();rolex.start();
	 std::vector<void*> evList(nEigs);
	 for (int n=0;n<nEigs;n++){
	   evList[n] = (void*)(&qSmearHandler->getLaphEigenvector(n).elem(all.start()).elem().elem(0).real());;
	   qSmearHandler->closeLaphLevelFiles();  // prevent too many files being open
	 }
	 rolex.stop(); evread2time+=rolex.getTimeInSeconds();

	   // collect sink pointers
	 rolex.reset();rolex.start();
	 std::vector<void*> sinkList(nSinkLaphBatch);
	 for (int iSink=0; iSink<nSinkLaphBatch; iSink++){
	   sinkList[iSink] = (void*)(&sinkBatchData[iSink].elem(all.start()).elem(0).elem(0).real());
	 }

	 multi1d<int> locLatDims = Layout::subgridLattSize();
	 const int X[4] = {locLatDims[0], locLatDims[1], locLatDims[2], locLatDims[3]};

	 multi4d<DComplex> qudaRes;
	 qudaRes.resize(nSinkLaphBatch, nEigs, Textent, Nspin);
	 __complex__ double* qudaResPtr = (__complex__ double*)(&qudaRes(0,0,0,0).elem().elem().elem());

	   // the main show
   QDPIO::cout << "projecting onto LapH eigenvectors (with QUDA)" << endl;
	 laphSinkProject(qudaResPtr, (void**)sinkList.data(), nSinkLaphBatch, nSinkQudaBatch, (void**)evList.data(), nEigs, nEigQudaBatch, &invParam, X);
	 rolex.stop(); evprojtime+=rolex.getTimeInSeconds();

	   // reorder and IO
          StopWatch iotimer; iotimer.start();
	  for (int iSink=0; iSink<nSinkLaphBatch; ++iSink) {
	    for (int t=minTime;t<=maxTime;t++)
	      for (int iSpin=0; iSpin<Nspin; ++iSpin) {
		multi1d<Complex> quark_sink(nEigs);
		for (int iEv=0; iEv<nEigs; ++iEv) {
		  quark_sink(iEv) = qudaRes(iSink, iEv, t, iSpin);
		}
    DHputPtr->putData(RecordKey(iSpin+1,t,sinkBatchInds[iSink]), quark_sink);

		if (verbose){
		  QDPIO::cout << "dil = " << sinkBatchInds[iSink] <<", spin = "<<iSpin+1<< ", time = " << t << endl;
	          for (int n=0;n<nEigs;n++){
		    QDPIO::cout << "coef for eigenlevel "<<n<<" = "
			        << quark_sink(n)<<endl;
		  }
		} // verbose
	      } // spin  loop
	  } // batch index loop

          iotimer.stop();
          iotime+=iotimer.getTimeInSeconds();

	  iSinkBatch = 0;
       
       }  // batch projection end
    } // converged check
    else{
    
       QDPIO::cout << endl<<endl;
       QDPIO::cout << "Inversion FAILED to converge before max iteration reached"<<endl;
       QDPIO::cout << "Solution NOT WRITTEN to file"<<endl;
       QDPIO::cout << endl<<endl;}

    DHputPtr->flush();
    }

 totaltime.stop();
 QDPIO::cout << endl<<endl;
 QDPIO::cout << "computeQuarkSink: one noise, all dilutions, one source time: ran successfully" << endl;
 QDPIO::cout << "                 Total time = "<<totaltime.getTimeInSeconds() << " seconds" << endl;
 QDPIO::cout << "   Total source set up time = "<<srctime<<" seconds"<<endl;
 QDPIO::cout << "           ZN noise creation time = "<<noisetime<<" seconds"<<endl;
 QDPIO::cout << "              Initialization time = "<<inittime<<" seconds"<<endl;
 QDPIO::cout << "            LapH eigvec read time = "<<evreadtime<<" seconds"<<endl;
 QDPIO::cout << "            latfermA compute time = "<<latfermAtime<<" seconds"<<endl;
 QDPIO::cout << "                src rotation time = "<<rotatetime<<" seconds"<<endl;
 QDPIO::cout << "     Total time in inverter = "<<invtime<<" seconds"<<endl;
 QDPIO::cout << " Total sink completion time = "<<snktime<<" seconds"<<endl;
 QDPIO::cout << "             Inversion check time = "<<invchecktime<<" seconds"<<endl;
 QDPIO::cout << "               Sink rotation time = "<<snkrottime<<" seconds"<<endl;
 QDPIO::cout << "                   Peek spin time = "<<peekspintime<<" seconds"<<endl;
 QDPIO::cout << "          Color contractions time = "<<contracttime<<" seconds"<<endl;
 QDPIO::cout << "             Time in lattice sums = "<<sumtime<<" seconds"<<endl;
 QDPIO::cout << "Projection onto LapH eigvecs time = "<<evprojtime<<" seconds"<<endl;
 QDPIO::cout << "            LapH eigvec read time = "<<evread2time<<" seconds"<<endl;
 QDPIO::cout << "    Total file writing time = "<<iotime <<" seconds"<<endl;
 QDPIO::cout << endl<<endl;
 END_CODE();
}

*/


    // Creates the source (multiplied by gamma_4) in Dirac-Pauli basis

void QuarkHandler::make_source(LattField& ferm_src, const Array<cmplx>& laph_noise, 
                               std::vector<void*> evList, const list<int>& on_times, 
                               const list<int>& on_spins, const list<int>& on_eigs)
{
 printLaph(" Making source for this inversion...");
 if (evList.size()==0){
    errorLaph("Cannot make fermion source since no Laph eigenvectors available");}
 ferm_src.reset(FieldSiteType::ColorSpinVector);
 bool dp=(ferm_src.bytesPerWord()==sizeof(std::complex<double>));
    // initialize source field to zero
 int nsites=LayoutInfo::getRankLatticeNumSites();
 int ncmplx_per_site=ferm_src.elemsPerSite();
 int ncmplx=ncmplx_per_site*nsites;
 int cbytes;
 dcmplx zrhodp;
 fcmplx zrhosp;
 char *zrho;
 if (dp){
    double* z0=reinterpret_cast<double*>(ferm_src.getDataPtr());
    std::fill(z0,z0+2*ncmplx,0.0);
    cbytes=sizeof(std::complex<double>);
    zrho=reinterpret_cast<char*>(&zrhodp);}
 else{
    float* z0=reinterpret_cast<float*>(ferm_src.getDataPtr());
    std::fill(z0,z0+2*ncmplx,0.0);
    cbytes=sizeof(std::complex<float>);
    zrho=reinterpret_cast<char*>(&zrhosp);}

 int start_parity=LayoutInfo::getMyStartParity();
 int mytmin=LayoutInfo::getMyCommCoords()[3]*LayoutInfo::getRankLattSizes()[3];
 int mytmax=mytmin+LayoutInfo::getRankLattSizes()[3]-1;
 int tstride=LayoutInfo::getRankLattSizes()[0]*LayoutInfo::getRankLattSizes()[1]
            *LayoutInfo::getRankLattSizes()[2];
 int loc_nsites=LayoutInfo::getRankLatticeNumSites();
 int incx=FieldNcolor;
 int incy=FieldNcolor*FieldNspin;

 for (list<int>::const_iterator it0=on_times.begin();it0!=on_times.end();it0++){
    if (((*it0)>=mytmin)&&((*it0)<=mytmax)){
       int tloc=((*it0)-mytmin);
       int parshift=loc_nsites/2*((start_parity+tloc)%2);
       int start1=tstride*tloc/2 + parshift;
       int stop1=(1+tstride*(tloc+1))/2 + parshift;
       int n1=stop1-start1;
       parshift=loc_nsites/2*((start_parity+1+tloc)%2);
       int start2=(1+tstride*tloc)/2 + parshift;
       int stop2=(tstride*(tloc+1))/2 + parshift;
       int n2=stop2-start2;
       int xstart1=start1*incx*cbytes;
       int xstart2=start2*incx*cbytes;
       char* ystart1=ferm_src.getDataPtr()+start1*incy*cbytes;
       char* ystart2=ferm_src.getDataPtr()+start2*incy*cbytes;
       
       for (list<int>::const_iterator vmask= on_eigs.begin(); vmask!=on_eigs.end(); vmask++){
          char* x0=reinterpret_cast<char*>(evList[*vmask]);
          for (list<int>::const_iterator smask= on_spins.begin(); smask!=on_spins.end(); smask++){
             zrhodp=laph_noise(*it0,*smask,*vmask);
	     if (*smask>1){ zrhodp=-zrhodp;}  // multiply by gamma_4
	     if (!dp){
                zrhosp=complex<float>(real(zrhodp),imag(zrhodp));}
             char* x1=x0+xstart1;
             char* x2=x0+xstart2;
             char* y1=ystart1+(*smask)*incx*cbytes;
             char* y2=ystart2+(*smask)*incx*cbytes;
             for (int c=0;c<FieldNcolor;++c){
                if (dp){
                   cblas_zaxpy(n1,(dcmplx*)(zrho),(dcmplx*)(x1),incx,(dcmplx*)(y1),incy);
                   cblas_zaxpy(n2,(dcmplx*)(zrho),(dcmplx*)(x2),incx,(dcmplx*)(y2),incy);}
                else{
                   cblas_caxpy(n1,(fcmplx*)(zrho),(fcmplx*)(x1),incx,(fcmplx*)(y1),incy);
                   cblas_caxpy(n2,(fcmplx*)(zrho),(fcmplx*)(x2),incx,(fcmplx*)(y2),incy);}
                x1+=cbytes; y1+=cbytes; x2+=cbytes; y2+=cbytes;}}}}}
//    QDPIO::cout << "source created...starting inversion"<<endl;
//    bulova.stop(); srctime+=bulova.getTimeInSeconds();
//    seiko.stop(); rotatetime+=seiko.getTimeInSeconds();*/

// check norm (slow version)
/*
if (dp){
  double norm=0.0;
    double* z0=reinterpret_cast<double*>(ferm_src.getDataPtr());
    cout << "ncmplx = "<<ncmplx<<endl;
    for (int k=0;k<2*ncmplx;++k,++z0){
       norm+=(*z0)*(*z0);}
  cout  << "norm = "<<sqrt(norm)<<endl;}
*/      
  

 printLaph("Source for this inversion created");
}


/*
 int Textent = uPtr->getTimeExtent();
 int minTime = uPtr->getMinTime();
 int maxTime = uPtr->getMaxTime();
 int nTimes = maxTime - minTime + 1;
 const list<int>& onTimes=dilHandler->getOnTimes(time_proj_index);

 
 QDPIO::cout << "Running computeSink"<<endl<<endl;
 QDPIO::cout <<endl<< "Quark sink computation for all dilutions, one noise,"
             << " one time dilution projector beginning"<<endl;
 QDPIO::cout << " Time dilution projector index = "<<time_proj_index<<endl;
 START_CODE();
 StopWatch totaltime;
 totaltime.start();
 double iotime=0.0, srctime=0.0, snktime=0.0, invtime=0.0;
 double evreadtime=0.0, sumtime=0.0, evread2time=0.0, evprojtime=0.0;
 double noisetime=0.0, inittime=0.0, rotatetime=0.0, latfermAtime=0.0;
 double invchecktime=0.0, snkrottime=0.0, peekspintime=0.0, contracttime=0.0;
 
     // set the noise vector

 StopWatch rolex,bulova; rolex.start();bulova.start();
 LaphZnNoise rho(noise.getZNGroup(),noise.getSeed(*uPtr));
 int Tdir = uPtr->getTimeDir();
 int Nspin = QDP::Ns;
 uint nEigs = qSmearPtr->getNumberOfLaplacianEigenvectors();
  
 multi3d<DComplex> laph_noise=rho.generateLapHQuarkSourceForSink(Textent,nEigs,
                          qactionPtr->getTimeBoundaryConditions());
 if (qactionPtr->getTimeBoundaryConditions()==QuarkActionInfo::ZeroDirichlet){
    QDPIO::cout << " Laph noise generated for zero Dirichlet boundary condition in time"<<endl;}
 else if (qactionPtr->getTimeBoundaryConditions()==QuarkActionInfo::AntiPeriodic){
    QDPIO::cout << " Laph noise generated for antiperiodic boundary condition in time"<<endl;}
 rolex.stop(); noisetime+=rolex.getTimeInSeconds();
 
 rolex.reset();rolex.start();
 Set timeslices;                         // needed for time slice masks
 timeslices.make(TimeSlice(Tdir)); 

 Set centLat;
 centLat.make(TimeInterval(minTime, nTimes, Tdir));

 SpinMatrix SrcRotate = Gamma(8) * DiracToDRMat();   //  multiply by gamma_4
 SpinMatrix SnkRotate = adj(DiracToDRMat());    // rotate back to Dirac-Pauli

 string fermact_xml = qactionPtr->getDescription();
 string fermact_id = qactionPtr->getActionName();

   // Typedefs to save typing
 typedef LatticeFermion               T;
 typedef multi1d<LatticeColorMatrix>  P;
 typedef multi1d<LatticeColorMatrix>  Q;

 GroupXML_t solverInfo;
 solverInfo.xml =  invertPtr->output();
 solverInfo.id = invertPtr->getId();
 solverInfo.path = "//InvertParam";
 
   // Initialize fermion action
   
 istringstream xml_s(fermact_xml);
 XMLReader fermacttop0(xml_s);
 XMLReader fermacttop(fermacttop0,"./descendant-or-self::Description");   // due to XmlReader bug

 Handle< FermionAction<T,P,Q> > S_f; 
 Handle< FermState<T,P,Q> > state;
 Handle< SystemSolver<LatticeFermion> > PP;

#if defined(BUILD_OPENQCD12) || defined(BUILD_OPENQCD14) || defined(BUILD_OPENQCD16)
 if (invertPtr->getId().find("OPENQCD")!=std::string::npos) {

        // if using openQCD for the first time, initialize deflation subspace etc.

    if (!TheNamedObjMap::Instance().check("OpenQCDHandler")) {
       QDPIO::cout << "Setting up OpenQCD Handler" << endl;
       TheNamedObjMap::Instance().create<OpenQCDHandler>("OpenQCDHandler");
       OpenQCDHandler& oqcdHandler = TheNamedObjMap::Instance().getData<
               OpenQCDHandler>("OpenQCDHandler");
       oqcdHandler.init(uPtr->getFileName(),*qactionPtr, *invertPtr);}
        // reset the mass to make sure we are computing the correct inversions
    else {
       OpenQCDHandler& oqcdHandler = TheNamedObjMap::Instance().getData<OpenQCDHandler>("OpenQCDHandler");
       oqcdHandler.resetMass(*qactionPtr);}}
 else
#endif
{

 try{
    QDPIO::cout << "creating Fermion Action Factory"<<endl;
    QDPIO::cout << "  fermion action id = "<<qactionPtr->getActionName()<<endl;
    QDPIO::cout << "          solver id = "<<solverInfo.id<<endl;
    QDPIO::cout << "  fermact_xml:"<<endl<<fermact_xml<<endl;
    S_f=TheFermionActionFactory::Instance().createObject(
            fermact_id,fermacttop,"./descendant-or-self::FermionAction");
    state=S_f->createState(gaugeHandler->getData());
    PP = S_f->qprop(state,solverInfo); }
 catch(const std::exception& err){
    errorLaph(" Fermion action and inverter could not be initialized"
                << " in QuarkHandler"<<endl;
    errorLaph("solverInfo.xml:"<<endl<<solverInfo.xml<<endl;
    errorLaph("fermact_xml:"<<endl<<fermact_xml<<endl;
    QDP_abort(1);}
 QDPIO::cout << "Suitable FermionActionFactory found: Dirac matrix inversions may begin" << endl;

 if (qactionPtr->getTimeBoundaryConditions()==QuarkActionInfo::ZeroDirichlet){
    QDPIO::cout <<std::endl<<std::endl<<"WARNING: using Chroma inverter for Dirac solve "
                << "with zero Dirichlet time boundary conditions"<<std::endl
                << "  -- solution will differ from OpenQCD solve near temporal limits"
                <<std::endl<<std::endl;}

}
     // get the file key and open file for writing

 FileKey fkey(noise,time_proj_index);
 DHputPtr->open(fkey);
 int ndil=dilHandler->getNumberOfSpinEigvecProjectors();
 bulova.stop(); srctime+=bulova.getTimeInSeconds();
 rolex.stop(); inittime+=rolex.getTimeInSeconds();


#ifdef DO_CURRENT
   // prepare data structure to keep unsmeared sinks if necessary
 if (postSink) {
   // Check if the current sink map is already there
   // and create if it is not
   if (!TheNamedObjMap::Instance().check(CurrentHandler::quarkSinkMapID))
     TheNamedObjMap::Instance().create<CurrentHandler::quarkSinkMap>(
	   CurrentHandler::quarkSinkMapID);

   CurrentHandler::quarkSinkMap& theSinkMap =
     TheNamedObjMap::Instance().getData<CurrentHandler::quarkSinkMap>(
	 CurrentHandler::quarkSinkMapID);

     // reserve container size for spin and dilution components
   auto& sinkVec = theSinkMap[*qactionPtr][CurrentHandler::NoiseTimeKey(noise, onTimes)];
   sinkVec.resize(Nspin);
   for (unsigned int iS=0; iS<Nspin; ++iS)
     sinkVec[iS].reserve(ndil);
 }
#endif

     // loop over dilutions
 
 for (int dil=0;dil<ndil;dil++){

    bulova.reset();bulova.start();
    QDPIO::cout <<endl<< "Starting dilution "<<dil<<" (with "<<ndil-1<<" as last)"<<endl;
    bool doneflag=true;
    rolex.reset();rolex.start();
    for (int t=minTime;t<=maxTime;t++)
    for (int s=1;s<=Nspin;s++){
       if (!DHputPtr->queryData(RecordKey(s,t,dil))){
          doneflag=false; s=Nspin+1; t=Textent;}}
    rolex.stop(); evreadtime+=rolex.getTimeInSeconds();

    if ((!fPtr->isModeOverwrite())&&(doneflag) && (!postSink)){
       QDPIO::cout << "warning: these quark sinks already computed..."
                   << "skip re-computing since fileMode not overwrite"<<endl;
       continue;}

        // get the lists of which spins and which eigenvectors are
        // "on" for this dilution projector
        
    const list<int>& on_spins=dilHandler->getOnSpinIndices(dil);
    const list<int>& on_eigs=dilHandler->getOnEigvecIndices(dil);

        //  initialize output field for sources
    StopWatch seiko; seiko.start();
    LatticeFermion latfermA = zero;
    seiko.stop(); latfermAtime+=seiko.getTimeInSeconds();
    for (list<int>::const_iterator vmask= on_eigs.begin(); vmask!=on_eigs.end(); vmask++){
       rolex.reset();rolex.start();
       const LattField& Vs = qSmearHandler->getLaphEigenvector(*vmask);
       rolex.stop(); evreadtime+=rolex.getTimeInSeconds();
       seiko.reset();seiko.start();
       LatticeSpinVector sv = zero;
       for (list<int>::const_iterator smask= on_spins.begin(); smask!=on_spins.end(); smask++){
          LatticeComplex temp = zero;
               // apply time dilution projector
          for (list<int>::const_iterator it0=onTimes.begin();
             it0!=onTimes.end();it0++){
             temp[timeslices[*it0]] = laph_noise(*it0,*smask,*vmask);}
          pokeSpin(sv,temp,*smask);}
       for (list<int>::const_iterator it0=onTimes.begin();
          it0!=onTimes.end();it0++){
          latfermA[timeslices[*it0]] += sv * Vs;}
       seiko.stop(); latfermAtime+=seiko.getTimeInSeconds();
       }

    seiko.reset();seiko.start();       
    LatticeFermion latfermB = SrcRotate * latfermA;  // rotate to DeGrand-Rossi, mult by gamma_4

    QDPIO::cout << "Norm of source vector = "<<sqrt(norm2(latfermB))<<endl;
    latfermA = zero;
    SystemSolverResults_t res;

#if defined(BUILD_OPENQCD12) || defined(BUILD_OPENQCD14) || defined(BUILD_OPENQCD16)
    if (invertPtr->getId().find("OPENQCD")!=std::string::npos) {
       OpenQCDHandler& oqcdHandler = TheNamedObjMap::Instance().getData<
               OpenQCDHandler>("OpenQCDHandler");

       QDPIO::cout << "source created...starting inversion with openQCD"
               << endl;
       bulova.stop();
       srctime += bulova.getTimeInSeconds();
       seiko.stop();
       rotatetime += seiko.getTimeInSeconds();

       // now do the inversion
       bulova.reset();
       bulova.start();
       res = oqcdHandler.solve(latfermA, latfermB); // solution in latfermA
       bulova.stop();
       invtime += bulova.getTimeInSeconds();

#ifdef DIRAC_SOLVE_CHECK
       checkCloverSolution(latfermA,latfermB,fermacttop,fermact_id,gaugeHandler.get());
#endif
        } else
#endif
    {

    QDPIO::cout << "source created...starting inversion"<<endl;
    bulova.stop(); srctime+=bulova.getTimeInSeconds();
    seiko.stop(); rotatetime+=seiko.getTimeInSeconds();
    
    // now do the inversion
    bulova.reset();bulova.start();
    res = (*PP)(latfermA, latfermB);  // solution in latfermA
    bulova.stop(); invtime+=bulova.getTimeInSeconds();

    QDPIO::cout << "Inversion done:  number of iterations = "<<res.n_count<<endl;
    QDPIO::cout << " Residual = "<<res.resid<<endl;

           // output the relative residual of the unpreconditioned system, if possible
           // The fermion action named "CLOVER" is even-odd preconditioned.
           // So one solves for either the even or the odd sites only with a modified
           // Dirac matrix, then the other sites are obtained algebraically.
#ifdef DIRAC_SOLVE_CHECK
    bulova.reset();bulova.start(); 
    rolex.reset();rolex.start();
    if (fermact_id=="CLOVER"){
       try{
        CloverFermActParams cparams(fermacttop,
                      "./descendant-or-self::FermionAction");
        UnprecCloverLinOp Dclover(state,cparams);
        T r=latfermB;
        T Mx;
        Dclover( Mx, latfermA, PLUS);
        r -= Mx;

        double ynorm2=toDouble(norm2(latfermB));
        LatticeReal lnorm=localNorm2(r);
        double localmag=toDouble(sqrt(globalMax(lnorm)/ynorm2));
        double relresidunprec=toDouble(sqrt(sum(lnorm)/ynorm2));

        QDPIO::cout << " Relative residual is  r = M*x-y / |y|"
                    << " for unpreconditioned system"<<endl;
        QDPIO::cout << " Relative residual of unpreconditioned system = |r| = "
                    << relresidunprec << endl;
        QDPIO::cout << "                       Maximum local magnitude of r = "
                    <<localmag<< endl<<endl;}
       catch(const std::exception& xp){
          QDPIO::cout << "could not evaluate relative residual of "
                      << "unpreconditioned clover system"<<endl;}}
    bulova.stop(); snktime+=bulova.getTimeInSeconds();
    rolex.stop(); invchecktime+=rolex.getTimeInSeconds();
#endif       
    } //non-openQCD inversions

    if ((res.n_count>0)&&(res.n_count<=invertPtr->getMaxIterations())){

       rolex.reset();rolex.start();
       latfermB = SnkRotate * latfermA;         // rotate back to Dirac-Pauli
       rolex.stop(); snkrottime+=rolex.getTimeInSeconds();
       multi2d<Complex> quark_sink(nTimes,nEigs);
       multi1d<DComplex> tres(Textent);
       double evprojtime_tmp=0.0;
       
        // sink = Vs^dagger * phi

       for (int s=0;s<Nspin;s++){
          bulova.reset();bulova.start(); 
          rolex.reset();rolex.start();
          LattField phi_s = peekSpin(latfermB, s);
          rolex.stop(); peekspintime+=rolex.getTimeInSeconds();

#ifdef DO_CURRENT
	    // post the unsmeared sinks to CurrentHandler
	  if (postSink) {
	    CurrentHandler::quarkSinkMap& theSinkMap =
	      TheNamedObjMap::Instance().getData<CurrentHandler::quarkSinkMap>(
		  CurrentHandler::quarkSinkMapID);
	    auto& sinkVec = theSinkMap[*qactionPtr][CurrentHandler::NoiseTimeKey(noise, onTimes)];
	    sinkVec[s].push_back(phi_s);
	  }
#endif
	    // If the quark sink was in the file already we can skip this part
	  if (doneflag)
	    continue;

	    // TODO this projection should be batched up for several solutions
          for (int n=0;n<nEigs;n++){
             rolex.reset();rolex.start();
             //QDPIO::cout << "projecting onto LapH eigenvector "<<n<<endl;
             const LattField& Ws= qSmearHandler->getLaphEigenvector(n);
             qSmearHandler->closeLaphLevelFiles();  // prevent too many files being open
             rolex.stop(); evread2time+=rolex.getTimeInSeconds();
             rolex.reset();rolex.start();
             LatticeComplex tmp;
             if (nTimes==Textent)
                tmp = localInnerProduct( Ws, phi_s );  // color contraction
             else
                tmp[centLat[0]] = localInnerProduct(Ws, phi_s); // color contraction
             rolex.stop(); contracttime+=rolex.getTimeInSeconds();
             rolex.reset();rolex.start();
             tres = sumMulti(tmp,timeslices);  // spatial sums on each timeslice
             rolex.stop(); sumtime+=rolex.getTimeInSeconds();
             for (int t=minTime;t<=maxTime;t++){
                quark_sink(t-minTime,n)=tres[t];}}
          bulova.stop(); snktime+=bulova.getTimeInSeconds();
          evprojtime_tmp+=bulova.getTimeInSeconds();

           // output to file
          StopWatch iotimer; iotimer.start();
          for (int t=minTime;t<=maxTime;t++)
             DHputPtr->putData(RecordKey(s+1,t,dil),quark_sink[t-minTime]);

          if (verbose){
          QDPIO::cout << "spin = "<<s+1<<endl;
          for (int t=0;t<nTimes;t++){
             QDPIO::cout << "time = "<<t+minTime<<endl;
             for (int n=0;n<nEigs;n++){
                QDPIO::cout << "coef for eigenlevel "<<n<<" = "
                            << quark_sink(t,n)<<endl;}}}

          iotimer.stop();
          iotime+=iotimer.getTimeInSeconds();}
       evprojtime+=evprojtime_tmp;
       QDPIO::cout << "Time for projection onto LapH eigvecs = "<<evprojtime_tmp<<" seconds"<<endl;
       }

    else{
    
       QDPIO::cout << endl<<endl;
       QDPIO::cout << "Inversion FAILED to converge before max iteration reached"<<endl;
       QDPIO::cout << "Solution NOT WRITTEN to file"<<endl;
       QDPIO::cout << endl<<endl;}

    DHputPtr->flush();
    }

 totaltime.stop();
 QDPIO::cout << endl<<endl;
 QDPIO::cout << "computeQuarkSink: one noise, all dilutions, one source time: ran successfully" << endl;
 QDPIO::cout << "                 Total time = "<<totaltime.getTimeInSeconds() << " seconds" << endl;
 QDPIO::cout << "   Total source set up time = "<<srctime<<" seconds"<<endl;
 QDPIO::cout << "           ZN noise creation time = "<<noisetime<<" seconds"<<endl;
 QDPIO::cout << "              Initialization time = "<<inittime<<" seconds"<<endl;
 QDPIO::cout << "            LapH eigvec read time = "<<evreadtime<<" seconds"<<endl;
 QDPIO::cout << "            latfermA compute time = "<<latfermAtime<<" seconds"<<endl;
 QDPIO::cout << "                src rotation time = "<<rotatetime<<" seconds"<<endl;
 QDPIO::cout << "     Total time in inverter = "<<invtime<<" seconds"<<endl;
 QDPIO::cout << " Total sink completion time = "<<snktime<<" seconds"<<endl;
 QDPIO::cout << "             Inversion check time = "<<invchecktime<<" seconds"<<endl;
 QDPIO::cout << "               Sink rotation time = "<<snkrottime<<" seconds"<<endl;
 QDPIO::cout << "                   Peek spin time = "<<peekspintime<<" seconds"<<endl;
 QDPIO::cout << "          Color contractions time = "<<contracttime<<" seconds"<<endl;
 QDPIO::cout << "             Time in lattice sums = "<<sumtime<<" seconds"<<endl;
 QDPIO::cout << "Projection onto LapH eigvecs time = "<<evprojtime<<" seconds"<<endl;
 QDPIO::cout << "            LapH eigvec read time = "<<evread2time<<" seconds"<<endl;
 QDPIO::cout << "    Total file writing time = "<<iotime <<" seconds"<<endl;
 QDPIO::cout << endl<<endl;
 END_CODE();*/




   // ***************************************************************
/*

    //  do inversions for all spin-laph-eigenvector dilution indices
    //  but for one noise, one time projector index
    //  This version uses BLAS to perform the Laph eigenvector projections.


void QuarkHandler::computeSink2(const LaphNoiseInfo& noise, int time_proj_index, bool verbose)
{
 if ((!isInfoSet())||(invertPtr==0)){
    errorLaph("cannot computeSink in QuarkHandler until"
                << " info and inverter set"<<endl;
    QDP_abort(1);}

 if (!dilHandler->isValidTimeProjectorIndex(time_proj_index)){
    errorLaph("invalid time projector index "<<time_proj_index
                <<" for compute in QuarkHandler"<<endl;
    errorLaph(" skipping this computation"<<endl;
    return;}

 int Textent = uPtr->getTimeExtent();
 int minTime = uPtr->getMinTime();
 int maxTime = uPtr->getMaxTime();
 int nTimes = maxTime - minTime + 1;
 const list<int>& onTimes=dilHandler->getOnTimes(time_proj_index);
 int nEigs = qSmearPtr->getNumberOfLaplacianEigenvectors();
 int Tdir = uPtr->getTimeDir();
 int Ncolor = QDP::Nc;

 QDPIO::cout << "Running computeSink2"<<endl<<endl;
 QDPIO::cout <<endl<< "Quark sink computation for all dilutions, one noise,"
             << " one time dilution projector beginning"<<endl;
 QDPIO::cout << " Time dilution projector index = "<<time_proj_index<<endl;
 START_CODE();
 StopWatch totaltime;
 totaltime.start();
 double iotime=0.0, srctime=0.0, snktime=0.0, invtime=0.0;
 double evreadtime=0.0, evprojtime=0.0;
 double noisetime=0.0, inittime=0.0, rotatetime=0.0, latfermAtime=0.0;
 double invchecktime=0.0, snkrottime=0.0;
 
    // read in all LapH eigenvectors for BLAS projections, place in TheNamedObjMap
    // form vector of pointers to the eigenvectors

 StopWatch rolex; rolex.start();
        // if LapH eigenvectors are not in TheNamedObjMap, put them in there
 if (!TheNamedObjMap::Instance().check("ProjLaphEVs")) {
    QDPIO::cout << "Reading the LapH eigenvectors" << endl;
    TheNamedObjMap::Instance().create<multi1d<LattField>>("ProjLaphEVs");
    multi1d<LattField>& laphevs = TheNamedObjMap::Instance().getData<multi1d<LattField>>("ProjLaphEVs");
    laphevs.resize(nEigs);
    for (uint j=0;j<nEigs;++j){
       laphevs[j] = qSmearHandler->getLaphEigenvector(j);  // do copy
       qSmearHandler->removeLaphEigenvector(j);}}
          // access to the eigenvectors through reference "laphevs"
 multi1d<LattField>& laphevs = TheNamedObjMap::Instance().getData<multi1d<LattField>>("ProjLaphEVs");
    // form vector of pointers to the eigenvectors for use by BLAS routine
 vector<const cmplxf*> laphev_ptrs(nEigs);
 for (uint j=0;j<nEigs;++j){
    const char* tptr=(char*)&(laphevs[j].elem(0).elem().elem(0).real());
    laphev_ptrs[j]=reinterpret_cast<const cmplxf*>(tptr);}
 rolex.stop(); evreadtime+=rolex.getTimeInSeconds();
 QDPIO::cout << "LapH eigenvector set up time = "<<evreadtime<<" seconds"<<endl;

     // set the noise vector

 StopWatch bulova; rolex.reset(); rolex.start();bulova.start();
 LaphZnNoise rho(noise.getZNGroup(),noise.getSeed(*uPtr));
 int Nspin = QDP::Ns;
  
 multi3d<DComplex> laph_noise=rho.generateLapHQuarkSourceForSink(Textent,nEigs,
                          qactionPtr->getTimeBoundaryConditions());
 if (qactionPtr->getTimeBoundaryConditions()==QuarkActionInfo::ZeroDirichlet){
    QDPIO::cout << " Laph noise generated for zero Dirichlet boundary condition in time"<<endl;}
 else if (qactionPtr->getTimeBoundaryConditions()==QuarkActionInfo::AntiPeriodic){
    QDPIO::cout << " Laph noise generated for antiperiodic boundary condition in time"<<endl;}
 rolex.stop(); noisetime+=rolex.getTimeInSeconds();
 
 rolex.reset();rolex.start();
 Set timeslices;                         // needed for time slice masks
 timeslices.make(TimeSlice(Tdir)); 

 Set centLat;
 centLat.make(TimeInterval(minTime, nTimes, Tdir));

 SpinMatrix SrcRotate = Gamma(8) * DiracToDRMat();   //  multiply by gamma_4
 SpinMatrix SnkRotate = adj(DiracToDRMat());    // rotate back to Dirac-Pauli

 string fermact_xml = qactionPtr->getDescription();
 string fermact_id = qactionPtr->getActionName();

   // Typedefs to save typing
 typedef LatticeFermion               T;
 typedef multi1d<LatticeColorMatrix>  P;
 typedef multi1d<LatticeColorMatrix>  Q;

 GroupXML_t solverInfo;
 solverInfo.xml =  invertPtr->output();
 solverInfo.id = invertPtr->getId();
 solverInfo.path = "//InvertParam";
 
   // Initialize fermion action
   
 istringstream xml_s(fermact_xml);
 XMLReader fermacttop0(xml_s);
 XMLReader fermacttop(fermacttop0,"./descendant-or-self::Description");   // due to XmlReader bug

 Handle< FermionAction<T,P,Q> > S_f; 
 Handle< FermState<T,P,Q> > state;
 Handle< SystemSolver<LatticeFermion> > PP;

#if defined(BUILD_OPENQCD12) || defined(BUILD_OPENQCD14) || defined(BUILD_OPENQCD16)
 if (invertPtr->getId().find("OPENQCD")!=std::string::npos) {

        // if using openQCD for the first time, initialize deflation subspace etc.

    if (!TheNamedObjMap::Instance().check("OpenQCDHandler")) {
       QDPIO::cout << "Setting up OpenQCD Handler" << endl;
       TheNamedObjMap::Instance().create<OpenQCDHandler>("OpenQCDHandler");
       OpenQCDHandler& oqcdHandler = TheNamedObjMap::Instance().getData<
               OpenQCDHandler>("OpenQCDHandler");
       oqcdHandler.init(uPtr->getFileName(),*qactionPtr, *invertPtr);}
        // reset the mass to make sure we are computing the correct inversions
    else {
       OpenQCDHandler& oqcdHandler = TheNamedObjMap::Instance().getData<OpenQCDHandler>("OpenQCDHandler");
       oqcdHandler.resetMass(*qactionPtr);}}
 else
#endif
{

 try{
    QDPIO::cout << "creating Fermion Action Factory"<<endl;
    QDPIO::cout << "  fermion action id = "<<qactionPtr->getActionName()<<endl;
    QDPIO::cout << "          solver id = "<<solverInfo.id<<endl;
    QDPIO::cout << "  fermact_xml:"<<endl<<fermact_xml<<endl;
    S_f=TheFermionActionFactory::Instance().createObject(
            fermact_id,fermacttop,"./descendant-or-self::FermionAction");
    state=S_f->createState(gaugeHandler->getData());
    PP = S_f->qprop(state,solverInfo); }
 catch(const std::exception& err){
    errorLaph(" Fermion action and inverter could not be initialized"
                << " in QuarkHandler"<<endl;
    errorLaph("solverInfo.xml:"<<endl<<solverInfo.xml<<endl;
    errorLaph("fermact_xml:"<<endl<<fermact_xml<<endl;
    QDP_abort(1);}
 QDPIO::cout << "Suitable FermionActionFactory found: Dirac matrix inversions may begin" << endl;

 if (qactionPtr->getTimeBoundaryConditions()==QuarkActionInfo::ZeroDirichlet){
    QDPIO::cout <<std::endl<<std::endl<<"WARNING: using Chroma inverter for Dirac solve "
                << "with zero Dirichlet time boundary conditions"<<std::endl
                << "  -- solution will differ from OpenQCD solve near temporal limits"
                <<std::endl<<std::endl;}

}
     // get the file key and open file for writing

 FileKey fkey(noise,time_proj_index);
 DHputPtr->open(fkey);
 int ndil=dilHandler->getNumberOfSpinEigvecProjectors();
 bulova.stop(); srctime+=bulova.getTimeInSeconds();
 rolex.stop(); inittime+=rolex.getTimeInSeconds();

     // loop over dilutions
 
 for (int dil=0;dil<ndil;dil++){

    StopWatch dtimer; dtimer.start();
    bulova.reset();bulova.start();
    QDPIO::cout <<endl<< "Starting dilution "<<dil<<" (with "<<ndil-1<<" as last)"<<endl;
    bool doneflag=true;
    rolex.reset();rolex.start();
    for (int t=minTime;t<=maxTime;t++)
    for (int s=1;s<=Nspin;s++){
       if (!DHputPtr->queryData(RecordKey(s,t,dil))){
          doneflag=false; s=Nspin+1; t=Textent;}}
    rolex.stop(); evreadtime+=rolex.getTimeInSeconds();

    if ((!fPtr->isModeOverwrite())&&(doneflag)){
       QDPIO::cout << "warning: these quark sinks already computed..."
                   << "skip re-computing since fileMode not overwrite"<<endl;
       bulova.stop();
       continue;}

        // get the lists of which spins and which eigenvectors are
        // "on" for this dilution projector
        
    const list<int>& on_spins=dilHandler->getOnSpinIndices(dil);
    const list<int>& on_eigs=dilHandler->getOnEigvecIndices(dil);

        //  initialize field for sources
    StopWatch seiko; seiko.start();
    LatticeFermion latfermA = zero;
    seiko.stop(); latfermAtime+=seiko.getTimeInSeconds();
    for (list<int>::const_iterator vmask= on_eigs.begin(); vmask!=on_eigs.end(); vmask++){
       LattField& Vs=laphevs[*vmask];
       seiko.reset();seiko.start();
       LatticeSpinVector sv = zero;
       for (list<int>::const_iterator smask= on_spins.begin(); smask!=on_spins.end(); smask++){
          LatticeComplex temp = zero;
               // apply time dilution projector
          for (list<int>::const_iterator it0=onTimes.begin();
             it0!=onTimes.end();it0++){
             temp[timeslices[*it0]] = laph_noise(*it0,*smask,*vmask);}
          pokeSpin(sv,temp,*smask);}
       for (list<int>::const_iterator it0=onTimes.begin();
          it0!=onTimes.end();it0++){
          latfermA[timeslices[*it0]] += sv * Vs;}
       seiko.stop(); latfermAtime+=seiko.getTimeInSeconds();
       }
    seiko.reset();seiko.start();       
    LatticeFermion latfermB = SrcRotate * latfermA;  // rotate to DeGrand-Rossi, mult by gamma_4

    QDPIO::cout << "Norm of source vector = "<<sqrt(norm2(latfermB))<<endl;
    latfermA = zero;
    SystemSolverResults_t res;

#if defined(BUILD_OPENQCD12) || defined(BUILD_OPENQCD14) || defined(BUILD_OPENQCD16)
    if (invertPtr->getId().find("OPENQCD")!=std::string::npos) {
       OpenQCDHandler& oqcdHandler = TheNamedObjMap::Instance().getData<
               OpenQCDHandler>("OpenQCDHandler");

       QDPIO::cout << "source created...starting inversion with openQCD"<< endl;
       bulova.stop();
       srctime += bulova.getTimeInSeconds();
       QDPIO::cout << "source set up time = "<<bulova.getTimeInSeconds()<<" seconds"<<endl;
       seiko.stop();
       rotatetime += seiko.getTimeInSeconds();

       // now do the inversion
       bulova.reset();
       bulova.start();
       res = oqcdHandler.solve(latfermA, latfermB); // solution in latfermA
       bulova.stop();
       invtime += bulova.getTimeInSeconds();
       QDPIO::cout << "inversion time = "<<bulova.getTimeInSeconds()<<" seconds"<<endl;

#ifdef DIRAC_SOLVE_CHECK
       checkCloverSolution(latfermA,latfermB,fermacttop,fermact_id,gaugeHandler.get());
#endif
        } else
#endif
    {

    QDPIO::cout << "source created...starting inversion"<<endl;
    bulova.stop(); srctime+=bulova.getTimeInSeconds();
    QDPIO::cout << "source set up time = "<<bulova.getTimeInSeconds()<<" seconds"<<endl;
    seiko.stop(); rotatetime+=seiko.getTimeInSeconds();
    
    // now do the inversion
    bulova.reset();bulova.start();
    res = (*PP)(latfermA, latfermB);  // solution in latfermA
    bulova.stop(); invtime+=bulova.getTimeInSeconds();
    QDPIO::cout << "inversion time = "<<bulova.getTimeInSeconds()<<" seconds"<<endl;

    QDPIO::cout << "Inversion done:  number of iterations = "<<res.n_count<<endl;
    QDPIO::cout << " Residual = "<<res.resid<<endl;

           // output the relative residual of the unpreconditioned system, if possible
           // The fermion action named "CLOVER" is even-odd preconditioned.
           // So one solves for either the even or the odd sites only with a modified
           // Dirac matrix, then the other sites are obtained algebraically.
#ifdef DIRAC_SOLVE_CHECK
    bulova.reset();bulova.start(); 
    rolex.reset();rolex.start();
    if (fermact_id=="CLOVER"){
       try{
        CloverFermActParams cparams(fermacttop,
                      "./descendant-or-self::FermionAction");
        UnprecCloverLinOp Dclover(state,cparams);
        T r=latfermB;
        T Mx;
        Dclover( Mx, latfermA, PLUS);
        r -= Mx;

        double ynorm2=toDouble(norm2(latfermB));
        LatticeReal lnorm=localNorm2(r);
        double localmag=toDouble(sqrt(globalMax(lnorm)/ynorm2));
        double relresidunprec=toDouble(sqrt(sum(lnorm)/ynorm2));

        QDPIO::cout << " Relative residual is  r = M*x-y / |y|"
                    << " for unpreconditioned system"<<endl;
        QDPIO::cout << " Relative residual of unpreconditioned system = |r| = "
                    << relresidunprec << endl;
        QDPIO::cout << "                       Maximum local magnitude of r = "
                    <<localmag<< endl<<endl;}
       catch(const std::exception& xp){
          QDPIO::cout << "could not evaluate relative residual of "
                      << "unpreconditioned clover system"<<endl;}}
    bulova.stop(); snktime+=bulova.getTimeInSeconds();
    rolex.stop(); invchecktime+=rolex.getTimeInSeconds();
    QDPIO::cout << "inversion check time = "<<rolex.getTimeInSeconds()<<" seconds"<<endl;
#endif    
    } //non-openQCD inversions

    if ((res.n_count>0)&&(res.n_count<=invertPtr->getMaxIterations())){

       rolex.reset();rolex.start();
       latfermB = SnkRotate * latfermA;         // rotate back to Dirac-Pauli
       rolex.stop(); snkrottime+=rolex.getTimeInSeconds();
       multi1d<Complex> projections;      // will contains the nEigs*Textent*Nspin projections
       seiko.reset(); seiko.start();
       
        // sink = Vs^dagger * phi   (Do the projections onto the Laph eigvecs)

       projectOntoLaphEigvecs(latfermB,laphev_ptrs,projections,nEigs,Textent);
       seiko.stop(); 
       QDPIO::cout << "Projection onto LapH eigenvectors takes "<<seiko.getTimeInSeconds()<<" seconds"<<endl;
       evprojtime+=seiko.getTimeInSeconds();

       // output to file

       StopWatch otimer; otimer.start();
       for (int s=0;s<Nspin;s++){
          for (int t=minTime;t<=maxTime;t++){
             multi1d<Complex> quark_sink(nEigs);
             uint k=t+s*nEigs*Textent;
             for (int n=0;n<nEigs;++n,k+=Textent){
                quark_sink(n)=projections[k];}
             DHputPtr->putData(RecordKey(s+1,t,dil),quark_sink);}}
       if (verbose){
          for (int s=0;s<Nspin;s++){
             QDPIO::cout << "spin = "<<s+1<<endl;
             for (int t=minTime;t<=maxTime;t++){
                QDPIO::cout << "time = "<<t+minTime<<endl;
                uint k=t+s*nEigs*Textent;
                for (int n=0;n<nEigs;++n,k+=Textent){
                   QDPIO::cout << "coef for eigenlevel "<<n<<" = "
                               << projections[k]<<endl;}}}}
       otimer.stop();
       QDPIO::cout << "Output results to file time = "<<otimer.getTimeInSeconds()<<endl;
       }

    else{
    
       QDPIO::cout << endl<<endl;
       QDPIO::cout << "Inversion FAILED to converge before max iteration reached"<<endl;
       QDPIO::cout << "Solution NOT WRITTEN to file"<<endl;
       QDPIO::cout << endl<<endl;}

    DHputPtr->flush();
    dtimer.stop();
    QDPIO::cout << "Total time for this dilution = "<<dtimer.getTimeInSeconds()<<endl;
    }

 totaltime.stop();
 QDPIO::cout << endl<<endl;
 QDPIO::cout << "computeQuarkSink: one noise, all dilutions, one source time: ran successfully" << endl;
 QDPIO::cout << "                 Total time = "<<totaltime.getTimeInSeconds() << " seconds" << endl;
 QDPIO::cout << "   Total source set up time = "<<srctime<<" seconds"<<endl;
 QDPIO::cout << "           ZN noise creation time = "<<noisetime<<" seconds"<<endl;
 QDPIO::cout << "              Initialization time = "<<inittime<<" seconds"<<endl;
 QDPIO::cout << "            LapH eigvec read time = "<<evreadtime<<" seconds"<<endl;
 QDPIO::cout << "            latfermA compute time = "<<latfermAtime<<" seconds"<<endl;
 QDPIO::cout << "                src rotation time = "<<rotatetime<<" seconds"<<endl;
 QDPIO::cout << "     Total time in inverter = "<<invtime<<" seconds"<<endl;
 QDPIO::cout << " Total sink completion time = "<<snktime<<" seconds"<<endl;
 QDPIO::cout << "             Inversion check time = "<<invchecktime<<" seconds"<<endl;
 QDPIO::cout << "               Sink rotation time = "<<snkrottime<<" seconds"<<endl;
 QDPIO::cout << "Projection onto LapH eigvecs time = "<<evprojtime<<" seconds"<<endl;
 QDPIO::cout << "    Total file writing time = "<<iotime <<" seconds"<<endl;
 QDPIO::cout << endl<<endl;
 END_CODE();
}
*/

  // ******************************************************************

   //  Projects a solution "latferm" of the Dirac equation onto the "nEigs" eigenvectors of the
   //  covariant Laplacian for each spin index and each time slice.  The LapH eigenvectors
   //  should be in laphevs with time as slowest varying index and eigenvector index the
   //  fastest varying index.  Results are returned in "projections" with spin as 
/*
void projectOntoLaphEigvecs1(const LatticeFermion& latferm, const multi1d<LattField>& laphevs,
                             multi1d<Complex>& projections, uint nEigs, uint Textent)
{
 QDPIO::cout << "Starting projectOntoLaphEigvecs"<<endl;
 Set timeslices;
 timeslices.make(TimeSlice(QDP::Nd-1)); 
 multi1d<DComplex> tres(Textent);
 LatticeComplex tmp;
 LattField phi_s;
 int Nspin = QDP::Ns; 
 projections.resize(nEigs*Textent*QDP::Ns);

 for (int s=0;s<Nspin;s++){
    phi_s = peekSpin(latferm, s);
    for (int n=0;n<nEigs;n++){
       tmp = localInnerProduct( laphevs[n], phi_s );  // color contraction
       tres = sumMulti(tmp,timeslices);  // spatial sums on each timeslice
       uint k=Textent*(n+nEigs*s);
       for (uint t=0;t<Textent;++t,++k){
          projections[k]=tres[t];}}}
 QDPIO::cout << "Finished projectOntoLaphEigvecs"<<endl;
}
*/


      // BLAS projections:  assumes the following formats
      //     latferm(color,spin,x,y,z,t)      slowest index on right
      //     laphevs(color,x,y,z,t)[eigindex]  slowest index on right
      //     projections(time,eigindex,spin)  slowest index on right
      // This version assumes lexico layout

/*

void QuarkHandler::projectOntoLaphEigvecs(const LatticeFermion& latferm, const std::vector<const cmplxf*>& laphev_ptrs,
                                          multi1d<Complex>& projections, uint nEigs, uint Textent)
{
 QDPIO::cout << "Starting projectOntoLaphEigvecs for lexico layout"<<endl;
 LattField phi_s;
 int Nspin = QDP::Ns; 
 projections.resize(Textent*nEigs*QDP::Ns);
 projections=zero;

  // determine what times are on this MPI rank
 uint minTime=Layout::nodeCoord()[QDP::Nd-1]*Layout::subgridLattSize()[QDP::Nd-1];
 uint maxTime=minTime+Layout::subgridLattSize()[QDP::Nd-1]-1;
 uint vecsize=QDP::Nc*Layout::subgridLattSize()[0]*Layout::subgridLattSize()[1]*Layout::subgridLattSize()[2];
 char *tptr2=(char*)&(projections[0].elem().elem().elem().real());
 cmplxf *r1=reinterpret_cast<cmplxf*>(tptr2);

 for (int s=0;s<Nspin;s++){
    phi_s = peekSpin(latferm, s);
    const char* tptr=(char*)&(phi_s.elem(0).elem().elem(0).real());
    const cmplxf* sol1=reinterpret_cast<const cmplxf*>(tptr);
    for (int n=0;n<nEigs;++n,r1+=Textent){
       const cmplxf* ev=laphev_ptrs[n];
       const cmplxf* sol=sol1;
       cmplxf *res=r1+minTime;
       for (int t=minTime;t<=maxTime;++t,++res){
#if (BASE_PRECISION==64)
          cblas_zdotc_sub(vecsize,ev,1,sol,1,res);
#else
          cblas_cdotc_sub(vecsize,ev,1,sol,1,res);
#endif
          sol+=vecsize;
          ev+=vecsize;}}}
#if  defined(ARCH_PARSCALAR) || defined(ARCH_PARSCALARVEC)
 QMP_barrier();
 QDPInternal::globalSumArray(projections);
#endif
 //QDPIO::cout << "Finished projectOntoLaphEigvecs"<<endl;
 //for (int i=0;i<projections.size();++i) QDPIO::cout << "projections["<<i<<"] = "<<projections[i]<<endl;
}

#elif ( QDP_USE_CB2_LAYOUT == 1 )

          // This version assume checkerboard 2 layout (red/black sites)

void QuarkHandler::projectOntoLaphEigvecs(const LatticeFermion& latferm, const std::vector<const cmplxf*>& laphev_ptrs,
                                          multi1d<Complex>& projections, uint nEigs, uint Textent)
{
 QDPIO::cout << "Starting projectOntoLaphEigvecs for CB2 layout"<<endl;
 LattField phi_s;
 int Nspin = QDP::Ns; 
 multi1d<Complex> red(Textent*nEigs*QDP::Ns), black(Textent*nEigs*QDP::Ns);
 red=zero; black=zero;

  // determine what times are on this MPI rank
 uint minTime=Layout::nodeCoord()[QDP::Nd-1]*Layout::subgridLattSize()[QDP::Nd-1];
 uint maxTime=minTime+Layout::subgridLattSize()[QDP::Nd-1]-1;
 uint vecsize=QDP::Nc*Layout::subgridLattSize()[0]*Layout::subgridLattSize()[1]*Layout::subgridLattSize()[2];
 char *tptr2=(char*)&(red[0].elem().elem().elem().real());
 cmplxf *r1=reinterpret_cast<cmplxf*>(tptr2);
 tptr2=(char*)&(black[0].elem().elem().elem().real());
 cmplxf *r2=reinterpret_cast<cmplxf*>(tptr2);
 vecsize/=2;
 uint shift=vecsize*Layout::subgridLattSize()[QDP::Nd-1];

 for (int s=0;s<Nspin;s++){
    phi_s = peekSpin(latferm, s);
    const char* tptr=(char*)&(phi_s.elem(0).elem().elem(0).real());
    const cmplxf* sol1=reinterpret_cast<const cmplxf*>(tptr);
    for (int n=0;n<nEigs;++n,r1+=Textent,r2+=Textent){
       const cmplxf* ev=laphev_ptrs[n];
       const cmplxf* sol=sol1;
       cmplxf *res1=r1+minTime;
       cmplxf *res2=r2+minTime;
       for (int t=minTime;t<=maxTime;++t,++res1,++res2){
#if (BASE_PRECISION==64)
          cblas_zdotc_sub(vecsize,ev,1,sol,1,res1);
          cblas_zdotc_sub(vecsize,ev+shift,1,sol+shift,1,res2);
#else
          cblas_cdotc_sub(vecsize,ev,1,sol,1,res1);
          cblas_cdotc_sub(vecsize,ev+shift,1,sol+shift,1,res2);
#endif
          sol+=vecsize;
          ev+=vecsize;}}}
#if  defined(ARCH_PARSCALAR) || defined(ARCH_PARSCALARVEC)
 QMP_barrier();
#endif
 projections=red+black;
#if  defined(ARCH_PARSCALAR) || defined(ARCH_PARSCALARVEC)
 QDPInternal::globalSumArray(projections);
#endif
 //QDPIO::cout << "Finished projectOntoLaphEigvecs"<<endl;
 //for (int i=0;i<projections.size();++i) QDPIO::cout << "projections["<<i<<"] = "<<projections[i]<<endl;
}

#endif
#endif
*/
  // **************************************************************************

/*
void QuarkHandler::checkCloverSolution(const LatticeFermion& sol, const LatticeFermion& src, XMLReader& fermacttop, 
                                       const std::string& fermact_id, GaugeConfigurationHandler* gaugeHandler)
{
 if (fermact_id!="CLOVER"){
    QDPIO::cout << "checkCloverSolution called for non-clover action; nothing to report"<<endl;
    return;}
 try{
    QDPIO::cout << "checking the clover solution"<<endl;
    typedef LatticeFermion               T;
    typedef multi1d<LatticeColorMatrix>  P;
    Handle< FermionAction<T,P,P> > S_f; 
    Handle< FermState<T,P,P> > state;
    S_f=TheFermionActionFactory::Instance().createObject(
            fermact_id,fermacttop,"./descendant-or-self::FermionAction");//}
    state=S_f->createState(gaugeHandler->getData());
    int Tdir = gaugeHandler->getGaugeConfigurationInfo().getTimeDir();
    int Textent = gaugeHandler->getGaugeConfigurationInfo().getTimeExtent();
    Set timeslices;                         // needed for time slice masks
    timeslices.make(TimeSlice(Tdir)); 

    CloverFermActParams cparams(fermacttop,"./descendant-or-self::FermionAction");
    UnprecCloverLinOp Dclover(state,cparams);
    LatticeFermion r=src;
    LatticeFermion Mx;
    Dclover( Mx, sol, PLUS);
    r -= Mx;

    double ynorm2=toDouble(norm2(src));
    LatticeReal lnorm=localNorm2(r);
    double localmag=toDouble(sqrt(globalMax(lnorm)/ynorm2));
    double relresidunprec=toDouble(sqrt(sum(lnorm)/ynorm2));

    multi1d<Real> tres(Textent);
    tres = sumMulti(lnorm, timeslices);

    QDPIO::cout << " Relative residual from Chroma is  r = M*x-y / |y|"
                << " for unpreconditioned system"<<endl;
    QDPIO::cout << " Relative residual of unpreconditioned system = |r| = "
                << relresidunprec << endl;
    QDPIO::cout << "                       Maximum local magnitude of r = "
                <<localmag<< endl;
    QDPIO::cout << "  Residual per timeslice: " <<endl;
    for (int iT = 0; iT < Textent; iT++)
       QDPIO::cout << "    t = " << iT << " : " << sqrt(tres[iT]/ynorm2) << endl;}
 catch(const std::exception& xp) {
    QDPIO::cout << "could not evaluate relative residual of "
    << "unpreconditioned clover system"<<endl;}
}

*/

 // ************************************************************************************

/*
const LattField* QuarkHandler::getData(
                                     bool source, 
                                     const LaphNoiseInfo& noise,
                                     int time_proj_index,
                                     int spinlev_dilution_index, int spin,
                                     const DirPath& displace, int disp_length,
                                     int time)
{
 map<StorageKey,LattField*>& store_map 
   = (source) ? store_sources : store_sinks;

 StorageKey skey(FileKey(noise,time_proj_index),
                 RecordKey(spin,time,spinlev_dilution_index),
                 displace,disp_length);

    // if already in map, return pointer

 map<StorageKey,LattField*>::const_iterator it
              =store_map.find(skey);
 if (it!=store_map.end()){
    return (it->second);}

    // else, must go to file and compute

 check_info_set("getData");
 if (source){
      // check time projector index, spin dilution
    if ((!dilHandler->isOnTime(time_proj_index,time)) 
      ||(!dilHandler->isOnSpin(spinlev_dilution_index,mode_spin(spin)-1))){
       //store_map.insert(std::make_pair<StorageKey,LattField*>(skey,0));
       return 0;}}

      // read undisplaced data from file (include in map)
 const LattField* start
   =(source) ? getSourceNoDisplace(skey.fkey,skey.rkey)
             : getSinkNoDisplace(skey.fkey,skey.rkey);

 if (skey.disp_length==0) return start;

   // calculate displacement
 LattField *finish;
 try{
    finish=new LattField;}
 catch(const std::exception& xp){
    errorLaph("could not allocation memory for set in QuarkHandler"<<endl;
    QDP_abort(1);}
 store_map.insert(make_pair(skey,finish));
 
 int numdisplace=skey.disp.Length();
 int seglength=skey.disp_length;
 DirPath::const_reverse_iterator seg=skey.disp.rbegin();

 if ((numdisplace%2)==1){  // odd number of displacements
    covdisplace(*start,*finish,*seg,seglength,time); ++seg;}
 if (numdisplace==1) return finish;

 LattField temp;
 if ((numdisplace%2)==0){
    covdisplace(*start,temp,*seg,seglength,time); ++seg;
    covdisplace(temp,*finish,*seg,seglength,time); ++seg;}
 for (int k=0;k<((numdisplace-1)/2);k++){
    covdisplace(*finish,temp,*seg,seglength,time); ++seg;
    covdisplace(temp,*finish,*seg,seglength,time); ++seg;}

 return finish;
}


multi1d<Complex> QuarkHandler::getCoefficients(
                                     bool source, 
                                     const LaphNoiseInfo& noise,
                                     int time_proj_index,
                                     int spinlev_dilution_index, int spin,
                                     int time)
{
  // TODO implement cache mechanism
 //map<StorageKey,LattField*>& store_map 
 //  = (source) ? store_sources : store_sinks;

 StorageKey skey(FileKey(noise,time_proj_index),
                 RecordKey(spin,time,spinlev_dilution_index),
                 DirPath(),0);

    // if already in map, return pointer

 / *map<StorageKey,LattField*>::const_iterator it
              =store_map.find(skey);
 if (it!=store_map.end()){
    return (it->second);} * /

    // else, must go to file and read

 check_info_set("getCoefficients");
 if (source){
      // check time projector index, spin dilution
    if ((!dilHandler->isOnTime(time_proj_index,time)) 
      ||(!dilHandler->isOnSpin(spinlev_dilution_index,mode_spin(spin)-1))){

        // return size-0 coefficients
      multi1d<Complex> ret;
      return ret;
    }
 }

      // read data from file (include in map)
 return (source) ? getSourceCoeffs(skey.fkey,skey.rkey)
                : getSinkCoeffs(skey.fkey,skey.rkey);
}


const LattField* QuarkHandler::getSinkNoDisplace(
                              const FileKey& fkey, const RecordKey& rkey)
{
 StorageKey skey(fkey,rkey,DirPath(),0);
 map<StorageKey,LattField*>::const_iterator fitr
         =store_sinks.find(skey);
 if (fitr!=store_sinks.end()) return (fitr->second);

 int gsign=1;
 DataType coefs;
 int nEigs = qSmearPtr->getNumberOfLaplacianEigenvectors();
 int t=rkey.getTime();
 RecordKey rgkey(rkey);
 if (!normal_mode) rgkey.applyGamma5Herm(gsign);

 coefs=DHgetPtr->getData(fkey,rgkey);
 if (coefs.size()!=nEigs){
    errorLaph("number of eigenvectors is wrong!!"<<endl;
    QDP_abort(1);}

 LattField *buf=0;
 try {
    buf=new LattField;
    *buf=zero;
    for (int n=0;n<nEigs;n++) 
       (*buf)+=coefs[n]*qSmearHandler->getLaphEigenvector(t,n);
    if (gsign==-1) *buf=-(*buf);}
 catch(const std::exception& xp){
    delete buf;
    errorLaph("Error during QuarkHandler lookup"<<endl;
    QDP_abort(1);}

 DHgetPtr->removeData(fkey,rgkey);
 store_sinks.insert(make_pair(skey,buf));
 return buf;
}


QuarkHandler::DataType QuarkHandler::getSinkCoeffs(
                              const FileKey& fkey, const RecordKey& rkey)
{
 int gsign=1;
 DataType coefs;
 int nEigs = qSmearPtr->getNumberOfLaplacianEigenvectors();
 int t=rkey.getTime();
 RecordKey rgkey(rkey);
 if (!normal_mode) rgkey.applyGamma5Herm(gsign);

 coefs=DHgetPtr->getData(fkey,rgkey);
 if (coefs.size()!=nEigs){
    errorLaph("number of eigenvectors is wrong!!"<<endl;
    QDP_abort(1);}

 if (gsign==-1) coefs*=-1.;

   // keep in memory at the data_io_handler level
 //DHgetPtr->removeData(fkey,rgkey);
 
 return coefs;
}


const LattField* QuarkHandler::getSourceNoDisplace(
                              const FileKey& fkey, const RecordKey& rkey)
{
 StorageKey skey(fkey,rkey,DirPath(),0);
 map<StorageKey,LattField*>::const_iterator fitr
         =store_sources.find(skey);
 if (fitr!=store_sources.end()) return (fitr->second);

 int gsign=1;
 int time=rkey.getTime();
 RecordKey rgkey(rkey);
 if (!normal_mode){
    rgkey.applyGamma5Herm(gsign);
    gsign=-gsign;}
 int spin=rgkey.getSpin()-1;  // need zero-base here

     // set the noise vector 

 LaphZnNoise rho(fkey.noise.getZNGroup(),fkey.noise.getSeed(*uPtr));
 int Textent = uPtr->getTimeExtent();
 int nEigs = qSmearPtr->getNumberOfLaplacianEigenvectors();
  
 multi3d<DComplex> laph_noise=rho.generateLapHQuarkSource(time,Textent,nEigs,
                          qactionPtr->getTimeBoundaryConditions());
 if (gsign==-1){
    for (int v=0;v<nEigs;v++) laph_noise(time,spin,v)*=-1.0;}

 int sevdil=rkey.getSpinLaphEigvecIndex();
 const list<int>& on_eigs=dilHandler->getOnEigvecIndices(sevdil);
 LattField *buf=0;
 try {
    buf=new LattField;
    *buf=zero;
    for (list<int>::const_iterator vmask=on_eigs.begin();vmask!=on_eigs.end();vmask++)
       (*buf)+=laph_noise(time,spin,*vmask)
               *qSmearHandler->getLaphEigenvector(time,*vmask);}
 catch(const std::exception& xp){
    delete buf;
    errorLaph("Error during QuarkHandler lookup"<<endl;
    QDP_abort(1);}

 store_sources.insert(make_pair(skey,buf));
 return buf;
}


QuarkHandler::DataType QuarkHandler::getSourceCoeffs(
                              const FileKey& fkey, const RecordKey& rkey)
{
 int gsign=1;
 int time=rkey.getTime();
 RecordKey rgkey(rkey);
 if (!normal_mode){
    rgkey.applyGamma5Herm(gsign);
    gsign=-gsign;}
 int spin=rgkey.getSpin()-1;  // need zero-base here

     // set the noise vector 

 LaphZnNoise rho(fkey.noise.getZNGroup(),fkey.noise.getSeed(*uPtr));
 int Textent = uPtr->getTimeExtent();
 int Nspin = QDP::Ns;
 int nEigs = qSmearPtr->getNumberOfLaplacianEigenvectors();

 multi3d<DComplex> laph_noise=rho.generateLapHQuarkSource(time,Textent,nEigs,
                          qactionPtr->getTimeBoundaryConditions());
 multi1d<Complex> ret;
 ret.resize(nEigs);
 ret = zero;

 int sevdil=rkey.getSpinLaphEigvecIndex();
 const list<int>& on_eigs=dilHandler->getOnEigvecIndices(sevdil);

 for (list<int>::const_iterator vmask=on_eigs.begin();vmask!=on_eigs.end();vmask++)
   ret(*vmask) = laph_noise(time,spin,*vmask);

 if (gsign==-1)
   ret *= -1.;

 return ret;
}


void QuarkHandler::covdisplace(const LattField& start,
                               LattField& finish,
                               int dir, int length, int timeval)
{
 const multi1d<LatticeColorMatrix>& usmear
        =gSmearHandler->getSmearedGaugeFieldTimeSlice(timeval);

 int qdp_length=(dir>0)?length:-length;
 int qdp_dir=abs(dir)-1;       // in coefficient file, 1=x, 2=y, 3=z
                               // in displace subroutine x=0, y=1, z=2
// StopWatch timer;
// timer.start();
 finish=displace(usmear,start,qdp_length,qdp_dir);
// timer.stop();
// cout << "time to displace = "<<timer.getTimeInMicroseconds()<<" microseconds"<<endl;
}


QuarkHandler::DataType QuarkHandler::getLaphEigenvectorSinkCoefficients(
                                     const LaphNoiseInfo& noise,
                                     int time_proj_index,
                                     int spinlev_dilution_index, 
                                     int spin, int time)
{
 FileKey fkey(noise,time_proj_index);
 RecordKey rkey(spin,time,spinlev_dilution_index);
 DataType coefs;
 if (!DHgetPtr->queryData(fkey,rkey)){
    errorLaph("requested coefficients could not be found"<<endl;}
 else
    coefs=DHgetPtr->getData(fkey,rkey);
 return coefs;
}

 // *****************************************************


bool QuarkHandler::queryData(bool source, const LaphNoiseInfo& noise, 
                             int time_proj_index, int spinlev_dilution_index, 
                             int spin, int time)
{
 if (time==-1) time = uPtr->getMinTime(); // default time = -1
 if (time < uPtr->getMinTime() || time > uPtr->getMaxTime()) return false;
 if (source) return true;
 StorageKey skey(FileKey(noise,time_proj_index),
                 RecordKey(spin,time,spinlev_dilution_index),
                 DirPath(),0);
    // if already in map, return true
 map<StorageKey,LattField*>::const_iterator it
              =store_sinks.find(skey);
 if (it!=store_sinks.end()) return true;
 check_info_set("getData");
 RecordKey rgkey(skey.rkey);
 int gsign;
 if (!normal_mode) rgkey.applyGamma5Herm(gsign);
 return DHgetPtr->queryData(skey.fkey,rgkey);
}


        // remove from internal memory

void QuarkHandler::removeData(bool source, const LaphNoiseInfo& noise,
                              int time_proj_index, int spinlev_dilution_index, 
                              int spin, const DirPath& displace, 
                              int disp_length, int time)
{
 map<StorageKey,LattField*>& store_map 
   = (source) ? store_sources : store_sinks;

 StorageKey skey(FileKey(noise,time_proj_index),
                 RecordKey(spin,time,spinlev_dilution_index),
                 displace,disp_length);

    // if already in map, remove

 map<StorageKey,LattField*>::iterator it
              =store_map.find(skey);
 if (it!=store_map.end()){
    if (it->second != 0) delete it->second;
    store_map.erase(it);}
}



void QuarkHandler::clearOnlyDisplacedData()
{
 for (map<StorageKey,LattField*>::iterator it=store_sources.begin();
    it!=store_sources.end();){
    if ((it->first).disp_length==0) it++;
    else{
       map<StorageKey,LattField*>::iterator bt=it; it++;
       if (bt->second != 0) delete bt->second;
       store_sources.erase(bt);}}
 for (map<StorageKey,LattField*>::iterator it=store_sinks.begin();
    it!=store_sinks.end();){
    if ((it->first).disp_length==0) it++;
    else{
       map<StorageKey,LattField*>::iterator bt=it; it++;
       delete bt->second;
       store_sinks.erase(bt);}}
}
*/

void QuarkHandler::clearData()
{
 if (compute_mode) return;
 for (map<StorageKey,LattField*>::iterator it=store_sources.begin();
    it!=store_sources.end();++it){
    if (it->second != 0) delete it->second;}
 store_sources.clear();
 for (map<StorageKey,LattField*>::iterator it=store_sinks.begin();
    it!=store_sinks.end();++it){
    delete it->second;}
 store_sinks.clear();
 DHgetPtr->clearData();
}

/*
void QuarkHandler::clearGaugeData()
{
 if (gSmearHandler.get()) gSmearHandler->clearData();
 if (qSmearHandler.get()) qSmearHandler->clearLaphEigenvectors();
}


#endif

 */
// ***************************************************************

  //  static pointers (set to null in default constructor)

unique_ptr<GluonSmearingHandler> QuarkHandler::gSmearHandler;
unique_ptr<QuarkSmearingHandler> QuarkHandler::qSmearHandler;
unique_ptr<GaugeConfigurationHandler> QuarkHandler::gaugeHandler;

int QuarkHandler::gSmearCounter=0;
int QuarkHandler::qSmearCounter=0;
int QuarkHandler::gaugeCounter=0;
//bool QuarkHandler::keepInMemory=false;





  // **************************************************************
  //
  //   The class below is used for checking the computations
  //   of the needed quark sinks has been done.
  // 
  // **************************************************************
/*

QuarkChecker::QuarkChecker()
          : uPtr(0), gSmearPtr(0), qSmearPtr(0), dilPtr(0), qactionPtr(0),
            fPtr(0), dilHandler(0), DHgetPtr(0) {}


QuarkChecker::QuarkChecker(const GaugeConfigurationInfo& gaugeinfo,
                           const GluonSmearingInfo& gluonsmear,
                           const QuarkSmearingInfo& quarksmear,
                           const DilutionSchemeInfo& dil,
                           const QuarkActionInfo& quark,
                           const FileListInfo& flist)
          : dilHandler(0), DHgetPtr(0)
{
 set_info(gaugeinfo,gluonsmear,quarksmear,dil,quark,flist);
}

void QuarkChecker::setInfo(const GaugeConfigurationInfo& gaugeinfo,
                           const GluonSmearingInfo& gluonsmear,
                           const QuarkSmearingInfo& quarksmear,
                           const DilutionSchemeInfo& dil,
                           const QuarkActionInfo& quark,
                           const FileListInfo& flist)
{
 clear();
 set_info(gaugeinfo,gluonsmear,quarksmear,dil,quark,flist);
}


void QuarkChecker::set_info(const GaugeConfigurationInfo& gaugeinfo,
                            const GluonSmearingInfo& gluonsmear,
                            const QuarkSmearingInfo& quarksmear,
                            const DilutionSchemeInfo& dil,
                            const QuarkActionInfo& quark,
                            const FileListInfo& flist)
{
 try{
    uPtr = new GaugeConfigurationInfo(gaugeinfo);
    gSmearPtr = new GluonSmearingInfo(gluonsmear);
    qSmearPtr = new QuarkSmearingInfo(quarksmear);
    dilPtr = new DilutionSchemeInfo(dil);
    qactionPtr = new QuarkActionInfo(quark);
    fPtr = new FileListInfo(flist);

    DHgetPtr=new DataGetHandlerMF<QuarkChecker,QuarkHandler::FileKey,
                     QuarkHandler::RecordKey,QuarkHandler::DataType>(
                    *this,*fPtr,"Laph--QuarkSink","QuarkHandlerDataFile");
    }
 catch(const std::exception& xp){
    errorLaph("allocation problem in QuarkChecker"<<endl;
    QDP_abort(1);}

 connectDilutionHandler();

}


QuarkChecker::~QuarkChecker()
{
 clear();
}


void QuarkChecker::clear()
{
 try{
    delete uPtr;
    delete gSmearPtr;
    delete qSmearPtr;
    delete dilPtr;
    delete qactionPtr;
    delete fPtr;}
 catch(const std::exception& xp){ QDP_abort(1);}
 uPtr=0;
 gSmearPtr=0;
 qSmearPtr=0;
 dilPtr=0;
 qactionPtr=0;
 fPtr=0;
 disconnectDilutionHandler();
 delete DHgetPtr; DHgetPtr=0;
}


  // ********************************
  // *
  // *    sub-handler connections  (private)
  // *
  // ********************************

void QuarkChecker::connectDilutionHandler() const
{
 if (dilHandler!=0){
    errorLaph("QuarkChecker::connectDilutionHandler already connected"<<endl;
    QDP_abort(1);}
 try{
    dilHandler = new DilutionHandler(*dilPtr,*uPtr,*qSmearPtr);}
 catch(const std::exception& xp){
    errorLaph("allocation problem in QuarkChecker::connectDilutionHandler"<<endl;
    QDP_abort(1);}
}

void QuarkChecker::disconnectDilutionHandler() const
{
 try{ delete dilHandler;}
 catch(const std::exception& xp){
    errorLaph("delete problem in QuarkChecker::disconnectDilutionHandler"<<endl;
    QDP_abort(1);}
 dilHandler=0;
}



void QuarkChecker::getFileMap(XmlWriter& xmlout) const
{
 if (isInfoSet()) DHgetPtr->getFileMap(xmlout);
}

void QuarkChecker::outputKeys(XmlWriter& xmlout)
{
 if (isInfoSet()) DHgetPtr->outputKeys(xmlout);
}

set<QuarkHandler::FileKey> QuarkChecker::getNoisesAndTimeProjectors() const
{
 check_info_set("getNoisesAndTimeProjectors");
 return DHgetPtr->getFileKeys();
}

void QuarkChecker::getNoisesAndTimeProjectors(set<LaphNoiseInfo>& noises,
                                              set<int>& time_proj_indices) const
{
 check_info_set("getNoisesAndTimeProjectors");
 set<NoiseAndTimeProjector> nt=DHgetPtr->getFileKeys();
 for (set<NoiseAndTimeProjector>::const_iterator it=nt.begin();
      it!=nt.end();++it){
    noises.insert(it->noise);
    time_proj_indices.insert(it->time_proj_index);}
}

void QuarkChecker::getNoisesAndSourceTimes(set<LaphNoiseInfo>& noises,
                                           set<int>& source_times) const
{
 check_info_set("getNoisesAndSourceTimes");
 set<NoiseAndTimeProjector> nt=DHgetPtr->getFileKeys();
 for (set<NoiseAndTimeProjector>::const_iterator it=nt.begin();
      it!=nt.end();++it){
    noises.insert(it->noise);
    const list<int>& onts=getOnTimes(it->time_proj_index);
    source_times.insert(onts.begin(),onts.end());}
}


map<int,QuarkHandler::FileKey> QuarkChecker::getSuffixMap() const
{
 check_info_set("getSuffixMap");
 return DHgetPtr->getSuffixMap();
}


void QuarkChecker::outputSuffixMap()
{
 check_info_set("getSuffixMap");
 map<int,QuarkHandler::FileKey> suffixmap=DHgetPtr->getSuffixMap();
 QDPIO::cout <<endl<<"Suffix map:"<<endl;
 for (map<int,QuarkHandler::FileKey>::const_iterator it=suffixmap.begin();
      it!=suffixmap.end();++it){
    QDPIO::cout << "suffix "<<it->first<<":  LaphNoiseInfo seed = "
      << it->second.noise.getSeed()<<"  time proj index = "
      << it->second.time_proj_index << endl;}
 QDPIO::cout << endl;
}


void QuarkChecker::outputSuffixMap(TextFileWriter& fout)
{
 check_info_set("getSuffixMap");
 map<int,QuarkHandler::FileKey> suffixmap=DHgetPtr->getSuffixMap();
 fout <<"\nSuffix map:\n";
 for (map<int,QuarkHandler::FileKey>::const_iterator it=suffixmap.begin();
      it!=suffixmap.end();++it){
    fout << "suffix "<<it->first<<":  LaphNoiseInfo seed = "
      << it->second.noise.getSeed()<<"  time proj index = "
      << it->second.time_proj_index << "\n";}
 fout << "\n";
}



bool QuarkChecker::isInfoSet() const
{
 return ((uPtr!=0)&&(gSmearPtr!=0)&&(qSmearPtr!=0)&&(fPtr!=0)
        &&(dilPtr!=0)&&(qactionPtr!=0));
}


void QuarkChecker::check_info_set(const string& name) const
{
 if (!isInfoSet()){
    errorLaph("error in QuarkChecker:"<<endl;
    errorLaph("  must setInfo before calling "<<name<<endl;
    QDP_abort(1);}
}


const GaugeConfigurationInfo& QuarkChecker::getGaugeConfigurationInfo() const 
{
 check_info_set("getGaugeConfigurationInfo");
 return *uPtr;
}

const GluonSmearingInfo& QuarkChecker::getGluonSmearingInfo() const
{
 check_info_set("getGluonSmearingInfo");
 return *gSmearPtr;
}

const QuarkSmearingInfo& QuarkChecker::getQuarkSmearingInfo() const
{
 check_info_set("getQuarkSmearingInfo");
 return *qSmearPtr;
}

const DilutionSchemeInfo& QuarkChecker::getDilutionSchemeInfo() const 
{
 check_info_set("getDilutionSchemeInfo");
 return *dilPtr;
}

const QuarkActionInfo& QuarkChecker::getQuarkActionInfo() const 
{
 check_info_set("getQuarkActionInfo");
 return *qactionPtr;
}

const FileListInfo& QuarkChecker::getFileListInfo() const 
{
 check_info_set("getFileListInfo");
 return *fPtr;
}

int QuarkChecker::getNumberOfSpinEigvecDilutionProjectors() const 
{
 check_info_set("getNumberOfSpinEigvecDilutionProjectors");
 return dilHandler->getNumberOfSpinEigvecProjectors();
}

int QuarkChecker::getNumberOfTimeDilutionProjectors() const 
{
 check_info_set("getNumberOfTimeDilutionProjectors");
 return dilHandler->getNumberOfTimeProjectors();
}

int QuarkChecker::getTimeDilutionProjectorIndex(int time_val) const 
{
 check_info_set("getTimeDilutionProjectorIndex");
 return dilHandler->getTimeProjectorIndex(time_val);
}

const list<int>& QuarkChecker::getOnTimes(int time_proj_index) const 
{
 check_info_set("getOnTimes");
 return dilHandler->getOnTimes(time_proj_index);
}

bool QuarkChecker::isFullTimeDilution() const 
{
 check_info_set("isFullTimeDilution");
 return dilHandler->isFullTimeDilution();
}

int QuarkChecker::getTimeExtent() const 
{
 check_info_set("getTimeExtent");
 return uPtr->getTimeExtent();
}


void QuarkChecker::getHeader(XmlWriter& xmlout) const
{
 if (isInfoSet()){
    push(xmlout,"QuarkHandlerDataFile");
    uPtr->output(xmlout);
    gSmearPtr->output(xmlout);
    qSmearPtr->output(xmlout);
    dilPtr->output(xmlout);
    qactionPtr->output(xmlout);
    pop(xmlout);}
}

bool QuarkChecker::checkHeader(XmlReader& xml_in, int suffix)
{
 if (xml_tag_count(xml_in,"QuarkHandlerDataFile")!=1) return false;
 XmlReader xmlr(xml_in,"./descendant-or-self::QuarkHandlerDataFile");
 GaugeConfigurationInfo gauge_check(xmlr);
 GluonSmearingInfo gsmear_check(xmlr);
 QuarkSmearingInfo qsmear_check(xmlr);
 DilutionSchemeInfo dil_check(xmlr);
 QuarkActionInfo qaction_check(xmlr);
 try {
    uPtr->checkEqual(gauge_check);
    gSmearPtr->checkEqual(gsmear_check);
    qSmearPtr->checkEqual(qsmear_check);
    dilPtr->checkEqual(dil_check);
    qactionPtr->checkEqual(qaction_check); }
 catch(const std::exception& xp){ return false;}
 return true;
}

 // *****************************************************

QuarkHandler::DataType QuarkChecker::getLaphEigenvectorSinkCoefficients(
                                     const LaphNoiseInfo& noise,
                                     int time_proj_index,
                                     int spinlev_dilution_index, 
                                     int spin, int time)
{
 check_info_set("getLaphEigenvectorSinkCoefficients");
 QuarkHandler::FileKey fkey(noise,time_proj_index);
 QuarkHandler::RecordKey rkey(spin,time,spinlev_dilution_index);
 QuarkHandler::DataType coefs;
 if (!DHgetPtr->queryData(fkey,rkey)){
    errorLaph("requested coefficients could not be found"<<endl;}
 else
    coefs=DHgetPtr->getData(fkey,rkey);
 return coefs;
}


bool QuarkChecker::queryData(bool source, const LaphNoiseInfo& noise, 
                             int time_proj_index, int spinlev_dilution_index, 
                             int spin, int time)
{
 if (time == -1) time = uPtr->getMinTime();
 if (time < uPtr->getMinTime() || time > uPtr->getMaxTime())
    return false;
 if (source) return true;
 check_info_set("queryData");
 QuarkHandler::FileKey fkey(noise,time_proj_index);
 QuarkHandler::RecordKey rkey(spin,time,spinlev_dilution_index);
 return DHgetPtr->queryData(fkey,rkey);
}


void QuarkChecker::query(const set<LaphNoiseInfo>& noise_list,
                         int num_time_proj, TextFileWriter& outlog)
{
 outlog << "QUERY:\n";
 outlog << "  Number of time dilution projectors required = "<<num_time_proj<<"\n";
 outlog << "  Noise seeds: ";
 for (set<LaphNoiseInfo>::const_iterator nt=noise_list.begin();
      nt!=noise_list.end();nt++) outlog << " "<<nt->getSeed();
 outlog << "\n\n"; 

 set<QuarkHandler::FileKey> fkeylist=getNoisesAndTimeProjectors();
 map<LaphNoiseInfo,set<int> > comps;
 for (set<QuarkHandler::FileKey>::const_iterator it=fkeylist.begin();
      it!=fkeylist.end();it++){
     comps[it->noise].insert(it->time_proj_index);}

 map<LaphNoiseInfo,set<int> >::const_iterator mt;
 for (set<LaphNoiseInfo>::const_iterator nt=noise_list.begin();
      nt!=noise_list.end();nt++){
   mt=comps.find(*nt);
   if (mt==comps.end()){
      outlog << "Noise "<<nt->getSeed()<<" is MISSING\n";}
   else{
      outlog << "For noise "<<nt->getSeed()<<" found time projector indices: ";
      for (set<int>::const_iterator st=mt->second.begin();st!=mt->second.end();++st)
         outlog <<" "<<*st;
      outlog << "\n";
      int nmiss=num_time_proj-mt->second.size();
      if (nmiss==1)
         outlog << "  1 time projector index is MISSING\n";
      else if (nmiss>1)
         outlog << "  "<<nmiss<<" time projector indices are MISSING\n";
      for (set<int>::const_iterator st=mt->second.begin();st!=mt->second.end();++st)
         checkCompletion(*nt,*st,outlog);}}
}


void QuarkChecker::checkCompletion(const LaphNoiseInfo& noise, 
                                   int time_proj_index, TextFileWriter& outlog)
{
 if (!isInfoSet()){
    errorLaph("cannot checkCompletion in QuarkChecker until info set"<<endl;
    QDP_abort(1);}
 if (!dilHandler->isValidTimeProjectorIndex(time_proj_index)) return;

 int Nspin = QDP::Ns;
 int minTime = uPtr->getMinTime();
 int maxTime = uPtr->getMaxTime();
// int nTimes = maxTime - minTime + 1;
 int ndil=dilHandler->getNumberOfSpinEigvecProjectors();
 QuarkHandler::FileKey fkey(noise,time_proj_index);

   DataGetHandlerMF<QuarkChecker,QuarkHandler::FileKey,
       QuarkHandler::RecordKey,QuarkHandler::DataType>* FDH=DHgetPtr;

 if (!FDH->queryFile(fkey)){
    outlog << "\n MISSING:  LaphNoiseInfo seed= "<<noise.getSeed()
           << " time proj index = "<<time_proj_index<<"\n";
    outlog <<"    All dilution indices\n\n";
    return;}

 bool firsttime=true;
 for (int dil=0;dil<ndil;dil++){
    bool fail=false;
    for (int t=minTime;t<=maxTime;t++)
    for (int s=1;s<=Nspin;s++){
       if (!FDH->queryData(fkey,QuarkHandler::RecordKey(s,t,dil))) fail=true;}
    if (fail){
       if (firsttime){
          outlog << "\n MISSING:  LaphNoiseInfo seed= "<<noise.getSeed()
                 << " time proj index = "<<time_proj_index<<"\n";
          firsttime=false;}
       outlog << "    Dilution index: "<<dil<<" \n";}}
 if (!firsttime) outlog << "\n\n";
}



  // **************************************************************
  //
  //   The class below is used for changing the LapH eigenvector
  //   dilution scheme.  
  // 
  // **************************************************************


QuarkUndiluter::QuarkUndiluter(const GaugeConfigurationInfo& gaugeinfo,
                               const GluonSmearingInfo& gluonsmear,
                               const QuarkSmearingInfo& quarksmear,
                               const DilutionSchemeInfo& indil,
                               const QuarkActionInfo& quark,
                               const FileListInfo& inflist,
                               const FileListInfo& outflist,
                               const DilutionSchemeInfo& outdil)
{
 try{
    uPtr = new GaugeConfigurationInfo(gaugeinfo);
    gSmearPtr = new GluonSmearingInfo(gluonsmear);
    qSmearPtr = new QuarkSmearingInfo(quarksmear);
    dilPtrIn = new DilutionSchemeInfo(indil);
    dilPtrOut = new DilutionSchemeInfo(outdil);
    qactionPtr = new QuarkActionInfo(quark);
    fPtrIn = new FileListInfo(inflist);
    fPtrOut = new FileListInfo(outflist);
    DHgetPtr=new DataGetHandlerMF<QuarkUndiluter,QuarkHandler::FileKey,
                     QuarkHandler::RecordKey,QuarkHandler::DataType>(
                    *this,*fPtrIn,"Laph--QuarkSink","QuarkHandlerDataFile");
    DHputPtr=new DataPutHandlerMF<QuarkUndiluter,QuarkHandler::FileKey,
                     QuarkHandler::RecordKey,QuarkHandler::DataType>(
                    *this,*fPtrOut,"Laph--QuarkSink","QuarkHandlerDataFile");
    indilHandler=new DilutionHandler(*dilPtrIn,*uPtr,*qSmearPtr);
    outdilHandler=new DilutionHandler(*dilPtrOut,*uPtr,*qSmearPtr);}
 catch(const std::exception& xp){
    errorLaph("allocation problem in QuarkUndiluter"<<endl;
    QDP_abort(1);}
}


QuarkUndiluter::~QuarkUndiluter()
{
 clear();
}


void QuarkUndiluter::clear()
{
 try{
    delete uPtr;
    delete gSmearPtr;
    delete qSmearPtr;
    delete dilPtrIn;
    delete dilPtrOut;
    delete qactionPtr;
    delete fPtrIn;
    delete fPtrOut;
    delete DHgetPtr;
    delete DHputPtr;
    delete indilHandler;
    delete outdilHandler;}
 catch(const std::exception& xp){ QDP_abort(1);}
 uPtr=0;
 gSmearPtr=0;
 qSmearPtr=0;
 dilPtrIn=0;
 dilPtrOut=0;
 qactionPtr=0;
 fPtrIn=0;
 fPtrOut=0;
 DHgetPtr=0;
 DHputPtr=0;
 indilHandler=0;
 outdilHandler=0;
}



bool QuarkUndiluter::checkHeader(XmlReader& xml_in, int suffix)
{
 if (xml_tag_count(xml_in,"QuarkHandlerDataFile")!=1) return false;
 XmlReader xmlr(xml_in,"./descendant-or-self::QuarkHandlerDataFile");
 GaugeConfigurationInfo gauge_check(xmlr);
 GluonSmearingInfo gsmear_check(xmlr);
 QuarkSmearingInfo qsmear_check(xmlr);
 DilutionSchemeInfo dil_check(xmlr);
 QuarkActionInfo qaction_check(xmlr);
 try {
    uPtr->checkEqual(gauge_check);
    gSmearPtr->checkEqual(gsmear_check);
    qSmearPtr->checkEqual(qsmear_check);
    dilPtrIn->checkEqual(dil_check);
    qactionPtr->checkEqual(qaction_check); }
 catch(const std::exception& xp){ return false;}
 return true;
}

void QuarkUndiluter::writeHeader(XmlWriter& xmlout, 
                                 const QuarkHandler::FileKey& fkey,
                                 int suffix)
{
 push(xmlout, "QuarkHandlerDataFile");
 uPtr->output(xmlout);
 gSmearPtr->output(xmlout);
 qSmearPtr->output(xmlout);
 dilPtrOut->output(xmlout);
 qactionPtr->output(xmlout);
 fkey.output(xmlout);
 pop(xmlout);
}

int QuarkUndiluter::getInSuffix(const QuarkHandler::FileKey& fkey) const
{
 std::map<int,QuarkHandler::FileKey> suffices=DHgetPtr->getSuffixMap();
 for (std::map<int,QuarkHandler::FileKey>::const_iterator it=suffices.begin();
      it!=suffices.end();++it)
    if (it->second == fkey) return it->first;
 errorLaph(" Could not get in suffix"<<endl;
 throw(std::invalid_argument("error"));
 return -1;
}

int QuarkUndiluter::getOutSuffix(const QuarkHandler::FileKey& fkey) const
{
 std::map<int,QuarkHandler::FileKey> suffices=DHputPtr->getSuffixMap();
 for (std::map<int,QuarkHandler::FileKey>::const_iterator it=suffices.begin();
      it!=suffices.end();++it)
    if (it->second == fkey) return it->first;
 errorLaph(" Could not get in suffix"<<endl;
 throw(std::invalid_argument("error"));
 return -1;
}


void QuarkUndiluter::undoDilution()
{

    //  figure out which two older indices are equivalent
    //  to each new spin-eigvec dilution index

 int ndil=outdilHandler->getNumberOfSpinEigvecProjectors();
 int old_ndil=indilHandler->getNumberOfSpinEigvecProjectors();
 
 QDPIO::cout <<endl<<"Performing undilution of quark sinks"<<endl<<endl;
 QDPIO::cout << "Original number of spin-lapheigv dilution indices = "<<old_ndil<<endl;
 QDPIO::cout << "     New number of spin-lapheigv dilution indices = "<<ndil<<endl<<endl;

 if (!(dilPtrIn->canUndilute(*dilPtrOut))){
    QDPIO::cout << "Incompatible dilution schemes: no undilution occurred"<<endl<<endl;
    return;}
 if (ndil>=old_ndil){
    QDPIO::cout << "No undilution requested: no undilution occurred"<<endl<<endl;
    return;}

 vector<set<int> > oldind_to_sum(ndil);
 for (int odil=0;odil<old_ndil;++odil){
    int spin=(indilHandler->getOnSpinIndices(odil)).front();
    int eigv=(indilHandler->getOnEigvecIndices(odil)).front();
    for (int dil=0;dil<ndil;++dil){
       if ((outdilHandler->isOnSpin(dil,spin))&&(outdilHandler->isOnEigvec(dil,eigv))){
          oldind_to_sum[dil].insert(odil);
          break;}}}

  //  do sum checks
 {bool flag=true;
 uint ndsum=old_ndil/ndil;
 set<int> checker;  
 for (int dil=0;dil<ndil;++dil){
    if (oldind_to_sum[dil].size()!=ndsum)
       flag=false;
    else{
       QDPIO::cout << "new dilution index = "<<dil <<" contains old dilution indices";
       for (set<int>::const_iterator ot=oldind_to_sum[dil].begin();ot!=oldind_to_sum[dil].end();++ot){
          QDPIO::cout <<" "<<*ot;  checker.insert(*ot);}
       QDPIO::cout <<endl;}}
 if (int(checker.size())!=old_ndil) flag=false;
 if (!flag){
    errorLaph("Determination of dilution index mapping failed"<<endl;
    throw(std::invalid_argument("Bad mapping"));}}
      
 int minTime = uPtr->getMinTime();
 int maxTime = uPtr->getMaxTime();
 int Nspin = QDP::Ns;
 QuarkHandler::DataType coefs,addcoefs;
 int neigs=qSmearPtr->getNumberOfLaplacianEigenvectors();
 QDPIO::cout << "Number of Laplacian eigenvectors = "<<neigs<<endl<<endl;

 set<QuarkHandler::FileKey> infkeys=DHgetPtr->getFileKeys();
 QDPIO::cout << endl<<"Number of files = "<<infkeys.size()<<endl;
 for (set<QuarkHandler::FileKey>::const_iterator it=infkeys.begin();it!=infkeys.end();++it){
    DHputPtr->open(*it);
    QDPIO::cout << "Undiluting file with suffix "<<getInSuffix(*it);
    QDPIO::cout << "  Output suffix is "<<getOutSuffix(*it);
    int count=0;
    for (int dil=0;dil<ndil;dil++){
       for (int t=minTime;t<=maxTime;t++)
       for (int s=1;s<=Nspin;s++){
//          QDPIO::cout << "dil = "<<dil<<" spin = "<<s<<" time = "<<t;
          try{
             QuarkHandler::RecordKey rkeyout(s,t,dil);
             bool inc=false;
             for (set<int>::const_iterator dilt=oldind_to_sum[dil].begin();
                               dilt!=oldind_to_sum[dil].end();++dilt){
                QuarkHandler::RecordKey rkey(s,t,*dilt);
                if (!DHgetPtr->queryData(*it,rkey)){
                   errorLaph("requested coefficients could not be found: dil = "<<dil<<endl;
                   throw(std::invalid_argument("error"));}
                addcoefs=DHgetPtr->getData(*it,rkey);
                if (addcoefs.size()!=neigs) throw(std::invalid_argument("error"));
                if (inc) coefs+=addcoefs;
                else {coefs=addcoefs; inc=true;}
                DHgetPtr->removeData(*it,rkey);}
             DHputPtr->putData(rkeyout,coefs);
             ++count;}
          catch(const std::exception& xp){
             errorLaph("undilution for dil = "<<dil<<" failed"<<endl;}}}

    QDPIO::cout << "  Number of records =  "<<count<<endl;
    DHgetPtr->clearData();
    DHputPtr->close();}
 QDPIO::cout <<endl<<endl<<"Undilution of quark sinks done."<<endl<<endl;
}

*/
// ***************************************************************
}
 
